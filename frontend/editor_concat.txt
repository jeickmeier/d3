// ========== FILE START: constants/color-constants.ts ==========
export const DEFAULT_COLORS = [
  {
    isBrightColor: false,
    name: "black",
    value: "#000000",
  },
  {
    isBrightColor: false,
    name: "dark grey 4",
    value: "#434343",
  },
  {
    isBrightColor: false,
    name: "dark grey 3",
    value: "#666666",
  },
  {
    isBrightColor: false,
    name: "dark grey 2",
    value: "#999999",
  },
  {
    isBrightColor: false,
    name: "dark grey 1",
    value: "#B7B7B7",
  },
  {
    isBrightColor: false,
    name: "grey",
    value: "#CCCCCC",
  },
  {
    isBrightColor: false,
    name: "light grey 1",
    value: "#D9D9D9",
  },
  {
    isBrightColor: true,
    name: "light grey 2",
    value: "#EFEFEF",
  },
  {
    isBrightColor: true,
    name: "light grey 3",
    value: "#F3F3F3",
  },
  {
    isBrightColor: true,
    name: "white",
    value: "#FFFFFF",
  },
  {
    isBrightColor: false,
    name: "red berry",
    value: "#980100",
  },
  {
    isBrightColor: false,
    name: "red",
    value: "#FE0000",
  },
  {
    isBrightColor: false,
    name: "orange",
    value: "#FE9900",
  },
  {
    isBrightColor: true,
    name: "yellow",
    value: "#FEFF00",
  },
  {
    isBrightColor: false,
    name: "green",
    value: "#00FF00",
  },
  {
    isBrightColor: false,
    name: "cyan",
    value: "#00FFFF",
  },
  {
    isBrightColor: false,
    name: "cornflower blue",
    value: "#4B85E8",
  },
  {
    isBrightColor: false,
    name: "blue",
    value: "#1300FF",
  },
  {
    isBrightColor: false,
    name: "purple",
    value: "#9900FF",
  },
  {
    isBrightColor: false,
    name: "magenta",
    value: "#FF00FF",
  },

  {
    isBrightColor: false,
    name: "light red berry 3",
    value: "#E6B8AF",
  },
  {
    isBrightColor: false,
    name: "light red 3",
    value: "#F4CCCC",
  },
  {
    isBrightColor: true,
    name: "light orange 3",
    value: "#FCE4CD",
  },
  {
    isBrightColor: true,
    name: "light yellow 3",
    value: "#FFF2CC",
  },
  {
    isBrightColor: true,
    name: "light green 3",
    value: "#D9EAD3",
  },
  {
    isBrightColor: false,
    name: "light cyan 3",
    value: "#D0DFE3",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 3",
    value: "#C9DAF8",
  },
  {
    isBrightColor: true,
    name: "light blue 3",
    value: "#CFE1F3",
  },
  {
    isBrightColor: true,
    name: "light purple 3",
    value: "#D9D2E9",
  },
  {
    isBrightColor: true,
    name: "light magenta 3",
    value: "#EAD1DB",
  },

  {
    isBrightColor: false,
    name: "light red berry 2",
    value: "#DC7E6B",
  },
  {
    isBrightColor: false,
    name: "light red 2",
    value: "#EA9999",
  },
  {
    isBrightColor: false,
    name: "light orange 2",
    value: "#F9CB9C",
  },
  {
    isBrightColor: true,
    name: "light yellow 2",
    value: "#FFE598",
  },
  {
    isBrightColor: false,
    name: "light green 2",
    value: "#B7D6A8",
  },
  {
    isBrightColor: false,
    name: "light cyan 2",
    value: "#A1C4C9",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 2",
    value: "#A4C2F4",
  },
  {
    isBrightColor: false,
    name: "light blue 2",
    value: "#9FC5E8",
  },
  {
    isBrightColor: false,
    name: "light purple 2",
    value: "#B5A7D5",
  },
  {
    isBrightColor: false,
    name: "light magenta 2",
    value: "#D5A6BD",
  },

  {
    isBrightColor: false,
    name: "light red berry 1",
    value: "#CC4125",
  },
  {
    isBrightColor: false,
    name: "light red 1",
    value: "#E06666",
  },
  {
    isBrightColor: false,
    name: "light orange 1",
    value: "#F6B26B",
  },
  {
    isBrightColor: false,
    name: "light yellow 1",
    value: "#FFD966",
  },
  {
    isBrightColor: false,
    name: "light green 1",
    value: "#93C47D",
  },
  {
    isBrightColor: false,
    name: "light cyan 1",
    value: "#76A5AE",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 1",
    value: "#6C9EEB",
  },
  {
    isBrightColor: false,
    name: "light blue 1",
    value: "#6FA8DC",
  },
  {
    isBrightColor: false,
    name: "light purple 1",
    value: "#8D7CC3",
  },
  {
    isBrightColor: false,
    name: "light magenta 1",
    value: "#C27BA0",
  },

  {
    isBrightColor: false,
    name: "dark red berry 1",
    value: "#A61B00",
  },
  {
    isBrightColor: false,
    name: "dark red 1",
    value: "#CC0000",
  },
  {
    isBrightColor: false,
    name: "dark orange 1",
    value: "#E59138",
  },
  {
    isBrightColor: false,
    name: "dark yellow 1",
    value: "#F1C231",
  },
  {
    isBrightColor: false,
    name: "dark green 1",
    value: "#6AA74F",
  },
  {
    isBrightColor: false,
    name: "dark cyan 1",
    value: "#45818E",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 1",
    value: "#3B78D8",
  },
  {
    isBrightColor: false,
    name: "dark blue 1",
    value: "#3E84C6",
  },
  {
    isBrightColor: false,
    name: "dark purple 1",
    value: "#664EA6",
  },
  {
    isBrightColor: false,
    name: "dark magenta 1",
    value: "#A64D78",
  },

  {
    isBrightColor: false,
    name: "dark red berry 2",
    value: "#84200D",
  },
  {
    isBrightColor: false,
    name: "dark red 2",
    value: "#990001",
  },
  {
    isBrightColor: false,
    name: "dark orange 2",
    value: "#B45F05",
  },
  {
    isBrightColor: false,
    name: "dark yellow 2",
    value: "#BF9002",
  },
  {
    isBrightColor: false,
    name: "dark green 2",
    value: "#38761D",
  },
  {
    isBrightColor: false,
    name: "dark cyan 2",
    value: "#124F5C",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 2",
    value: "#1155CB",
  },
  {
    isBrightColor: false,
    name: "dark blue 2",
    value: "#0C5394",
  },
  {
    isBrightColor: false,
    name: "dark purple 2",
    value: "#351C75",
  },
  {
    isBrightColor: false,
    name: "dark magenta 2",
    value: "#741B47",
  },

  {
    isBrightColor: false,
    name: "dark red berry 3",
    value: "#5B0F00",
  },
  {
    isBrightColor: false,
    name: "dark red 3",
    value: "#660000",
  },
  {
    isBrightColor: false,
    name: "dark orange 3",
    value: "#783F04",
  },
  {
    isBrightColor: false,
    name: "dark yellow 3",
    value: "#7E6000",
  },
  {
    isBrightColor: false,
    name: "dark green 3",
    value: "#274E12",
  },
  {
    isBrightColor: false,
    name: "dark cyan 3",
    value: "#0D343D",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 3",
    value: "#1B4487",
  },
  {
    isBrightColor: false,
    name: "dark blue 3",
    value: "#083763",
  },
  {
    isBrightColor: false,
    name: "dark purple 3",
    value: "#1F124D",
  },
  {
    isBrightColor: false,
    name: "dark magenta 3",
    value: "#4C1130",
  },
];

export const DEFAULT_CUSTOM_COLORS = [
  {
    isBrightColor: false,
    name: "dark orange 3",
    value: "#783F04",
  },
  {
    isBrightColor: false,
    name: "dark grey 3",
    value: "#666666",
  },
  {
    isBrightColor: false,
    name: "dark grey 2",
    value: "#999999",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 1",
    value: "#6C9EEB",
  },
  {
    isBrightColor: false,
    name: "dark magenta 3",
    value: "#4C1130",
  },
];

// ========== FILE END: constants/color-constants.ts ==========



// ========== FILE START: constants/emoji-icons.tsx ==========
import type React from "react";

import type { EmojiCategoryList } from "@udecode/plate-emoji";

import {
  AppleIcon,
  ClockIcon,
  CompassIcon,
  FlagIcon,
  LeafIcon,
  LightbulbIcon,
  MusicIcon,
  SearchIcon,
  SmileIcon,
  StarIcon,
  XIcon,
} from "lucide-react";

export const emojiCategoryIcons: Record<
  EmojiCategoryList,
  {
    outline: React.ReactElement;
    solid: React.ReactElement; // Needed to add another solid variant - outline will be used for now
  }
> = {
  activity: {
    outline: (
      <svg
        className="size-full"
        fill="none"
        stroke="currentColor"
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth="2"
        viewBox="0 0 24 24"
        xmlns="http://www.w3.org/2000/svg"
      >
        <circle cx="12" cy="12" r="10" />
        <path d="M2.1 13.4A10.1 10.1 0 0 0 13.4 2.1" />
        <path d="m5 4.9 14 14.2" />
        <path d="M21.9 10.6a10.1 10.1 0 0 0-11.3 11.3" />
      </svg>
    ),
    solid: (
      <svg
        className="size-full"
        fill="none"
        stroke="currentColor"
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth="2"
        viewBox="0 0 24 24"
        xmlns="http://www.w3.org/2000/svg"
      >
        <circle cx="12" cy="12" r="10" />
        <path d="M2.1 13.4A10.1 10.1 0 0 0 13.4 2.1" />
        <path d="m5 4.9 14 14.2" />
        <path d="M21.9 10.6a10.1 10.1 0 0 0-11.3 11.3" />
      </svg>
    ),
  },

  custom: {
    outline: <StarIcon className="size-full" />,
    solid: <StarIcon className="size-full" />,
  },

  flags: {
    outline: <FlagIcon className="size-full" />,
    solid: <FlagIcon className="size-full" />,
  },

  foods: {
    outline: <AppleIcon className="size-full" />,
    solid: <AppleIcon className="size-full" />,
  },

  frequent: {
    outline: <ClockIcon className="size-full" />,
    solid: <ClockIcon className="size-full" />,
  },

  nature: {
    outline: <LeafIcon className="size-full" />,
    solid: <LeafIcon className="size-full" />,
  },

  objects: {
    outline: <LightbulbIcon className="size-full" />,
    solid: <LightbulbIcon className="size-full" />,
  },

  people: {
    outline: <SmileIcon className="size-full" />,
    solid: <SmileIcon className="size-full" />,
  },

  places: {
    outline: <CompassIcon className="size-full" />,
    solid: <CompassIcon className="size-full" />,
  },

  symbols: {
    outline: <MusicIcon className="size-full" />,
    solid: <MusicIcon className="size-full" />,
  },
};

export const emojiSearchIcons = {
  delete: <XIcon className="size-4 text-current" />,
  loupe: <SearchIcon className="size-4 text-current" />,
};

// ========== FILE END: constants/emoji-icons.tsx ==========



// ========== FILE START: constants/prompts.ts ==========
export const DEFAULT_PROMPT_TEMPLATES = {
  continueWriting:
    "Continue writing after the current block. Provide one sentence of continuation.",
  summarize: "Summarize the above text in one sentence.",
  explain: "Explain the above content concisely.",
  improveWriting: "Improve the writing in the above text.",
  // Add additional prompt templates as needed
};

// ========== FILE END: constants/prompts.ts ==========



// ========== FILE START: constants/table-icons.tsx ==========
"use client";

import type { LucideProps } from "lucide-react";

export const BorderAll = (props: LucideProps) => (
  <svg
    fill="none"
    height="15"
    viewBox="0 0 15 15"
    width="15"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M0.25 1C0.25 0.585786 0.585786 0.25 1 0.25H14C14.4142 0.25 14.75 0.585786 14.75 1V14C14.75 14.4142 14.4142 14.75 14 14.75H1C0.585786 14.75 0.25 14.4142 0.25 14V1ZM1.75 1.75V13.25H13.25V1.75H1.75Z"
      fill="currentColor"
      fillRule="evenodd"
    ></path>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="5"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="3"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="7"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="5" y="7"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="3" y="7"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="9" y="7"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="11" y="7"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="9"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="11"></rect>
  </svg>
);

export const BorderBottom = (props: LucideProps) => (
  <svg
    fill="none"
    height="15"
    viewBox="0 0 15 15"
    width="15"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M1 13.25L14 13.25V14.75L1 14.75V13.25Z"
      fill="currentColor"
      fillRule="evenodd"
    ></path>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="5"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="13" y="5"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="3"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="13" y="3"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="7"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="1"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="13" y="7"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="13" y="1"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="5" y="7"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="5" y="1"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="3" y="7"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="3" y="1"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="9" y="7"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="9" y="1"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="11" y="7"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="11" y="1"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="9"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="13" y="9"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="11"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="13" y="11"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="5"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="3"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="7"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="1"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="9"></rect>
    <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="11"></rect>
  </svg>
);

export const BorderLeft = (props: LucideProps) => (
  <svg
    fill="none"
    height="15"
    viewBox="0 0 15 15"
    width="15"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M1.75 1L1.75 14L0.249999 14L0.25 1L1.75 1Z"
      fill="currentColor"
      fillRule="evenodd"
    ></path>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 10 7)"
      width="1"
      x="10"
      y="7"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 10 13)"
      width="1"
      x="10"
      y="13"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 12 7)"
      width="1"
      x="12"
      y="7"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 12 13)"
      width="1"
      x="12"
      y="13"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 8 7)"
      width="1"
      x="8"
      y="7"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 14 7)"
      width="1"
      x="14"
      y="7"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 8 13)"
      width="1"
      x="8"
      y="13"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 14 13)"
      width="1"
      x="14"
      y="13"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 8 5)"
      width="1"
      x="8"
      y="5"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 14 5)"
      width="1"
      x="14"
      y="5"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 8 3)"
      width="1"
      x="8"
      y="3"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 14 3)"
      width="1"
      x="14"
      y="3"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 8 9)"
      width="1"
      x="8"
      y="9"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 14 9)"
      width="1"
      x="14"
      y="9"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 8 11)"
      width="1"
      x="8"
      y="11"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 14 11)"
      width="1"
      x="14"
      y="11"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 6 7)"
      width="1"
      x="6"
      y="7"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 6 13)"
      width="1"
      x="6"
      y="13"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 4 7)"
      width="1"
      x="4"
      y="7"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 4 13)"
      width="1"
      x="4"
      y="13"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 10 1)"
      width="1"
      x="10"
      y="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 12 1)"
      width="1"
      x="12"
      y="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 8 1)"
      width="1"
      x="8"
      y="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 14 1)"
      width="1"
      x="14"
      y="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 6 1)"
      width="1"
      x="6"
      y="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(90 4 1)"
      width="1"
      x="4"
      y="1"
    ></rect>
  </svg>
);

export const BorderNone = (props: LucideProps) => (
  <svg
    fill="none"
    height="15"
    viewBox="0 0 15 15"
    width="15"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="7"
      y="5.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="13"
      y="5.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="7"
      y="3.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="13"
      y="3.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="7"
      y="7.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="7"
      y="13.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="7"
      y="1.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="13"
      y="7.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="13"
      y="13.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="13"
      y="1.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="5"
      y="7.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="5"
      y="13.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="5"
      y="1.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="3"
      y="7.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="3"
      y="13.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="3"
      y="1.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="9"
      y="7.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="9"
      y="13.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="9"
      y="1.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="11"
      y="7.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="11"
      y="13.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="11"
      y="1.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="7"
      y="9.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="13"
      y="9.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="7"
      y="11.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="13"
      y="11.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="1"
      y="5.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="1"
      y="3.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="1"
      y="7.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="1"
      y="13.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="1"
      y="1.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="1"
      y="9.025"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      width="1"
      x="1"
      y="11.025"
    ></rect>
  </svg>
);

export const BorderRight = (props: LucideProps) => (
  <svg
    fill="none"
    height="15"
    viewBox="0 0 15 15"
    width="15"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M13.25 1L13.25 14L14.75 14L14.75 1L13.25 1Z"
      fill="currentColor"
      fillRule="evenodd"
    ></path>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 5 7)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 5 13)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 3 7)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 3 13)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 7 7)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 1 7)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 7 13)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 1 13)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 7 5)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 1 5)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 7 3)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 1 3)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 7 9)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 1 9)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 7 11)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 1 11)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 9 7)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 9 13)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 11 7)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 11 13)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 5 1)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 3 1)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 7 1)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 1 1)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 9 1)"
      width="1"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="matrix(0 1 1 0 11 1)"
      width="1"
    ></rect>
  </svg>
);

export const BorderTop = (props: LucideProps) => (
  <svg
    fill="none"
    height="15"
    viewBox="0 0 15 15"
    width="15"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M14 1.75L1 1.75L1 0.249999L14 0.25L14 1.75Z"
      fill="currentColor"
      fillRule="evenodd"
    ></path>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 8 10)"
      width="1"
      x="8"
      y="10"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 2 10)"
      width="1"
      x="2"
      y="10"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 8 12)"
      width="1"
      x="8"
      y="12"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 2 12)"
      width="1"
      x="2"
      y="12"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 8 8)"
      width="1"
      x="8"
      y="8"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 8 14)"
      width="1"
      x="8"
      y="14"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 2 8)"
      width="1"
      x="2"
      y="8"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 2 14)"
      width="1"
      x="2"
      y="14"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 10 8)"
      width="1"
      x="10"
      y="8"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 10 14)"
      width="1"
      x="10"
      y="14"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 12 8)"
      width="1"
      x="12"
      y="8"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 12 14)"
      width="1"
      x="12"
      y="14"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 6 8)"
      width="1"
      x="6"
      y="8"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 6 14)"
      width="1"
      x="6"
      y="14"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 4 8)"
      width="1"
      x="4"
      y="8"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 4 14)"
      width="1"
      x="4"
      y="14"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 8 6)"
      width="1"
      x="8"
      y="6"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 2 6)"
      width="1"
      x="2"
      y="6"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 8 4)"
      width="1"
      x="8"
      y="4"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 2 4)"
      width="1"
      x="2"
      y="4"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 14 10)"
      width="1"
      x="14"
      y="10"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 14 12)"
      width="1"
      x="14"
      y="12"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 14 8)"
      width="1"
      x="14"
      y="8"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 14 14)"
      width="1"
      x="14"
      y="14"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 14 6)"
      width="1"
      x="14"
      y="6"
    ></rect>
    <rect
      fill="currentColor"
      height="1"
      rx=".5"
      transform="rotate(-180 14 4)"
      width="1"
      x="14"
      y="4"
    ></rect>
  </svg>
);

// ========== FILE END: constants/table-icons.tsx ==========



// ========== FILE START: core/transforms.ts ==========
"use client";

import type { PlateEditor } from "@udecode/plate/react";

import {
  type NodeEntry,
  type Path,
  type TElement,
  PathApi,
} from "@udecode/plate";
import { insertCallout } from "@udecode/plate-callout";
import { CalloutPlugin } from "@udecode/plate-callout/react";
import { insertCodeBlock } from "@udecode/plate-code-block";
import { CodeBlockPlugin } from "@udecode/plate-code-block/react";
import { insertDate } from "@udecode/plate-date";
import { DatePlugin } from "@udecode/plate-date/react";
import { insertToc } from "@udecode/plate-heading";
import { TocPlugin } from "@udecode/plate-heading/react";
import { INDENT_LIST_KEYS, ListStyleType } from "@udecode/plate-indent-list";
import { IndentListPlugin } from "@udecode/plate-indent-list/react";
import { insertColumnGroup, toggleColumnGroup } from "@udecode/plate-layout";
import { ColumnItemPlugin, ColumnPlugin } from "@udecode/plate-layout/react";
import { LinkPlugin, triggerFloatingLink } from "@udecode/plate-link/react";
import { insertEquation, insertInlineEquation } from "@udecode/plate-math";
import {
  EquationPlugin,
  InlineEquationPlugin,
} from "@udecode/plate-math/react";
import {
  insertAudioPlaceholder,
  insertFilePlaceholder,
  insertMedia,
  insertVideoPlaceholder,
} from "@udecode/plate-media";
import {
  AudioPlugin,
  FilePlugin,
  ImagePlugin,
  MediaEmbedPlugin,
  VideoPlugin,
} from "@udecode/plate-media/react";
import { SuggestionPlugin } from "@udecode/plate-suggestion/react";
import {
  TableCellPlugin,
  TablePlugin,
  TableRowPlugin,
} from "@udecode/plate-table/react";

/**
 * Array of Plate plugin keys that are considered structural, meaning they
 * define the layout or structure of the content rather than formatting.
 * Used to identify elements that should not be easily replaced by other block types.
 */
export const STRUCTURAL_TYPES: string[] = [
  ColumnPlugin.key,
  ColumnItemPlugin.key,
  TablePlugin.key,
  TableRowPlugin.key,
  TableCellPlugin.key,
];

const ACTION_THREE_COLUMNS = "action_three_columns";

/**
 * Inserts a list node (e.g., bulleted, numbered, todo) into the editor.
 * @param editor The Plate editor instance.
 * @param type The specific list style type (e.g., 'decimal', 'disc', 'todo').
 */
const insertList = (editor: PlateEditor, type: string) => {
  editor.tf.insertNodes(
    editor.api.create.block({
      indent: 1,
      listStyleType: type,
    }),
    { select: true },
  );
};

const insertBlockMap: Record<
  string,
  (editor: PlateEditor, type: string) => void
> = {
  [INDENT_LIST_KEYS.todo]: insertList,
  [ListStyleType.Decimal]: insertList,
  [ListStyleType.Disc]: insertList,
  [ACTION_THREE_COLUMNS]: (editor) =>
    insertColumnGroup(editor, { columns: 3, select: true }),
  [AudioPlugin.key]: (editor) =>
    insertAudioPlaceholder(editor, { select: true }),
  [CalloutPlugin.key]: (editor) => insertCallout(editor, { select: true }),
  [CodeBlockPlugin.key]: (editor) => insertCodeBlock(editor, { select: true }),
  [EquationPlugin.key]: (editor) => insertEquation(editor, { select: true }),
  [FilePlugin.key]: (editor) => insertFilePlaceholder(editor, { select: true }),
  [ImagePlugin.key]: (editor) =>
    insertMedia(editor, {
      select: true,
      type: ImagePlugin.key,
    }),
  [MediaEmbedPlugin.key]: (editor) =>
    insertMedia(editor, {
      select: true,
      type: MediaEmbedPlugin.key,
    }),
  [TablePlugin.key]: (editor) =>
    editor.getTransforms(TablePlugin).insert.table({}, { select: true }),
  [TocPlugin.key]: (editor) => insertToc(editor, { select: true }),
  [VideoPlugin.key]: (editor) =>
    insertVideoPlaceholder(editor, { select: true }),
};

const insertInlineMap: Record<
  string,
  (editor: PlateEditor, type: string) => void
> = {
  [DatePlugin.key]: (editor) => insertDate(editor, { select: true }),
  [InlineEquationPlugin.key]: (editor) =>
    insertInlineEquation(editor, "", { select: true }),
  [LinkPlugin.key]: (editor) => triggerFloatingLink(editor, { focused: true }),
};

/**
 * Inserts a block element of a given type into the editor.
 * It uses a map (`insertBlockMap`) for custom insertion logic for specific block types,
 * otherwise, it inserts a generic block. It also handles removing the previous empty block
 * if the new block type is different.
 * @param editor The Plate editor instance.
 * @param type The type of the block element to insert.
 */
export const insertBlock = (editor: PlateEditor, type: string) => {
  editor.tf.withoutNormalizing(() => {
    const block = editor.api.block();

    if (!block) return;
    if (type in insertBlockMap) {
      insertBlockMap[type](editor, type);
    } else {
      editor.tf.insertNodes(editor.api.create.block({ type }), {
        at: PathApi.next(block[1]),
        select: true,
      });
    }
    if (getBlockType(block[0]) !== type) {
      editor.getApi(SuggestionPlugin).suggestion.withoutSuggestions(() => {
        editor.tf.removeNodes({ previousEmptyBlock: true });
      });
    }
  });
};

/**
 * Inserts an inline element of a given type into the editor.
 * It uses a map (`insertInlineMap`) for custom insertion logic for specific inline types.
 * @param editor The Plate editor instance.
 * @param type The type of the inline element to insert.
 */
export const insertInlineElement = (editor: PlateEditor, type: string) => {
  if (insertInlineMap[type]) {
    insertInlineMap[type](editor, type);
  }
};

const setList = (
  editor: PlateEditor,
  type: string,
  entry: NodeEntry<TElement>,
) => {
  editor.tf.setNodes(
    editor.api.create.block({
      indent: 1,
      listStyleType: type,
    }),
    {
      at: entry[1],
    },
  );
};

const setBlockMap: Record<
  string,
  (editor: PlateEditor, type: string, entry: NodeEntry<TElement>) => void
> = {
  [INDENT_LIST_KEYS.todo]: setList,
  [ListStyleType.Decimal]: setList,
  [ListStyleType.Disc]: setList,
  [ACTION_THREE_COLUMNS]: (editor) => toggleColumnGroup(editor, { columns: 3 }),
};

/**
 * Sets the type of the block element at the current selection or a specified path.
 * It handles unsetting list-related properties if the new type is not a list.
 * It uses a map (`setBlockMap`) for custom transformation logic for specific block types.
 * @param editor The Plate editor instance.
 * @param type The new type for the block element.
 * @param at Optional path to the block element to modify. Defaults to the current selection.
 */
export const setBlockType = (
  editor: PlateEditor,
  type: string,
  { at }: { at?: Path } = {},
) => {
  editor.tf.withoutNormalizing(() => {
    const setEntry = (entry: NodeEntry<TElement>) => {
      const [node, path] = entry;

      if (node[IndentListPlugin.key]) {
        editor.tf.unsetNodes([IndentListPlugin.key, "indent"], { at: path });
      }
      if (type in setBlockMap) {
        return setBlockMap[type](editor, type, entry);
      }
      if (node.type !== type) {
        editor.tf.setNodes({ type }, { at: path });
      }
    };

    if (at) {
      const entry = editor.api.node<TElement>(at);

      if (entry) {
        setEntry(entry);

        return;
      }
    }

    const entries = editor.api.blocks({ mode: "lowest" });

    entries.forEach((entry) => setEntry(entry));
  });
};

/**
 * Gets the effective block type of a given TElement.
 * This is particularly useful for list items, as it correctly identifies
 * the list style type (decimal, todo, disc) instead of just a generic 'list-item' type.
 * For other elements, it returns the element's `type` property.
 * @param block The TElement to get the type from.
 * @returns The effective block type as a string.
 */
export const getBlockType = (block: TElement) => {
  if (block[IndentListPlugin.key]) {
    if (block[IndentListPlugin.key] === ListStyleType.Decimal) {
      return ListStyleType.Decimal;
    } else if (block[IndentListPlugin.key] === INDENT_LIST_KEYS.todo) {
      return INDENT_LIST_KEYS.todo;
    } else {
      return ListStyleType.Disc;
    }
  }

  return block.type;
};

// ========== FILE END: core/transforms.ts ==========



// ========== FILE START: core/use-chat.ts ==========
"use client";

import * as React from "react";

import { useChat as useBaseChat } from "@ai-sdk/react";

import { useSettings } from "../settings";
import { fakeStreamText } from "../lib/mock-chat-stream";

export const useChat = () => {
  const { aiModel } = useSettings();

  // remove when you implement the route /api/ai/command
  const abortControllerRef = React.useRef<AbortController | null>(null);
  const _abortFakeStream = () => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
  };

  const chat = useBaseChat({
    id: "editor",
    api: "/api/ai/command",
    // IMPORTANT: The OpenAI API key is now sourced from the NEXT_PUBLIC_OPENAI_API_KEY environment variable.
    // Ensure this variable is set in your .env.local file for development.
    // In a production environment, the /api/ai/command endpoint should securely manage the API key
    // and not rely on a client-exposed environment variable if possible, or ensure the key has minimal privileges.
    body: {
      apiKey: process.env.NEXT_PUBLIC_OPENAI_API_KEY,
      model: aiModel.value,
    },
    // Mock the API response. Remove it when you implement the route /api/ai/command
    fetch: async (input, init) => {
      const res = await fetch(input, init);

      if (!res.ok) {
        let sample: "markdown" | "mdx" | null = null;

        try {
          const content = JSON.parse(init?.body as string).messages.at(
            -1,
          ).content;

          if (content.includes("Generate a markdown sample")) {
            sample = "markdown";
          } else if (content.includes("Generate a mdx sample")) {
            sample = "mdx";
          }
        } catch {
          sample = null;
        }

        abortControllerRef.current = new AbortController();
        await new Promise((resolve) => setTimeout(resolve, 400));

        const stream = fakeStreamText({
          sample,
          signal: abortControllerRef.current.signal,
        });

        return new Response(stream, {
          headers: {
            Connection: "keep-alive",
            "Content-Type": "text/plain",
          },
        });
      }

      return res;
    },
  });

  return { ...chat, _abortFakeStream };
};

// ========== FILE END: core/use-chat.ts ==========



// ========== FILE START: core/use-create-editor.ts ==========
"use client";

import type { Value } from "@udecode/plate";
import * as React from "react";
import { useMemo } from "react";

import { withProps } from "@udecode/cn";
import { AIPlugin } from "@udecode/plate-ai/react";
import {
  BoldPlugin,
  CodePlugin,
  ItalicPlugin,
  StrikethroughPlugin,
  SubscriptPlugin,
  SuperscriptPlugin,
  UnderlinePlugin,
} from "@udecode/plate-basic-marks/react";
import { BlockquotePlugin } from "@udecode/plate-block-quote/react";
import { CalloutPlugin } from "@udecode/plate-callout/react";
import {
  CodeBlockPlugin,
  CodeLinePlugin,
  CodeSyntaxPlugin,
} from "@udecode/plate-code-block/react";
import { CommentsPlugin } from "@udecode/plate-comments/react";
import { DatePlugin } from "@udecode/plate-date/react";
import { EmojiInputPlugin } from "@udecode/plate-emoji/react";
import { ExcalidrawPlugin } from "@udecode/plate-excalidraw/react";
import { HEADING_KEYS } from "@udecode/plate-heading";
import { TocPlugin } from "@udecode/plate-heading/react";
import { HighlightPlugin } from "@udecode/plate-highlight/react";
import { HorizontalRulePlugin } from "@udecode/plate-horizontal-rule/react";
import { KbdPlugin } from "@udecode/plate-kbd/react";
import { ColumnItemPlugin, ColumnPlugin } from "@udecode/plate-layout/react";
import { LinkPlugin } from "@udecode/plate-link/react";
import {
  EquationPlugin,
  InlineEquationPlugin,
} from "@udecode/plate-math/react";
import {
  AudioPlugin,
  FilePlugin,
  ImagePlugin,
  MediaEmbedPlugin,
  PlaceholderPlugin,
  VideoPlugin,
} from "@udecode/plate-media/react";
import {
  MentionInputPlugin,
  MentionPlugin,
} from "@udecode/plate-mention/react";
import { SlashInputPlugin } from "@udecode/plate-slash-command/react";
import { SuggestionPlugin } from "@udecode/plate-suggestion/react";
import {
  TableCellHeaderPlugin,
  TableCellPlugin,
  TablePlugin,
  TableRowPlugin,
} from "@udecode/plate-table/react";
import { TogglePlugin } from "@udecode/plate-toggle/react";
import {
  ParagraphPlugin,
  PlateLeaf,
  usePlateEditor,
  type PlatePlugin,
} from "@udecode/plate/react";

import { editorPlugins } from "../plugins/editor-plugins";
import { AILeaf } from "../ui/elements/ai/ai-leaf";
import { BlockquoteElement } from "../ui/elements/blockquote/blockquote-element";
import { CalloutElement } from "../ui/elements/callout/callout-element";
import { CodeBlockElement } from "../ui/elements/code/code-block-element";
import { CodeLeaf } from "../ui/elements/code/code-leaf";
import { CodeLineElement } from "../ui/elements/code/code-line-element";
import { CodeSyntaxLeaf } from "../ui/elements/code/code-syntax-leaf";
import { ColumnElement } from "../ui/elements/layout/column-element";
import { ColumnGroupElement } from "../ui/elements/layout/column-group-element";
import { CommentLeaf } from "../ui/elements/comments-suggestions/comment-leaf";
import { DateElement } from "../ui/elements/date/date-element";
import { EmojiInputElement } from "../ui/menus/emoji/emoji-input-element";
import { EquationElement } from "../ui/elements/equation/equation-element";
import { ExcalidrawElement } from "../ui/elements/excalidraw/excalidraw-element";
import { HeadingElement } from "../ui/elements/heading/heading-element";
import { HighlightLeaf } from "../ui/elements/leafs/highlight-leaf";
import { HrElement } from "../ui/elements/heading/hr-element";
import { ImageElement } from "../ui/elements/image/image-element";
import { InlineEquationElement } from "../ui/elements/equation/inline-equation-element";
import { KbdLeaf } from "../ui/elements/leafs/kbd-leaf";
import { LinkElement } from "../ui/elements/link/link-element";
import { MediaAudioElement } from "../ui/elements/media/media-audio-element";
import { MediaEmbedElement } from "../ui/elements/media/media-embed-element";
import { MediaFileElement } from "../ui/elements/media/media-file-element";
import { MediaPlaceholderElement } from "../ui/elements/media/media-placeholder-element";
import { MediaVideoElement } from "../ui/elements/media/media-video-element";
import { MentionElement } from "../ui/elements/mention/mention-element";
import { MentionInputElement } from "../ui/elements/mention/mention-input-element";
import { ParagraphElement } from "../ui/elements/paragraph/paragraph-element";
import { withPlaceholders } from "../ui/primitives/placeholder";
import { SlashInputElement } from "../ui/elements/slash-input/slash-input-element";
import { SuggestionLeaf } from "../ui/elements/leafs/suggestion-leaf";
import {
  TableCellElement,
  TableCellHeaderElement,
} from "../ui/elements/table/table-cell-element";
import { TableElement } from "../ui/elements/table/table-element";
import { TableRowElement } from "../ui/elements/table/table-row-element";
import { TocElement } from "../ui/elements/toc/toc-element";
import { ToggleElement } from "../ui/elements/toggle/toggle-element";

import { discussionPlugin, TDiscussion } from "../plugins/discussion-plugin";
import { MyValue } from "../plate-types";

export const viewComponents = {
  [AudioPlugin.key]: MediaAudioElement,
  [BlockquotePlugin.key]: BlockquoteElement,
  [BoldPlugin.key]: withProps(PlateLeaf, { as: "strong" }),
  [CalloutPlugin.key]: CalloutElement,
  [CodeBlockPlugin.key]: CodeBlockElement,
  [CodeLinePlugin.key]: CodeLineElement,
  [CodePlugin.key]: CodeLeaf,
  [CodeSyntaxPlugin.key]: CodeSyntaxLeaf,
  [ColumnItemPlugin.key]: ColumnElement,
  [ColumnPlugin.key]: ColumnGroupElement,
  [CommentsPlugin.key]: CommentLeaf,
  [DatePlugin.key]: DateElement,
  [EquationPlugin.key]: EquationElement,
  [ExcalidrawPlugin.key]: ExcalidrawElement,
  [FilePlugin.key]: MediaFileElement,
  [HEADING_KEYS.h1]: withProps(HeadingElement, { variant: "h1" }),
  [HEADING_KEYS.h2]: withProps(HeadingElement, { variant: "h2" }),
  [HEADING_KEYS.h3]: withProps(HeadingElement, { variant: "h3" }),
  [HEADING_KEYS.h4]: withProps(HeadingElement, { variant: "h4" }),
  [HEADING_KEYS.h5]: withProps(HeadingElement, { variant: "h5" }),
  [HEADING_KEYS.h6]: withProps(HeadingElement, { variant: "h6" }),
  [HighlightPlugin.key]: HighlightLeaf,
  [HorizontalRulePlugin.key]: HrElement,
  [ImagePlugin.key]: ImageElement,
  [InlineEquationPlugin.key]: InlineEquationElement,
  [ItalicPlugin.key]: withProps(PlateLeaf, { as: "em" }),
  [KbdPlugin.key]: KbdLeaf,
  [LinkPlugin.key]: LinkElement,
  [MediaEmbedPlugin.key]: MediaEmbedElement,
  [MentionPlugin.key]: MentionElement,
  [ParagraphPlugin.key]: ParagraphElement,
  [PlaceholderPlugin.key]: MediaPlaceholderElement,
  [StrikethroughPlugin.key]: withProps(PlateLeaf, { as: "s" }),
  [SubscriptPlugin.key]: withProps(PlateLeaf, { as: "sub" }),
  [SuggestionPlugin.key]: SuggestionLeaf,
  [SuperscriptPlugin.key]: withProps(PlateLeaf, { as: "sup" }),
  [TableCellHeaderPlugin.key]: TableCellHeaderElement,
  [TableCellPlugin.key]: TableCellElement,
  [TablePlugin.key]: TableElement,
  [TableRowPlugin.key]: TableRowElement,
  [TocPlugin.key]: TocElement,
  [TogglePlugin.key]: ToggleElement,
  [UnderlinePlugin.key]: withProps(PlateLeaf, { as: "u" }),
  [VideoPlugin.key]: MediaVideoElement,
};

export const editorComponents = {
  ...viewComponents,
  [AIPlugin.key]: AILeaf,
  [EmojiInputPlugin.key]: EmojiInputElement,
  [MentionInputPlugin.key]: MentionInputElement,
  [SlashInputPlugin.key]: SlashInputElement,
};

// Placeholder for initial discussions, actual data might come from API or props
const initialDiscussions: TDiscussion[] = [];

// Define a more flexible type for hookOptions based on common usePlateEditor props
interface UseCreateEditorProps {
  id?: string;
  initialValue?: Value;
  plugins?: any[]; // Reverted to any[] due to complex type issues
  components?: Record<string, React.ComponentType<any>>;
  override?: Record<string, any>;
  readOnly?: boolean;
  placeholders?: boolean;
  currentUser?: {
    id: string;
    name?: string;
    avatarUrl?: string;
  };
  // Add other common Plate editor options if needed
}

export const useCreateEditor = (
  hookOptions: UseCreateEditorProps = {},
  deps: React.DependencyList = [],
) => {
  const {
    id = "main",
    initialValue: initialValueProp,
    plugins: hookGivenPlugins,
    components: hookGivenComponents,
    override,
    readOnly = false,
    placeholders = true,
    currentUser,
    ...restHookOptions
  } = hookOptions;

  const currentUserId = currentUser?.id || "anonymous";
  const currentUserName = currentUser?.name || "Anonymous";
  const avatarUrl = (seed: string) =>
    `https://api.dicebear.com/9.x/glass/svg?seed=${seed}`;
  const currentUserAvatar = currentUser?.avatarUrl || avatarUrl(currentUserId);

  const memoizedPlugins = useMemo(() => {
    let newPlugins = hookGivenPlugins || editorPlugins;

    // Dynamically configure the discussion plugin with current user data (always configure)
    {
      const baseDiscussionPluginOptions = discussionPlugin.options || {};
      const baseUsers = baseDiscussionPluginOptions.users || {};
      const baseDiscussions =
        baseDiscussionPluginOptions.discussions || initialDiscussions;

      const configuredDiscussionPlugin = discussionPlugin.extend({
        options: {
          ...baseDiscussionPluginOptions,
          currentUserId: currentUserId,
          users: {
            ...baseUsers,
            [currentUserId]: {
              id: currentUserId,
              name: currentUserName,
              avatarUrl: currentUserAvatar,
            },
          },
          discussions: baseDiscussions,
        },
      });

      if (
        newPlugins.findIndex(
          (p: PlatePlugin) => p.key === discussionPlugin.key,
        ) > -1
      ) {
        newPlugins = [...newPlugins]; // Create a new array instance for immutability
        newPlugins[
          newPlugins.findIndex(
            (p: PlatePlugin) => p.key === discussionPlugin.key,
          )
        ] = configuredDiscussionPlugin;
      } else {
        // If discussionPlugin wasn't in the initial set, add the configured version.
        // This might occur if hookGivenPlugins is provided and doesn't include it.
        newPlugins = [...newPlugins, configuredDiscussionPlugin];
      }
    }
    return newPlugins;
  }, [hookGivenPlugins, currentUserId, currentUserName, currentUserAvatar]);

  const resolvedComponents = useMemo(() => {
    const baseComps = readOnly
      ? viewComponents
      : placeholders
        ? withPlaceholders(editorComponents)
        : editorComponents;
    return { ...baseComps, ...hookGivenComponents };
  }, [readOnly, placeholders, hookGivenComponents]);

  const defaultValue = React.useMemo<MyValue>(
    () => [
      {
        type: ParagraphPlugin.key,
        children: [{ text: "Start typing..." }],
      },
    ],
    [],
  );

  const editor = usePlateEditor(
    {
      id,
      value: initialValueProp ?? defaultValue,
      plugins: memoizedPlugins,
      components: resolvedComponents,
      override,
      ...restHookOptions,
    },
    [
      id,
      initialValueProp,
      memoizedPlugins,
      resolvedComponents,
      override,
      ...deps,
    ],
  );

  return editor;
};

// ========== FILE END: core/use-create-editor.ts ==========



// ========== FILE START: lib/mock-chat-stream.ts ==========
import { faker } from "@faker-js/faker";

// Used for testing. Remove it after implementing useChat api.
export const fakeStreamText = ({
  chunkCount = 10,
  sample = null,
  signal,
  streamProtocol = "data",
}: {
  chunkCount?: number;
  sample?: "markdown" | "mdx" | null;
  signal?: AbortSignal;
  streamProtocol?: "data" | "text";
} = {}) => {
  const blocks = (() => {
    if (sample === "markdown") {
      return markdownChunks;
    }

    if (sample === "mdx") {
      return mdxChunks;
    }

    return [
      Array.from({ length: chunkCount }, () => ({
        delay: faker.number.int({ max: 100, min: 30 }),
        texts: faker.lorem.words({ max: 3, min: 1 }) + " ",
      })),

      Array.from({ length: chunkCount + 2 }, () => ({
        delay: faker.number.int({ max: 100, min: 30 }),
        texts: faker.lorem.words({ max: 3, min: 1 }) + " ",
      })),

      Array.from({ length: chunkCount + 4 }, () => ({
        delay: faker.number.int({ max: 100, min: 30 }),
        texts: faker.lorem.words({ max: 3, min: 1 }) + " ",
      })),
    ];
  })();

  const encoder = new TextEncoder();

  return new ReadableStream({
    async start(controller) {
      if (signal?.aborted) {
        controller.error(new Error("Aborted before start"));
        return;
      }

      const abortHandler = () => {
        controller.error(new Error("Stream aborted"));
      };

      signal?.addEventListener("abort", abortHandler);

      for (let i = 0; i < blocks.length; i++) {
        const block = blocks[i];

        // Stream the block content
        for (const chunk of block) {
          await new Promise((resolve) => setTimeout(resolve, chunk.delay));

          if (streamProtocol === "text") {
            controller.enqueue(encoder.encode(chunk.texts));
          } else {
            controller.enqueue(
              encoder.encode(`0:${JSON.stringify(chunk.texts)}\n`),
            );
          }
        }

        // Add double newline after each block except the last one
        if (i < blocks.length - 1) {
          if (streamProtocol === "text") {
            controller.enqueue(encoder.encode("\n\n"));
          } else {
            controller.enqueue(encoder.encode(`0:${JSON.stringify("\n\n")}\n`));
          }
        }
      }

      if (streamProtocol === "data") {
        controller.enqueue(
          `d:{"finishReason":"stop","usage":{"promptTokens":0,"completionTokens":${blocks.reduce(
            (sum, block) => sum + block.length,
            0,
          )}}}\n`,
        );
      }

      controller.close();
    },
  });
};

const delay = faker.number.int({ max: 20, min: 5 });

export const markdownChunks = [
  [
    { delay, texts: "Make text " },
    { delay, texts: "**bold**" },
    { delay, texts: ", " },
    { delay, texts: "*italic*" },
    { delay, texts: ", " },
    { delay, texts: "__underlined__" },
    { delay, texts: ", or apply a " },
    {
      delay,
      texts: "***combination***",
    },
    { delay, texts: " " },
    { delay, texts: "of " },
    { delay, texts: "these " },
    { delay, texts: "styles " },
    { delay, texts: "for " },
    { delay, texts: "a " },
    { delay, texts: "visually " },
    { delay, texts: "striking " },
    { delay, texts: "effect." },
    { delay, texts: "\n\n" },
    { delay, texts: "Add " },
    {
      delay,
      texts: "~~strikethrough~~",
    },
    { delay, texts: " " },
    { delay, texts: "to " },
    { delay, texts: "indicate " },
    { delay, texts: "deleted " },
    { delay, texts: "or " },
    { delay, texts: "outdated " },
    { delay, texts: "content." },
    { delay, texts: "\n\n" },
    { delay, texts: "Write " },
    { delay, texts: "code " },
    { delay, texts: "snippets " },
    { delay, texts: "with " },
    { delay, texts: "inline " },
    { delay, texts: "`code`" },
    { delay, texts: " formatting " },
    { delay, texts: "for " },
    { delay, texts: "easy " },
    { delay: faker.number.int({ max: 100, min: 30 }), texts: "readability." },
    { delay, texts: "\n\n" },
    { delay, texts: "Add " },
    {
      delay,
      texts: "[links](https://example.com)",
    },
    { delay: faker.number.int({ max: 100, min: 30 }), texts: " to " },
    { delay: faker.number.int({ max: 100, min: 30 }), texts: "external " },
    { delay, texts: "resources " },
    { delay, texts: "or " },
    {
      delay,
      texts: "references.\n\n",
    },

    { delay, texts: "Use " },
    { delay, texts: "inline " },
    { delay, texts: "math " },
    { delay, texts: "equations " },
    { delay, texts: "like " },
    { delay, texts: "$E = mc^2$ " },
    { delay, texts: "for " },
    { delay, texts: "scientific " },
    { delay, texts: "notation." },
    { delay, texts: "\n\n" },

    { delay, texts: "# " },
    { delay, texts: "Heading " },
    { delay, texts: "1\n\n" },
    { delay, texts: "## " },
    { delay, texts: "Heading " },
    { delay, texts: "2\n\n" },
    { delay, texts: "### " },
    { delay, texts: "Heading " },
    { delay, texts: "3\n\n" },
    { delay, texts: "> " },
    { delay, texts: "Blockquote\n\n" },
    { delay, texts: "- " },
    { delay, texts: "Unordered " },
    { delay, texts: "list " },
    { delay, texts: "item " },
    { delay, texts: "1\n" },
    { delay, texts: "- " },
    { delay, texts: "Unordered " },
    { delay, texts: "list " },
    { delay, texts: "item " },
    { delay, texts: "2\n\n" },
    { delay, texts: "1. " },
    { delay, texts: "Ordered " },
    { delay, texts: "list " },
    { delay, texts: "item " },
    { delay, texts: "1\n" },
    { delay, texts: "2. " },
    { delay, texts: "Ordered " },
    { delay, texts: "list " },
    { delay, texts: "item " },
    { delay, texts: "2\n\n" },
    { delay, texts: "- " },
    { delay, texts: "[ " },
    { delay, texts: "] " },
    { delay, texts: "Task " },
    { delay, texts: "list " },
    { delay, texts: "item " },
    { delay, texts: "1\n" },
    { delay, texts: "- " },
    { delay, texts: "[x] " },
    { delay, texts: "Task " },
    { delay, texts: "list " },
    { delay, texts: "item " },
    { delay, texts: "2\n\n" },
    { delay, texts: "![Alt " },
    {
      delay,
      texts:
        "text](https://images.unsplash.com/photo-1712688930249-98e1963af7bd?q=80&w=2070&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)\n\n",
    },
    {
      delay,
      texts: "### Advantage blocks:\n",
    },
    { delay, texts: "\n" },
    { delay, texts: "$$\n" },
    {
      delay,
      texts: "a^2 + b^2 = c^2\n",
    },
    { delay, texts: "$$\n" },
    { delay, texts: "\n" },
    { delay, texts: "```python\n" },
    { delay, texts: "# " },
    { delay, texts: "Code " },
    { delay, texts: "block\n" },
    { delay, texts: 'print("Hello, ' },
    { delay, texts: 'World!")\n' },
    { delay, texts: "```\n\n" },
    { delay, texts: "Horizontal " },
    { delay, texts: "rule\n\n" },
    { delay, texts: "---\n\n" },
    { delay, texts: "| " },
    { delay, texts: "Header " },
    { delay, texts: "1 " },
    { delay, texts: "| " },
    { delay, texts: "Header " },
    { delay, texts: "2 " },
    { delay, texts: "|\n" },
    {
      delay,
      texts: "|----------|----------|\n",
    },
    { delay, texts: "| " },
    { delay, texts: "Row " },
    { delay, texts: "1   " },
    { delay, texts: " | " },
    { delay, texts: "Data    " },
    { delay, texts: " |\n" },
    { delay, texts: "| " },
    { delay, texts: "Row " },
    { delay, texts: "2   " },
    { delay, texts: " | " },
    { delay, texts: "Data    " },
    { delay, texts: " |" },
  ],
];

export const mdxChunks = [
  [
    {
      delay,
      texts: "## ",
    },
    {
      delay,
      texts: "Basic ",
    },
    {
      delay,
      texts: "Markdown\n\n",
    },
    {
      delay,
      texts: "> ",
    },
    {
      delay,
      texts: "The ",
    },
    {
      delay,
      texts: "following ",
    },
    {
      delay,
      texts: "node ",
    },
    {
      delay,
      texts: "and ",
    },
    {
      delay,
      texts: "marks ",
    },
    {
      delay,
      texts: "is ",
    },
    {
      delay,
      texts: "supported ",
    },
    {
      delay,
      texts: "by ",
    },
    {
      delay,
      texts: "the ",
    },
    {
      delay,
      texts: "Markdown ",
    },
    {
      delay,
      texts: "standard.\n\n",
    },
    {
      delay,
      texts: "Format ",
    },
    {
      delay,
      texts: "text ",
    },
    {
      delay,
      texts: "with **b",
    },
    {
      delay,
      texts: "old**, _",
    },
    {
      delay,
      texts: "italic_,",
    },
    {
      delay,
      texts: " _**comb",
    },
    {
      delay,
      texts: "ined sty",
    },
    {
      delay,
      texts: "les**_, ",
    },
    {
      delay,
      texts: "~~strike",
    },
    {
      delay,
      texts: "through~~",
    },
    {
      delay,
      texts: ", `code`",
    },
    {
      delay,
      texts: " format",
    },
    {
      delay,
      texts: "ting, an",
    },
    {
      delay,
      texts: "d [hyper",
    },
    {
      delay,
      texts: "links](https://en.wikipedia.org/wiki/Hypertext).\n\n",
    },
    {
      delay,
      texts: "```javascript\n",
    },
    {
      delay,
      texts: "// Use code blocks to showcase code snippets\n",
    },
    {
      delay,
      texts: "function greet() {\n",
    },
    {
      delay,
      texts: '  console.info("Hello World!")\n',
    },
    {
      delay,
      texts: "}\n",
    },
    {
      delay,
      texts: "```\n\n",
    },
    {
      delay,
      texts: "- Simple",
    },
    {
      delay,
      texts: " lists f",
    },
    {
      delay,
      texts: "or organ",
    },
    {
      delay,
      texts: "ntent\n",
    },
    {
      delay,
      texts: "1. ",
    },
    {
      delay,
      texts: "Numbered ",
    },
    {
      delay,
      texts: "lists ",
    },
    {
      delay,
      texts: "for ",
    },
    {
      delay,
      texts: "sequential ",
    },
    {
      delay,
      texts: "steps\n\n",
    },
    {
      delay,
      texts: "| **Plugin**  | **Element** | **Inline** | **Void** |\n",
    },
    {
      delay,
      texts: "| ----------- | ----------- | ---------- | -------- |\n",
    },
    {
      delay,
      texts: "| **Heading** |             |            | No       |\n",
    },
    {
      delay,
      texts: "| **Image**   | Yes         | No         | Yes      |\n",
    },
    {
      delay,
      texts: "| **Ment",
    },
    {
      delay,
      texts: "ion** | Yes         | Yes        | Yes      |\n\n",
    },
    {
      delay,
      texts:
        "![](https://images.unsplash.com/photo-1712688930249-98e1963af7bd?q=80&w=2070&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)\n\n",
    },
    {
      delay,
      texts: "- [x] Co",
    },
    {
      delay,
      texts: "mpleted ",
    },
    {
      delay,
      texts: "tasks\n",
    },
    {
      delay,
      texts: "- [ ] Pe",
    },
    {
      delay,
      texts: "nding ta",
    },
    {
      delay,
      texts: "sks\n\n",
    },
    {
      delay,
      texts: "---\n\n## Advan",
    },
    {
      delay,
      texts: "ced Feat",
    },
    {
      delay,
      texts: "ures\n\n",
    },
    {
      delay,
      texts: "<callout> ",
    },
    {
      delay,
      texts: "The ",
    },
    {
      delay,
      texts: "following ",
    },
    {
      delay,
      texts: "node ",
    },
    {
      delay,
      texts: "and ",
    },
    {
      delay,
      texts: "marks ",
    },
    {
      delay,
      texts: "are ",
    },
    {
      delay,
      texts: "not ",
    },
    {
      delay,
      texts: "supported ",
    },
    {
      delay,
      texts: "in ",
    },
    {
      delay,
      texts: "Markdown ",
    },
    {
      delay,
      texts: "but ",
    },
    {
      delay,
      texts: "can ",
    },
    {
      delay,
      texts: "be ",
    },
    {
      delay,
      texts: "serialized ",
    },
    {
      delay,
      texts: "and ",
    },
    {
      delay,
      texts: "deserialized ",
    },
    {
      delay,
      texts: "using ",
    },
    {
      delay,
      texts: "MDX ",
    },
    {
      delay,
      texts: "or ",
    },
    {
      delay,
      texts: "specialized ",
    },
    {
      delay,
      texts: "UnifiedJS ",
    },
    {
      delay,
      texts: "plugins. ",
    },
    {
      delay,
      texts: "</callout>\n\n",
    },
    {
      delay,
      texts: "Advanced ",
    },
    {
      delay,
      texts: "marks: ",
    },
    {
      delay,
      texts: "<kbd> ",
    },
    {
      delay,
      texts: "+ ",
    },
    {
      delay,
      texts: "B</kbd>,<u>underlined</u>, ",
    },
    {
      delay,
      texts: "<mark",
    },
    {
      delay,
      texts: ">highli",
    },
    {
      delay,
      texts: "ghted</m",
    },
    {
      delay,
      texts: "ark",
    },
    {
      delay,
      texts: "> text, ",
    },
    {
      delay,
      texts: "<span s",
    },
    {
      delay,
      texts: 'tyle="co',
    },
    {
      delay,
      texts: "lor: #93",
    },
    {
      delay,
      texts: 'C47D;">c',
    },
    {
      delay,
      texts: "olored t",
    },
    {
      delay,
      texts: "ext</spa",
    },
    {
      delay,
      texts: "n> and ",
    },
    {
      delay,
      texts: "<spa",
    },
    {
      delay,
      texts: "n",
    },
    {
      delay,
      texts: ' style="',
    },
    {
      delay,
      texts: "backgrou",
    },
    {
      delay,
      texts: "nd-color",
    },
    {
      delay,
      texts: ": #6C9EE",
    },
    {
      delay,
      texts: 'B;">back',
    },
    {
      delay,
      texts: "ground h",
    },
    {
      delay,
      texts: "ighlight",
    },
    {
      delay,
      texts: "s</spa",
    },
    {
      delay,
      texts: "n> for ",
    },
    {
      delay,
      texts: "visual e",
    },
    {
      delay,
      texts: "mphasis.\n\n",
    },
    {
      delay,
      texts: "Superscript ",
    },
    {
      delay,
      texts: "like ",
    },
    {
      delay,
      texts: "E=mc<sup>2</sup> ",
    },
    {
      delay,
      texts: "and ",
    },
    {
      delay,
      texts: "subscript ",
    },
    {
      delay,
      texts: "like ",
    },
    {
      delay,
      texts: "H<sub>2</sub>O ",
    },
    {
      delay,
      texts: "demonstrate ",
    },
    {
      delay,
      texts: "mathematical ",
    },
    {
      delay,
      texts: "and ",
    },
    {
      delay,
      texts: "chemical ",
    },
    {
      delay,
      texts: "notation ",
    },
    {
      delay,
      texts: "capabilities.\n\n",
    },
    {
      delay,
      texts: "Add ",
    },
    {
      delay,
      texts: "mentions ",
    },
    {
      delay,
      texts: "like ",
    },
    {
      delay,
      texts: "@BB-8, d",
    },
    {
      delay,
      texts: "ates (<d",
    },
    {
      delay,
      texts: "ate>2025",
    },
    {
      delay,
      texts: "-05-08</",
    },
    {
      delay,
      texts: "date>), ",
    },
    {
      delay,
      texts: "and math",
    },
    {
      delay,
      texts: " formula",
    },
    {
      delay,
      texts: "s ($E=mc",
    },
    {
      delay,
      texts: "^2$).\n\n",
    },
    {
      delay,
      texts: "The ",
    },
    {
      delay,
      texts: "table ",
    },
    {
      delay,
      texts: "of ",
    },
    {
      delay,
      texts: "contents ",
    },
    {
      delay,
      texts: "feature ",
    },
    {
      delay,
      texts: "automatically ",
    },
    {
      delay,
      texts: "generates ",
    },
    {
      delay,
      texts: "document ",
    },
    {
      delay,
      texts: "structure ",
    },
    {
      delay,
      texts: "for ",
    },
    {
      delay,
      texts: "easy ",
    },
    {
      delay,
      texts: "navigation.\n\n",
    },
    {
      delay,
      texts: "<toc ",
    },
    {
      delay,
      texts: "/>\n\n",
    },
    {
      delay,
      texts: "Math ",
    },
    {
      delay,
      texts: "formula ",
    },
    {
      delay,
      texts: "support ",
    },
    {
      delay,
      texts: "makes ",
    },
    {
      delay,
      texts: "displaying ",
    },
    {
      delay,
      texts: "complex ",
    },
    {
      delay,
      texts: "mathematical ",
    },
    {
      delay,
      texts: "expressions ",
    },
    {
      delay,
      texts: "simple.\n\n",
    },
    {
      delay,
      texts: "$$\n",
    },
    {
      delay,
      texts: "a^2",
    },
    {
      delay,
      texts: "+b^2",
    },
    {
      delay,
      texts: "=c^2\n",
    },
    {
      delay,
      texts: "$$\n\n",
    },
    {
      delay,
      texts: "Multi-co",
    },
    {
      delay,
      texts: "lumn lay",
    },
    {
      delay,
      texts: "out feat",
    },
    {
      delay,
      texts: "ures ena",
    },
    {
      delay,
      texts: "ble rich",
    },
    {
      delay,
      texts: "er page ",
    },
    {
      delay,
      texts: "designs ",
    },
    {
      delay,
      texts: "and cont",
    },
    {
      delay,
      texts: "ent layo",
    },
    {
      delay,
      texts: "uts.\n\n",
    },
    // {
    //  delay,
    //   texts: '<column_group layout="[50,50]">\n',
    // },
    // {
    //  delay,
    //   texts: '<column width="50%">\n',
    // },
    // {
    //  delay,
    //   texts: '  left\n',
    // },
    // {
    //  delay,
    //   texts: '</column>\n',
    // },
    // {
    //  delay,
    //   texts: '<column width="50%">\n',
    // },
    // {
    //  delay,
    //   texts: '  right\n',
    // },
    // {
    //  delay,
    //   texts: '</column>\n',
    // },
    // {
    //  delay,
    //   texts: '</column_group>\n\n',
    // },
    {
      delay,
      texts: "PDF ",
    },
    {
      delay,
      texts: "embedding ",
    },
    {
      delay,
      texts: "makes ",
    },
    {
      delay,
      texts: "document ",
    },
    {
      delay,
      texts: "referencing ",
    },
    {
      delay,
      texts: "simple ",
    },
    {
      delay,
      texts: "and ",
    },
    {
      delay,
      texts: "intuitive.\n\n",
    },
    {
      delay,
      texts: "<file ",
    },
    {
      delay,
      texts: 'name="sample.pdf" ',
    },
    {
      delay,
      texts: 'align="center" ',
    },
    {
      delay,
      texts:
        'src="https://s26.q4cdn.com/900411403/files/doc_downloads/test.pdf" width="80%" isUpload="true" />\n\n',
    },
    {
      delay,
      texts: "Audio ",
    },
    {
      delay,
      texts: "players ",
    },
    {
      delay,
      texts: "can ",
    },
    {
      delay,
      texts: "be ",
    },
    {
      delay,
      texts: "embedded ",
    },
    {
      delay,
      texts: "directly ",
    },
    {
      delay,
      texts: "into ",
    },
    {
      delay,
      texts: "documents, ",
    },
    {
      delay,
      texts: "supporting ",
    },
    {
      delay,
      texts: "online ",
    },
    {
      delay,
      texts: "audio ",
    },
    {
      delay,
      texts: "resources.\n\n",
    },
    {
      delay,
      texts: "<audio ",
    },
    {
      delay,
      texts: 'align="center" ',
    },
    {
      delay,
      texts:
        'src="https://samplelib.com/lib/preview/mp3/sample-3s.mp3" width="80%" />\n\n',
    },
    {
      delay,
      texts: "Video ",
    },
    {
      delay,
      texts: "playback ",
    },
    {
      delay,
      texts: "features ",
    },
    {
      delay,
      texts: "support ",
    },
    {
      delay,
      texts: "embedding ",
    },
    {
      delay,
      texts: "various ",
    },
    {
      delay,
      texts: "online ",
    },
    {
      delay,
      texts: "video ",
    },
    {
      delay,
      texts: "resources, ",
    },
    {
      delay,
      texts: "enriching ",
    },
    {
      delay,
      texts: "document ",
    },
    {
      delay,
      texts: "content.\n\n",
    },
    {
      delay,
      texts: "<video ",
    },
    {
      delay,
      texts: 'align="center" ',
    },
    {
      delay,
      texts:
        'src="https://videos.pexels.com/video-files/6769791/6769791-uhd_2560_1440_24fps.mp4" width="80%" isUpload="true" />',
    },
  ],
];

// ========== FILE END: lib/mock-chat-stream.ts ==========



// ========== FILE START: plate-editor.tsx ==========
"use client";

import * as React from "react";
import { DndProvider } from "react-dnd";
import { HTML5Backend } from "react-dnd-html5-backend";

import { Plate } from "@udecode/plate/react";

import { useCreateEditor } from "./core/use-create-editor";
import { SettingsDialog } from "./settings";
import { Editor, EditorContainer } from "./ui/primitives/editor";

interface PlateEditorProps {
  currentUser?: {
    id: string;
    name?: string;
    avatarUrl?: string;
  };
}

export function PlateEditor({ currentUser }: PlateEditorProps) {
  const editor = useCreateEditor({ currentUser });

  return (
    <DndProvider backend={HTML5Backend}>
      <Plate editor={editor}>
        <EditorContainer>
          <Editor variant="demo" />
        </EditorContainer>

        <SettingsDialog />
      </Plate>
    </DndProvider>
  );
}

// ========== FILE END: plate-editor.tsx ==========



// ========== FILE START: plate-types.ts ==========
"use client";

import type React from "react";

import type { TElement, TText } from "@udecode/plate";
import type { BlockquotePlugin } from "@udecode/plate-block-quote/react";
import type {
  CodeBlockPlugin,
  CodeLinePlugin,
} from "@udecode/plate-code-block/react";
import type { TCommentText } from "@udecode/plate-comments";
import type { TExcalidrawElement } from "@udecode/plate-excalidraw";
import type { ExcalidrawPlugin } from "@udecode/plate-excalidraw/react";
import type { HEADING_KEYS } from "@udecode/plate-heading";
import type { HorizontalRulePlugin } from "@udecode/plate-horizontal-rule/react";
import type { TLinkElement } from "@udecode/plate-link";
import type { LinkPlugin } from "@udecode/plate-link/react";
import type { TImageElement, TMediaEmbedElement } from "@udecode/plate-media";
import type { ImagePlugin, MediaEmbedPlugin } from "@udecode/plate-media/react";
import type {
  TMentionElement,
  TMentionInputElement,
} from "@udecode/plate-mention";
import type {
  MentionInputPlugin,
  MentionPlugin,
} from "@udecode/plate-mention/react";
import type { TTableElement } from "@udecode/plate-table";
import type {
  TableCellPlugin,
  TablePlugin,
  TableRowPlugin,
} from "@udecode/plate-table/react";
import type { TToggleElement } from "@udecode/plate-toggle";
import type { TogglePlugin } from "@udecode/plate-toggle/react";
import type { ParagraphPlugin } from "@udecode/plate/react";

/** Text */

export type EmptyText = {
  text: "";
};

export interface MyAlignProps {
  align?: React.CSSProperties["textAlign"];
}

export interface MyBlockElement
  extends MyIndentListProps,
    MyLineHeightProps,
    TElement {
  id?: string;
}

/** Inline Elements */

export interface MyBlockquoteElement extends MyBlockElement {
  children: MyInlineChildren;
  type: typeof BlockquotePlugin.key;
}

export interface MyCodeBlockElement extends MyBlockElement {
  children: MyCodeLineElement[];
  type: typeof CodeBlockPlugin.key;
}

export interface MyCodeLineElement extends TElement {
  children: PlainText[];
  type: typeof CodeLinePlugin.key;
}

export interface MyExcalidrawElement
  extends MyBlockElement,
    TExcalidrawElement {
  children: [EmptyText];
  type: typeof ExcalidrawPlugin.key;
}

export interface MyH1Element extends MyBlockElement {
  children: MyInlineChildren;
  type: typeof HEADING_KEYS.h1;
}

export interface MyH2Element extends MyBlockElement {
  children: MyInlineChildren;
  type: typeof HEADING_KEYS.h2;
}

/** Block props */

export interface MyH3Element extends MyBlockElement {
  children: MyInlineChildren;
  type: typeof HEADING_KEYS.h3;
}

export interface MyHrElement extends MyBlockElement {
  children: [EmptyText];
  type: typeof HorizontalRulePlugin.key;
}

export interface MyImageElement extends MyBlockElement, TImageElement {
  children: [EmptyText];
  type: typeof ImagePlugin.key;
}

export interface MyIndentListProps extends MyIndentProps {
  listRestart?: number;
  listStart?: number;
  listStyleType?: string;
}

export interface MyIndentProps {
  indent?: number;
}

/** Blocks */

export type MyInlineChildren = MyInlineDescendant[];

export type MyInlineDescendant = MyInlineElement | RichText;

export type MyInlineElement =
  | MyLinkElement
  | MyMentionElement
  | MyMentionInputElement;

export interface MyLineHeightProps {
  lineHeight?: React.CSSProperties["lineHeight"];
}

export interface MyLinkElement extends TLinkElement {
  children: RichText[];
  type: typeof LinkPlugin.key;
}

export interface MyMediaEmbedElement
  extends MyBlockElement,
    TMediaEmbedElement {
  children: [EmptyText];
  type: typeof MediaEmbedPlugin.key;
}

export interface MyMentionElement extends TMentionElement {
  children: [EmptyText];
  type: typeof MentionPlugin.key;
}

export interface MyMentionInputElement extends TMentionInputElement {
  children: [PlainText];
  type: typeof MentionInputPlugin.key;
}

export type MyNestableBlock = MyParagraphElement;

export interface MyParagraphElement extends MyBlockElement {
  children: MyInlineChildren;
  type: typeof ParagraphPlugin.key;
}

export type MyRootBlock =
  | MyBlockquoteElement
  | MyCodeBlockElement
  | MyExcalidrawElement
  | MyH1Element
  | MyH2Element
  | MyH3Element
  | MyHrElement
  | MyImageElement
  | MyMediaEmbedElement
  | MyParagraphElement
  | MyTableElement
  | MyToggleElement;

export interface MyTableCellElement extends TElement {
  children: MyNestableBlock[];
  type: typeof TableCellPlugin.key;
}

export interface MyTableElement extends MyBlockElement, TTableElement {
  children: MyTableRowElement[];
  type: typeof TablePlugin.key;
}

export interface MyTableRowElement extends TElement {
  children: MyTableCellElement[];
  type: typeof TableRowPlugin.key;
}

export interface MyToggleElement extends MyBlockElement, TToggleElement {
  children: MyInlineChildren;
  type: typeof TogglePlugin.key;
}

export type MyValue = MyRootBlock[];

export type PlainText = {
  text: string;
};

export interface RichText extends TCommentText, TText {
  backgroundColor?: React.CSSProperties["backgroundColor"];
  bold?: boolean;
  code?: boolean;
  color?: React.CSSProperties["color"];
  fontFamily?: React.CSSProperties["fontFamily"];
  fontSize?: React.CSSProperties["fontSize"];
  fontWeight?: React.CSSProperties["fontWeight"];
  italic?: boolean;
  kbd?: boolean;
  strikethrough?: boolean;
  subscript?: boolean;
  underline?: boolean;
}

// export type MyElement = ElementOf<MyEditor>;

// export type MyBlock = Exclude<MyElement, MyInlineElement>;

// export type MyEditor = ReturnType<typeof useCreateEditor>;

// export const useEditor = () => useEditorRef<MyEditor>();

// ========== FILE END: plate-types.ts ==========



// ========== FILE START: plugins/ai-plugins.tsx ==========
"use client";

import * as React from "react";

import type { AIChatPluginConfig } from "@udecode/plate-ai/react";

import { PathApi } from "@udecode/plate";
import { streamInsertChunk, withAIBatch } from "@udecode/plate-ai";
import { AIChatPlugin, AIPlugin, useChatChunk } from "@udecode/plate-ai/react";
import { usePluginOption } from "@udecode/plate/react";

import { markdownPlugin } from "./markdown-plugin";
import { AILoadingBar } from "../ui/elements/ai/ai-loading-bar";
import { AIMenu } from "../ui/menus/ai/ai-menu";

import { cursorOverlayPlugin } from "./cursor-overlay-plugin";

const systemCommon = `\
You are an advanced AI-powered note-taking assistant, designed to enhance productivity and creativity in note management.
Respond directly to user prompts with clear, concise, and relevant content. Maintain a neutral, helpful tone.

Rules:
- <Document> is the entire note the user is working on.
- <Reminder> is a reminder of how you should reply to INSTRUCTIONS. It does not apply to questions.
- Anything else is the user prompt.
- Your response should be tailored to the user's prompt, providing precise assistance to optimize note management.
- For INSTRUCTIONS: Follow the <Reminder> exactly. Provide ONLY the content to be inserted or replaced. No explanations or comments.
- For QUESTIONS: Provide a helpful and concise answer. You may include brief explanations if necessary.
- CRITICAL: DO NOT remove or modify the following custom MDX tags: <u>, <callout>, <kbd>, <toc>, <sub>, <sup>, <mark>, <del>, <date>, <span>, <column>, <column_group>, <file>, <audio>, <video> in <Selection> unless the user explicitly requests this change.
- CRITICAL: Distinguish between INSTRUCTIONS and QUESTIONS. Instructions typically ask you to modify or add content. Questions ask for information or clarification.
- CRITICAL: when asked to write in markdown, do not start with \`\`\`markdown.
`;

const systemDefault = `\
${systemCommon}
- <Block> is the current block of text the user is working on.
- Ensure your output can seamlessly fit into the existing <Block> structure.

<Block>
{block}
</Block>
`;

const systemSelecting = `\
${systemCommon}
- <Block> is the block of text containing the user's selection, providing context.
- Ensure your output can seamlessly fit into the existing <Block> structure.
- <Selection> is the specific text the user has selected in the block and wants to modify or ask about.
- Consider the context provided by <Block>, but only modify <Selection>. Your response should be a direct replacement for <Selection>.
<Block>
{block}
</Block>
<Selection>
{selection}
</Selection>
`;

const systemBlockSelecting = `\
${systemCommon}
- <Selection> represents the full blocks of text the user has selected and wants to modify or ask about.
- Your response should be a direct replacement for the entire <Selection>.
- Maintain the overall structure and formatting of the selected blocks, unless explicitly instructed otherwise.
- CRITICAL: Provide only the content to replace <Selection>. Do not add additional blocks or change the block structure unless specifically requested.
<Selection>
{block}
</Selection>
`;

const userDefault = `<Reminder>
CRITICAL: NEVER write <Block>.
</Reminder>
{prompt}`;

const userSelecting = `<Reminder>
If this is a question, provide a helpful and concise answer about <Selection>.
If this is an instruction, provide ONLY the text to replace <Selection>. No explanations.
Ensure it fits seamlessly within <Block>. If <Block> is empty, write ONE random sentence.
NEVER write <Block> or <Selection>.
</Reminder>
{prompt} about <Selection>`;

const userBlockSelecting = `<Reminder>
If this is a question, provide a helpful and concise answer about <Selection>.
If this is an instruction, provide ONLY the content to replace the entire <Selection>. No explanations.
Maintain the overall structure unless instructed otherwise.
NEVER write <Block> or <Selection>.
</Reminder>
{prompt} about <Selection>`;

export const PROMPT_TEMPLATES = {
  systemBlockSelecting,
  systemDefault,
  systemSelecting,
  userBlockSelecting,
  userDefault,
  userSelecting,
};

export const aiPlugins = [
  cursorOverlayPlugin,
  markdownPlugin,
  AIPlugin,
  AIChatPlugin.configure({
    options: {
      promptTemplate: ({ isBlockSelecting, isSelecting }) => {
        return isBlockSelecting
          ? PROMPT_TEMPLATES.userBlockSelecting
          : isSelecting
            ? PROMPT_TEMPLATES.userSelecting
            : PROMPT_TEMPLATES.userDefault;
      },
      systemTemplate: ({ isBlockSelecting, isSelecting }) => {
        return isBlockSelecting
          ? PROMPT_TEMPLATES.systemBlockSelecting
          : isSelecting
            ? PROMPT_TEMPLATES.systemSelecting
            : PROMPT_TEMPLATES.systemDefault;
      },
    },
    render: {
      afterContainer: () => <AILoadingBar />,
      afterEditable: () => <AIMenu />,
    },
  }).extend({
    useHooks: ({ editor, getOption }) => {
      const mode = usePluginOption(
        { key: "aiChat" } as AIChatPluginConfig,
        "mode",
      );

      useChatChunk({
        onChunk: ({ chunk, isFirst, nodes }) => {
          if (isFirst && mode == "insert") {
            editor.tf.withoutSaving(() => {
              editor.tf.insertNodes(
                {
                  children: [{ text: "" }],
                  type: AIChatPlugin.key,
                },
                {
                  at: PathApi.next(editor.selection!.focus.path.slice(0, 1)),
                },
              );
            });
            editor.setOption(AIChatPlugin, "streaming", true);
          }

          if (mode === "insert" && nodes.length > 0) {
            withAIBatch(
              editor,
              () => {
                if (!getOption("streaming")) return;
                editor.tf.withScrolling(() => {
                  streamInsertChunk(editor, chunk, {
                    textProps: {
                      ai: true,
                    },
                  });
                });
              },
              { split: isFirst },
            );
          }
        },
        onFinish: () => {
          editor.setOption(AIChatPlugin, "streaming", false);
          editor.setOption(AIChatPlugin, "_blockChunks", "");
          editor.setOption(AIChatPlugin, "_blockPath", null);
        },
      });
    },
  }),
] as const;

// ========== FILE END: plugins/ai-plugins.tsx ==========



// ========== FILE START: plugins/align-plugin.ts ==========
"use client";

import { AlignPlugin } from "@udecode/plate-alignment/react";
import { HEADING_LEVELS } from "@udecode/plate-heading";
import { ImagePlugin, MediaEmbedPlugin } from "@udecode/plate-media/react";
import { ParagraphPlugin } from "@udecode/plate/react";

export const alignPlugin = AlignPlugin.extend({
  inject: {
    targetPlugins: [
      ParagraphPlugin.key,
      ...HEADING_LEVELS,
      MediaEmbedPlugin.key,
      ImagePlugin.key,
    ],
  },
});

// ========== FILE END: plugins/align-plugin.ts ==========



// ========== FILE START: plugins/autoformat-plugin.ts ==========
"use client";

import type { AutoformatRule } from "@udecode/plate-autoformat";

import {
  autoformatArrow,
  autoformatLegal,
  autoformatLegalHtml,
  autoformatMath,
  autoformatPunctuation,
  autoformatSmartQuotes,
} from "@udecode/plate-autoformat";
import { AutoformatPlugin } from "@udecode/plate-autoformat/react";
import {
  BoldPlugin,
  CodePlugin,
  ItalicPlugin,
  StrikethroughPlugin,
  SubscriptPlugin,
  SuperscriptPlugin,
  UnderlinePlugin,
} from "@udecode/plate-basic-marks/react";
import { BlockquotePlugin } from "@udecode/plate-block-quote/react";
import { insertEmptyCodeBlock } from "@udecode/plate-code-block";
import { CodeBlockPlugin } from "@udecode/plate-code-block/react";
import { HEADING_KEYS } from "@udecode/plate-heading";
import { HighlightPlugin } from "@udecode/plate-highlight/react";
import { HorizontalRulePlugin } from "@udecode/plate-horizontal-rule/react";
import {
  INDENT_LIST_KEYS,
  ListStyleType,
  toggleIndentList,
} from "@udecode/plate-indent-list";
import { openNextToggles, TogglePlugin } from "@udecode/plate-toggle/react";
import { ParagraphPlugin } from "@udecode/plate/react";

const autoformatMarks: AutoformatRule[] = [
  {
    match: "***",
    mode: "mark",
    type: [BoldPlugin.key, ItalicPlugin.key],
  },
  {
    match: "__*",
    mode: "mark",
    type: [UnderlinePlugin.key, ItalicPlugin.key],
  },
  {
    match: "__**",
    mode: "mark",
    type: [UnderlinePlugin.key, BoldPlugin.key],
  },
  {
    match: "___***",
    mode: "mark",
    type: [UnderlinePlugin.key, BoldPlugin.key, ItalicPlugin.key],
  },
  {
    match: "**",
    mode: "mark",
    type: BoldPlugin.key,
  },
  {
    match: "__",
    mode: "mark",
    type: UnderlinePlugin.key,
  },
  {
    match: "*",
    mode: "mark",
    type: ItalicPlugin.key,
  },
  {
    match: "_",
    mode: "mark",
    type: ItalicPlugin.key,
  },
  {
    match: "~~",
    mode: "mark",
    type: StrikethroughPlugin.key,
  },
  {
    match: "^",
    mode: "mark",
    type: SuperscriptPlugin.key,
  },
  {
    match: "~",
    mode: "mark",
    type: SubscriptPlugin.key,
  },
  {
    match: "==",
    mode: "mark",
    type: HighlightPlugin.key,
  },
  {
    match: "",
    mode: "mark",
    type: HighlightPlugin.key,
  },
  {
    match: "`",
    mode: "mark",
    type: CodePlugin.key,
  },
];

const autoformatBlocks: AutoformatRule[] = [
  {
    match: "# ",
    mode: "block",
    type: HEADING_KEYS.h1,
  },
  {
    match: "## ",
    mode: "block",
    type: HEADING_KEYS.h2,
  },
  {
    match: "### ",
    mode: "block",
    type: HEADING_KEYS.h3,
  },
  {
    match: "#### ",
    mode: "block",
    type: HEADING_KEYS.h4,
  },
  {
    match: "##### ",
    mode: "block",
    type: HEADING_KEYS.h5,
  },
  {
    match: "###### ",
    mode: "block",
    type: HEADING_KEYS.h6,
  },
  {
    match: "> ",
    mode: "block",
    type: BlockquotePlugin.key,
  },
  {
    match: "```",
    mode: "block",
    type: CodeBlockPlugin.key,
    format: (editor) => {
      insertEmptyCodeBlock(editor, {
        defaultType: ParagraphPlugin.key,
        insertNodesOptions: { select: true },
      });
    },
  },
  {
    match: "+ ",
    mode: "block",
    preFormat: openNextToggles,
    type: TogglePlugin.key,
  },
  {
    match: ["---", "-", "___ "],
    mode: "block",
    type: HorizontalRulePlugin.key,
    format: (editor) => {
      editor.tf.setNodes({ type: HorizontalRulePlugin.key });
      editor.tf.insertNodes({
        children: [{ text: "" }],
        type: ParagraphPlugin.key,
      });
    },
  },
];

const autoformatIndentLists: AutoformatRule[] = [
  {
    match: ["* ", "- "],
    mode: "block",
    type: "list",
    format: (editor) => {
      toggleIndentList(editor, {
        listStyleType: ListStyleType.Disc,
      });
    },
  },
  {
    match: [String.raw`^\d+\.$ `, String.raw`^\d+\)$ `],
    matchByRegex: true,
    mode: "block",
    type: "list",
    format: (editor, { matchString }) => {
      toggleIndentList(editor, {
        listRestartPolite: Number(matchString) || 1,
        listStyleType: ListStyleType.Decimal,
      });
    },
  },
  {
    match: ["[] "],
    mode: "block",
    type: "list",
    format: (editor) => {
      toggleIndentList(editor, {
        listStyleType: INDENT_LIST_KEYS.todo,
      });
      editor.tf.setNodes({
        checked: false,
        listStyleType: INDENT_LIST_KEYS.todo,
      });
    },
  },
  {
    match: ["[x] "],
    mode: "block",
    type: "list",
    format: (editor) => {
      toggleIndentList(editor, {
        listStyleType: INDENT_LIST_KEYS.todo,
      });
      editor.tf.setNodes({
        checked: true,
        listStyleType: INDENT_LIST_KEYS.todo,
      });
    },
  },
];

export const autoformatPlugin = AutoformatPlugin.configure({
  options: {
    enableUndoOnDelete: true,
    rules: [
      ...autoformatBlocks,
      ...autoformatMarks,
      ...autoformatSmartQuotes,
      ...autoformatPunctuation,
      ...autoformatLegal,
      ...autoformatLegalHtml,
      ...autoformatArrow,
      ...autoformatMath,
      ...autoformatIndentLists,
    ].map(
      (rule): AutoformatRule => ({
        ...rule,
        query: (editor) =>
          !editor.api.some({
            match: { type: editor.getType(CodeBlockPlugin) },
          }),
      }),
    ),
  },
});

// ========== FILE END: plugins/autoformat-plugin.ts ==========



// ========== FILE START: plugins/basic-nodes-plugins.tsx ==========
"use client";

import { BasicMarksPlugin } from "@udecode/plate-basic-marks/react";
import { BlockquotePlugin } from "@udecode/plate-block-quote/react";
import { CodeBlockPlugin } from "@udecode/plate-code-block/react";
import { HeadingPlugin } from "@udecode/plate-heading/react";
import { all, createLowlight } from "lowlight";

const lowlight = createLowlight(all);

export const basicNodesPlugins = [
  HeadingPlugin.configure({ options: { levels: 3 } }),
  BlockquotePlugin,
  CodeBlockPlugin.configure({ options: { lowlight } }),
  BasicMarksPlugin,
] as const;

// ========== FILE END: plugins/basic-nodes-plugins.tsx ==========



// ========== FILE START: plugins/block-menu-plugins.ts ==========
"use client";

import { BlockMenuPlugin } from "@udecode/plate-selection/react";

import { BlockContextMenu } from "../ui/menus/block-context-menu";

import { blockSelectionPlugins } from "./block-selection-plugins";

export const blockMenuPlugins = [
  ...blockSelectionPlugins,
  BlockMenuPlugin.configure({
    render: { aboveEditable: BlockContextMenu },
  }),
] as const;

// ========== FILE END: plugins/block-menu-plugins.ts ==========



// ========== FILE START: plugins/block-selection-plugins.tsx ==========
"use client";

import { BlockSelectionPlugin } from "@udecode/plate-selection/react";

import { BlockSelection } from "../ui/primitives/block-selection";

export const blockSelectionPlugins = [
  BlockSelectionPlugin.configure(({ editor }) => ({
    options: {
      enableContextMenu: true,
      isSelectable: (element, path) => {
        return (
          !["code_line", "column", "td"].includes(element.type) &&
          !editor.api.block({ above: true, at: path, match: { type: "tr" } })
        );
      },
    },
    render: {
      belowRootNodes: (props) => {
        if (!props.attributes.className?.includes("slate-selectable"))
          return null;

        return <BlockSelection />;
      },
    },
  })),
] as const;

export const blockSelectionReadOnlyPlugin = BlockSelectionPlugin.configure({
  api: {},
  extendEditor: null,
  handlers: {},
  options: {},
  render: {},
  useHooks: null,
});

// ========== FILE END: plugins/block-selection-plugins.tsx ==========



// ========== FILE START: plugins/comments/ExtendedCommentsPlugin.tsx ==========
"use client";

import { useEffect } from "react";

import type { Path } from "@udecode/plate";

import { isSlateString } from "@udecode/plate";
import { getDraftCommentKey } from "@udecode/plate-comments";
import { CommentsPlugin } from "@udecode/plate-comments/react";
import { useEditorContainerRef, useHotkeys } from "@udecode/plate/react";

export const ExtendedCommentsPlugin = CommentsPlugin.extend({
  options: {
    activeId: null as string | null,
    commentingBlock: null as Path | null,
    hotkey: ["meta+shift+m", "ctrl+shift+m"],
    hoverId: null as string | null,
    isOverlapWithEditor: false as boolean,
    uniquePathMap: new Map(),
    updateTimestamp: null as number | null,
  },
})
  .extend({
    handlers: {
      onClick: ({ api, event, setOption, type }) => {
        let leaf = event.target as HTMLElement;
        let isSet = false;

        const unsetActiveSuggestion = () => {
          setOption("activeId", null);
          isSet = true;
        };

        if (!isSlateString(leaf)) unsetActiveSuggestion();

        while (leaf.parentElement) {
          if (leaf.classList.contains(`slate-${type}`)) {
            const commentsEntry = api.comment.node();

            if (!commentsEntry) {
              unsetActiveSuggestion();

              break;
            }

            const id = api.comment.nodeId(commentsEntry[0]) ?? null;
            const isDraft = commentsEntry[0][getDraftCommentKey()];

            setOption("activeId", isDraft ? getDraftCommentKey() : id);
            isSet = true;

            break;
          }

          leaf = leaf.parentElement;
        }

        if (!isSet) unsetActiveSuggestion();
      },
    },
    useHooks: ({ editor, getOptions }) => {
      const { hotkey } = getOptions();

      const editorContainerRef = useEditorContainerRef();

      useEffect(() => {
        if (!editorContainerRef.current) return;

        const editable = editor.api.toDOMNode(editor);

        if (!editable) return;

        const observer = new ResizeObserver((entries) => {
          const width = entries[0].contentRect.width;
          const isOverlap = width < 700;

          editor.setOption(
            ExtendedCommentsPlugin,
            "isOverlapWithEditor",
            isOverlap,
          );
        });

        observer.observe(editable);

        return () => {
          observer.disconnect();
        };
      }, [editor, editorContainerRef]);

      useHotkeys(
        hotkey!,
        (e) => {
          if (!editor.selection) return;

          e.preventDefault();

          if (!editor.api.isExpanded()) return;
        },
        {
          enableOnContentEditable: true,
        },
      );
    },
  })
  .overrideEditor(
    ({ editor, setOption, tf: { apply, insertBreak }, tf, type }) => ({
      transforms: {
        apply(operation) {
          if (
            operation.type !== "set_selection" &&
            operation.type !== "set_node" &&
            operation.type !== "split_node" &&
            operation.type !== "merge_node"
          ) {
            const { newProperties, properties } = operation;

            if (
              (properties as Record<string, any>)?.[getDraftCommentKey()] ||
              (newProperties as Record<string, any>)?.[getDraftCommentKey()]
            )
              return;

            setOption("updateTimestamp", Date.now());
          }

          apply(operation);
        },

        insertBreak() {
          setOption("updateTimestamp", Date.now());

          // TODO: move to SkipMarkPlugin
          tf.comment.removeMark();
          insertBreak();
          editor.tf.unsetNodes([type], {
            at: editor.selection?.focus,
            mode: "lowest",
          });
        },
      },
    }),
  );

// ========== FILE END: plugins/comments/ExtendedCommentsPlugin.tsx ==========



// ========== FILE START: plugins/comments/comments-plugin.tsx ==========
"use client";

import { AfterEditableComments } from "../../ui/menus/comments/floating-discussion";

import { ExtendedCommentsPlugin } from "./ExtendedCommentsPlugin";

export const commentsPlugin = ExtendedCommentsPlugin.extend({
  render: {
    afterEditable: AfterEditableComments as any,
  },
});

// ========== FILE END: plugins/comments/comments-plugin.tsx ==========



// ========== FILE START: plugins/copilot-plugins.tsx ==========
"use client";

import type { TElement } from "@udecode/plate";

import { CopilotPlugin } from "@udecode/plate-ai/react";
// import { faker } from '@faker-js/faker';
import { serializeMd, stripMarkdown } from "@udecode/plate-markdown";

import { GhostText } from "../ui/primitives/ghost-text";
import { markdownPlugin } from "./markdown-plugin";

export const copilotPlugins = [
  markdownPlugin,
  CopilotPlugin.configure(({ api }) => ({
    options: {
      completeOptions: {
        api: "/api/ai/copilot",
        body: {
          system: `You are an advanced AI writing assistant, similar to VSCode Copilot but for general text. Your task is to predict and generate the next part of the text based on the given context.
  
  Rules:
  - Continue the text naturally up to the next punctuation mark (., ,, ;, :, ?, or !).
  - Maintain style and tone. Don't repeat given text.
  - For unclear context, provide the most likely continuation.
  - Handle code snippets, lists, or structured text if needed.
  - Don't include """ in your response.
  - CRITICAL: Always end with a punctuation mark.
  - CRITICAL: Avoid starting a new block. Do not use block formatting like >, #, 1., 2., -, etc. The suggestion should continue in the same block as the context.
  - If no context is provided or you can't generate a continuation, return "0" without explanation.`,
        },
        onError: () => {
          // Mock the API response. Remove it when you implement the route /api/ai/copilot
          // api.copilot.setBlockSuggestion({
          //   text: stripMarkdown(faker.lorem.sentence()),
          // });
          console.error("Copilot API call failed or is not implemented.");
        },
        onFinish: (_, completion) => {
          if (completion === "0") return;

          api.copilot.setBlockSuggestion({
            text: stripMarkdown(completion),
          });
        },
      },
      debounceDelay: 500,
      renderGhostText: GhostText,
      getPrompt: ({ editor }) => {
        const contextEntry = editor.api.block({ highest: true });

        if (!contextEntry) return "";

        const prompt = serializeMd(editor, {
          value: [contextEntry[0] as TElement],
        });

        return `Continue the text up to the next punctuation mark:
  """
  ${prompt}
  """`;
      },
    },
  })),
] as const;

// ========== FILE END: plugins/copilot-plugins.tsx ==========



// ========== FILE START: plugins/cursor-overlay-plugin.tsx ==========
"use client";

import { CursorOverlayPlugin } from "@udecode/plate-selection/react";

import { CursorOverlay } from "../ui/primitives/cursor-overlay";

export const cursorOverlayPlugin = CursorOverlayPlugin.configure({
  render: {
    afterEditable: () => <CursorOverlay />,
  },
});

// ========== FILE END: plugins/cursor-overlay-plugin.tsx ==========



// ========== FILE START: plugins/delete-plugins.ts ==========
"use client";

import { HorizontalRulePlugin } from "@udecode/plate-horizontal-rule/react";
import {
  AudioPlugin,
  FilePlugin,
  ImagePlugin,
  MediaEmbedPlugin,
  VideoPlugin,
} from "@udecode/plate-media/react";
import { DeletePlugin, SelectOnBackspacePlugin } from "@udecode/plate-select";

export const deletePlugins = [
  SelectOnBackspacePlugin.configure({
    options: {
      query: {
        allow: [
          ImagePlugin.key,
          VideoPlugin.key,
          AudioPlugin.key,
          FilePlugin.key,
          MediaEmbedPlugin.key,
          HorizontalRulePlugin.key,
        ],
      },
    },
  }),
  DeletePlugin,
] as const;

// ========== FILE END: plugins/delete-plugins.ts ==========



// ========== FILE START: plugins/discussion-plugin.tsx ==========
"use client";

import type { TComment } from "../ui/elements/comments-suggestions/comment";

import { createPlatePlugin } from "@udecode/plate/react";

import { BlockDiscussion } from "../ui/elements/comments-suggestions/block-discussion";

export interface TDiscussion {
  id: string;
  comments: TComment[];
  createdAt: Date;
  isResolved: boolean;
  userId: string;
  documentContent?: string;
}

const discussionsData: TDiscussion[] = [
  {
    id: "discussion1",
    comments: [
      {
        id: "comment1",
        contentRich: [
          {
            children: [
              {
                text: "This is a comment",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 900_000),
        discussionId: "discussion1",
        isEdited: false,
        userId: "alice",
      },
    ],
    createdAt: new Date(),
    documentContent: "comments",
    isResolved: false,
    userId: "alice",
  },
  {
    id: "discussion2",
    comments: [
      {
        id: "comment1",
        contentRich: [
          {
            children: [
              {
                text: "There will be animation here",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 900_000),
        discussionId: "discussion1",
        isEdited: false,
        userId: "bob",
      },
    ],
    createdAt: new Date(),
    documentContent: "here",
    isResolved: false,
    userId: "bob",
  },
  {
    id: "discussion3",
    comments: [
      {
        id: "comment1",
        contentRich: [
          {
            children: [
              {
                text: "Try hovering here",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 900_000),
        discussionId: "discussion3",
        isEdited: false,
        userId: "charlie",
      },
    ],
    createdAt: new Date(),
    documentContent: "activate",
    isResolved: false,
    userId: "charlie",
  },
  {
    id: "discussion4",
    comments: [
      {
        id: "comment1",
        contentRich: [
          {
            children: [
              {
                text: "Click here to highlight this block",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 900_000),
        discussionId: "discussion4",
        isEdited: false,
        userId: "alice",
      },
    ],
    createdAt: new Date(),
    documentContent: "block",
    isResolved: false,
    userId: "bob",
  },
];

const avatarUrl = (seed: string) =>
  `https://api.dicebear.com/9.x/glass/svg?seed=${seed}`;

const usersData: Record<
  string,
  { id: string; avatarUrl: string; name: string; hue?: number }
> = {
  alice: {
    id: "alice",
    avatarUrl: avatarUrl("alice6"),
    name: "Alice",
  },
  bob: {
    id: "bob",
    avatarUrl: avatarUrl("bob4"),
    name: "Bob",
  },
  charlie: {
    id: "charlie",
    avatarUrl: avatarUrl("charlie2"),
    name: "Charlie",
  },
};

// This plugin is purely UI. It's only used to store the discussions and users data
export const discussionPlugin = createPlatePlugin({
  key: "discussion",
  options: {
    currentUserId: "alice",
    discussions: discussionsData,
    users: usersData,
  },
})
  .configure({
    render: { aboveNodes: BlockDiscussion },
  })
  .extendSelectors(({ getOption }) => ({
    currentUser: () => getOption("users")[getOption("currentUserId")],
    user: (id: string) => getOption("users")[id],
  }));

// ========== FILE END: plugins/discussion-plugin.tsx ==========



// ========== FILE START: plugins/dnd-plugins.tsx ==========
"use client";

import { DndPlugin } from "@udecode/plate-dnd";
import { PlaceholderPlugin } from "@udecode/plate-media/react";
import { NodeIdPlugin } from "@udecode/plate-node-id";

import { DraggableAboveNodes } from "../ui/primitives/draggable";

export const dndPlugins = [
  NodeIdPlugin,
  DndPlugin.configure({
    options: {
      enableScroller: true,
      onDropFiles: ({ dragItem, editor, target }) => {
        editor
          .getTransforms(PlaceholderPlugin)
          .insert.media(dragItem.files, { at: target, nextBlock: false });
      },
    },
    render: {
      aboveNodes: DraggableAboveNodes,
    },
  }),
] as const;

// ========== FILE END: plugins/dnd-plugins.tsx ==========



// ========== FILE START: plugins/editor-plugins.tsx ==========
"use client";

import emojiMartData, { type EmojiMartData } from "@emoji-mart/data";
import { CalloutPlugin } from "@udecode/plate-callout/react";
import { CodeBlockPlugin } from "@udecode/plate-code-block/react";
import { DatePlugin } from "@udecode/plate-date/react";
import { DocxPlugin } from "@udecode/plate-docx";
import { EmojiPlugin } from "@udecode/plate-emoji/react";
import {
  FontBackgroundColorPlugin,
  FontColorPlugin,
  FontSizePlugin,
} from "@udecode/plate-font/react";
import { HighlightPlugin } from "@udecode/plate-highlight/react";
import { HorizontalRulePlugin } from "@udecode/plate-horizontal-rule/react";
import { JuicePlugin } from "@udecode/plate-juice";
import { KbdPlugin } from "@udecode/plate-kbd/react";
import { ColumnPlugin } from "@udecode/plate-layout/react";
import { SlashPlugin } from "@udecode/plate-slash-command/react";
import { TogglePlugin } from "@udecode/plate-toggle/react";
import { TrailingBlockPlugin } from "@udecode/plate-trailing-block";

import { FixedToolbarPlugin } from "./fixed-toolbar-plugin";
import { FloatingToolbarPlugin } from "./floating-toolbar-plugin";
import { SuggestionBelowNodes } from "../ui/elements/comments-suggestions/suggestion-line-break";

import { aiPlugins } from "./ai-plugins";
import { alignPlugin } from "./align-plugin";
import { autoformatPlugin } from "./autoformat-plugin";
import { basicNodesPlugins } from "./basic-nodes-plugins";
import { blockMenuPlugins } from "./block-menu-plugins";
import { commentsPlugin } from "./comments/comments-plugin";
import { cursorOverlayPlugin } from "./cursor-overlay-plugin";
import { deletePlugins } from "./delete-plugins";
import { discussionPlugin } from "./discussion-plugin";
import { dndPlugins } from "./dnd-plugins";
import { equationPlugins } from "./equation-plugins";
import { exitBreakPlugin } from "./exit-break-plugin";
import { indentListPlugins } from "./indent-list-plugins";
import { lineHeightPlugin } from "./line-height-plugin";
import { linkPlugin } from "./link-plugin";
import { markdownPlugin } from "./markdown-plugin";
import { mediaPlugins } from "./media-plugins";
import { mentionPlugin } from "./mention-plugin";
import { resetBlockTypePlugin } from "./reset-block-type-plugin";
import { skipMarkPlugin } from "./skip-mark-plugin";
import { softBreakPlugin } from "./soft-break-plugin";
import { suggestionPlugin } from "./suggestion-plugin";
import { tablePlugin } from "./table-plugin";
import { tocPlugin } from "./toc-plugin";

export const viewPlugins = [
  ...basicNodesPlugins,
  HorizontalRulePlugin,
  linkPlugin,
  DatePlugin,
  mentionPlugin,
  tablePlugin,
  TogglePlugin,
  tocPlugin,
  ...mediaPlugins,
  ...equationPlugins,
  CalloutPlugin,
  ColumnPlugin,

  // Marks
  FontColorPlugin,
  FontBackgroundColorPlugin,
  FontSizePlugin,
  HighlightPlugin,
  KbdPlugin,
  skipMarkPlugin,

  // Block Style
  alignPlugin,
  ...indentListPlugins,
  lineHeightPlugin,

  // Collaboration
  commentsPlugin,
  discussionPlugin,
  suggestionPlugin.configure({
    render: { belowNodes: SuggestionBelowNodes as any },
  }),
] as const;

export const editorPlugins = [
  // AI
  ...aiPlugins,

  // Nodes
  ...viewPlugins,

  // Functionality
  SlashPlugin.extend({
    options: {
      // Disable slash commands within code blocks to prevent conflicts with code input.
      triggerQuery(editor) {
        return !editor.api.some({
          match: { type: editor.getType(CodeBlockPlugin) },
        });
      },
    },
  }),
  autoformatPlugin,
  cursorOverlayPlugin,
  ...blockMenuPlugins,
  ...dndPlugins,
  EmojiPlugin.configure({ options: { data: emojiMartData as EmojiMartData } }),
  exitBreakPlugin,
  resetBlockTypePlugin,
  ...deletePlugins,
  softBreakPlugin,
  TrailingBlockPlugin,

  // Deserialization
  DocxPlugin,
  markdownPlugin,
  JuicePlugin,

  // UI
  FixedToolbarPlugin,
  FloatingToolbarPlugin,
];

// ========== FILE END: plugins/editor-plugins.tsx ==========



// ========== FILE START: plugins/equation-plugins.ts ==========
"use client";

import {
  EquationPlugin,
  InlineEquationPlugin,
} from "@udecode/plate-math/react";

export const equationPlugins = [InlineEquationPlugin, EquationPlugin];

// ========== FILE END: plugins/equation-plugins.ts ==========



// ========== FILE START: plugins/exit-break-plugin.ts ==========
"use client";

import { ExitBreakPlugin } from "@udecode/plate-break/react";
import { HEADING_LEVELS } from "@udecode/plate-heading";

export const exitBreakPlugin = ExitBreakPlugin.configure({
  options: {
    rules: [
      {
        hotkey: "mod+enter",
      },
      {
        before: true,
        hotkey: "mod+shift+enter",
      },
      {
        hotkey: "enter",
        level: 1,
        query: {
          allow: HEADING_LEVELS,
          end: true,
          start: true,
        },
        relative: true,
      },
    ],
  },
});

// ========== FILE END: plugins/exit-break-plugin.ts ==========



// ========== FILE START: plugins/fixed-toolbar-plugin.tsx ==========
"use client";

import { createPlatePlugin } from "@udecode/plate/react";

import { FixedToolbar } from "../ui/menus/toolbars/fixed/fixed-toolbar";
import { FixedToolbarButtons } from "../ui/menus/buttons/fixed-toolbar-buttons";

export const FixedToolbarPlugin = createPlatePlugin({
  key: "fixed-toolbar",
  render: {
    beforeEditable: () => (
      <FixedToolbar>
        <FixedToolbarButtons />
      </FixedToolbar>
    ),
  },
});

// ========== FILE END: plugins/fixed-toolbar-plugin.tsx ==========



// ========== FILE START: plugins/floating-toolbar-plugin.tsx ==========
"use client";

import { createPlatePlugin } from "@udecode/plate/react";

import { FloatingToolbar } from "../ui/menus/toolbars/floating/floating-toolbar";
import { FloatingToolbarButtons } from "../ui/menus/buttons/floating-toolbar-buttons";

export const FloatingToolbarPlugin = createPlatePlugin({
  key: "floating-toolbar",
  render: {
    afterEditable: () => (
      <FloatingToolbar>
        <FloatingToolbarButtons />
      </FloatingToolbar>
    ),
  },
});

// ========== FILE END: plugins/floating-toolbar-plugin.tsx ==========



// ========== FILE START: plugins/indent-list-plugins.ts ==========
"use client";

import { BlockquotePlugin } from "@udecode/plate-block-quote/react";
import { CodeBlockPlugin } from "@udecode/plate-code-block/react";
import { HEADING_LEVELS } from "@udecode/plate-heading";
import { IndentListPlugin } from "@udecode/plate-indent-list/react";
import { IndentPlugin } from "@udecode/plate-indent/react";
import { TogglePlugin } from "@udecode/plate-toggle/react";
import { ParagraphPlugin } from "@udecode/plate/react";

import {
  FireLiComponent,
  FireMarker,
} from "../ui/elements/indentation/indent-fire-marker";
import {
  TodoLi,
  TodoMarker,
} from "../ui/elements/indentation/indent-todo-marker";

export const indentListPlugins = [
  IndentPlugin.extend({
    inject: {
      targetPlugins: [
        ParagraphPlugin.key,
        ...HEADING_LEVELS,
        BlockquotePlugin.key,
        CodeBlockPlugin.key,
        TogglePlugin.key,
      ],
    },
  }),
  IndentListPlugin.extend({
    inject: {
      targetPlugins: [
        ParagraphPlugin.key,
        ...HEADING_LEVELS,
        BlockquotePlugin.key,
        CodeBlockPlugin.key,
        TogglePlugin.key,
      ],
    },
    options: {
      listStyleTypes: {
        fire: {
          liComponent: FireLiComponent,
          markerComponent: FireMarker,
          type: "fire",
        },
        todo: {
          liComponent: TodoLi,
          markerComponent: TodoMarker,
          type: "todo",
        },
      },
    },
  }),
];

// ========== FILE END: plugins/indent-list-plugins.ts ==========



// ========== FILE START: plugins/line-height-plugin.ts ==========
"use client";

import { HEADING_LEVELS } from "@udecode/plate-heading";
import { LineHeightPlugin } from "@udecode/plate-line-height/react";
import { ParagraphPlugin } from "@udecode/plate/react";

export const lineHeightPlugin = LineHeightPlugin.configure({
  inject: {
    nodeProps: {
      defaultNodeValue: 1.5,
      validNodeValues: [1, 1.2, 1.5, 2, 3],
    },
    targetPlugins: [ParagraphPlugin.key, ...HEADING_LEVELS],
  },
});

// ========== FILE END: plugins/line-height-plugin.ts ==========



// ========== FILE START: plugins/link-plugin.tsx ==========
"use client";

import { LinkPlugin } from "@udecode/plate-link/react";

import { LinkFloatingToolbar } from "../ui/menus/link-floating-toolbar";

export const linkPlugin = LinkPlugin.extend({
  render: { afterEditable: () => <LinkFloatingToolbar /> },
});

// ========== FILE END: plugins/link-plugin.tsx ==========



// ========== FILE START: plugins/markdown-plugin.tsx ==========
"use client";

import {
  MarkdownPlugin,
  remarkMdx,
  remarkMention,
} from "@udecode/plate-markdown";
import { SuggestionPlugin } from "@udecode/plate-suggestion/react";
import remarkGfm from "remark-gfm";
import remarkMath from "remark-math";

export const markdownPlugin = MarkdownPlugin.configure({
  options: {
    disallowedNodes: [SuggestionPlugin.key],
    remarkPlugins: [remarkMath, remarkGfm, remarkMdx, remarkMention],
  },
});

// ========== FILE END: plugins/markdown-plugin.tsx ==========



// ========== FILE START: plugins/media-plugins.tsx ==========
"use client";

import { CaptionPlugin } from "@udecode/plate-caption/react";
import {
  AudioPlugin,
  FilePlugin,
  ImagePlugin,
  MediaEmbedPlugin,
  PlaceholderPlugin,
  VideoPlugin,
} from "@udecode/plate-media/react";

import { ImagePreview } from "../ui/elements/media/image-preview";
import { MediaUploadToast } from "../ui/elements/media/media-upload-toast";

export const mediaPlugins = [
  ImagePlugin.extend({
    options: { disableUploadInsert: true },
    render: { afterEditable: ImagePreview },
  }),
  MediaEmbedPlugin,
  VideoPlugin,
  AudioPlugin,
  FilePlugin,
  CaptionPlugin.configure({
    options: {
      plugins: [
        ImagePlugin,
        VideoPlugin,
        AudioPlugin,
        FilePlugin,
        MediaEmbedPlugin,
      ],
    },
  }),
  PlaceholderPlugin.configure({
    options: { disableEmptyPlaceholder: true },
    render: { afterEditable: MediaUploadToast },
  }),
] as const;

// ========== FILE END: plugins/media-plugins.tsx ==========



// ========== FILE START: plugins/mention-plugin.ts ==========
"use client";

import { MentionPlugin } from "@udecode/plate-mention/react";

export const mentionPlugin = MentionPlugin.configure({
  options: { triggerPreviousCharPattern: /^$|^[\s"']$/ },
});

// ========== FILE END: plugins/mention-plugin.ts ==========



// ========== FILE START: plugins/reset-block-type-plugin.ts ==========
"use client";

import { BlockquotePlugin } from "@udecode/plate-block-quote/react";
import { CalloutPlugin } from "@udecode/plate-callout/react";
import {
  isCodeBlockEmpty,
  isSelectionAtCodeBlockStart,
  unwrapCodeBlock,
} from "@udecode/plate-code-block";
import { CodeBlockPlugin } from "@udecode/plate-code-block/react";
import { HEADING_LEVELS } from "@udecode/plate-heading";
import { INDENT_LIST_KEYS, ListStyleType } from "@udecode/plate-indent-list";
import { ResetNodePlugin } from "@udecode/plate-reset-node/react";
import { ParagraphPlugin } from "@udecode/plate/react";

const resetBlockTypesCommonRule = {
  defaultType: ParagraphPlugin.key,
  types: [
    ...HEADING_LEVELS,
    BlockquotePlugin.key,
    INDENT_LIST_KEYS.todo,
    ListStyleType.Disc,
    ListStyleType.Decimal,
    CalloutPlugin.key,
  ],
};

const resetBlockTypesCodeBlockRule = {
  defaultType: ParagraphPlugin.key,
  types: [CodeBlockPlugin.key],
  onReset: unwrapCodeBlock,
};

export const resetBlockTypePlugin = ResetNodePlugin.configure({
  options: {
    rules: [
      {
        ...resetBlockTypesCommonRule,
        hotkey: "Enter",
        predicate: (editor) =>
          editor.api.isEmpty(editor.selection, { block: true }),
      },
      {
        ...resetBlockTypesCommonRule,
        hotkey: "Backspace",
        predicate: (editor) => editor.api.isAt({ start: true }),
      },
      {
        ...resetBlockTypesCodeBlockRule,
        hotkey: "Enter",
        predicate: isCodeBlockEmpty,
      },
      {
        ...resetBlockTypesCodeBlockRule,
        hotkey: "Backspace",
        predicate: isSelectionAtCodeBlockStart,
      },
    ],
  },
});

// ========== FILE END: plugins/reset-block-type-plugin.ts ==========



// ========== FILE START: plugins/skip-mark-plugin.ts ==========
"use client";

import { CodePlugin, SkipMarkPlugin } from "@udecode/plate-basic-marks/react";
import { CommentsPlugin } from "@udecode/plate-comments/react";
import { SuggestionPlugin } from "@udecode/plate-suggestion/react";

export const skipMarkPlugin = SkipMarkPlugin.configure({
  options: {
    query: {
      allow: [SuggestionPlugin.key, CodePlugin.key, CommentsPlugin.key],
    },
  },
});

// ========== FILE END: plugins/skip-mark-plugin.ts ==========



// ========== FILE START: plugins/soft-break-plugin.ts ==========
"use client";

import { BlockquotePlugin } from "@udecode/plate-block-quote/react";
import { SoftBreakPlugin } from "@udecode/plate-break/react";
import { CalloutPlugin } from "@udecode/plate-callout/react";
import { CodeBlockPlugin } from "@udecode/plate-code-block/react";
import {
  TableCellHeaderPlugin,
  TableCellPlugin,
} from "@udecode/plate-table/react";

export const softBreakPlugin = SoftBreakPlugin.configure({
  options: {
    rules: [
      { hotkey: "shift+enter" },
      {
        hotkey: "enter",
        query: {
          allow: [
            CodeBlockPlugin.key,
            BlockquotePlugin.key,
            TableCellPlugin.key,
            TableCellHeaderPlugin.key,
            CalloutPlugin.key,
          ],
        },
      },
    ],
  },
});

// ========== FILE END: plugins/soft-break-plugin.ts ==========



// ========== FILE START: plugins/suggestion-plugin.tsx ==========
"use client";

import {
  type ExtendConfig,
  type Path,
  isSlateEditor,
  isSlateElement,
  isSlateString,
} from "@udecode/plate";
import {
  type BaseSuggestionConfig,
  BaseSuggestionPlugin,
} from "@udecode/plate-suggestion";
import { toTPlatePlugin } from "@udecode/plate/react";

import { discussionPlugin } from "./discussion-plugin";
import { BlockSuggestion } from "../ui/elements/comments-suggestions/block-suggestion";

export type SuggestionConfig = ExtendConfig<
  BaseSuggestionConfig,
  {
    activeId: string | null;
    hoverId: string | null;
    uniquePathMap: Map<string, Path>;
  }
>;

export const suggestionPlugin = toTPlatePlugin<SuggestionConfig>(
  BaseSuggestionPlugin,
  ({ editor }) => ({
    handlers: {
      // unset active suggestion when clicking outside of suggestion
      onClick: ({ api, event, setOption, type }) => {
        let leaf = event.target as HTMLElement;
        let isSet = false;

        const unsetActiveSuggestion = () => {
          setOption("activeId", null);
          isSet = true;
        };

        if (!isSlateString(leaf)) unsetActiveSuggestion();

        while (
          leaf.parentElement &&
          !isSlateElement(leaf.parentElement) &&
          !isSlateEditor(leaf.parentElement)
        ) {
          if (leaf.classList.contains(`slate-${type}`)) {
            const suggestionEntry = api.suggestion!.node({ isText: true });

            if (!suggestionEntry) {
              unsetActiveSuggestion();

              break;
            }

            const id = api.suggestion!.nodeId(suggestionEntry[0]);

            setOption("activeId", id ?? null);
            isSet = true;

            break;
          }

          leaf = leaf.parentElement;
        }

        if (!isSet) unsetActiveSuggestion();
      },
    },
    options: {
      activeId: null,
      currentUserId: editor.getOption(discussionPlugin, "currentUserId"),
      hoverId: null,
      uniquePathMap: new Map(),
    },
    render: {
      belowRootNodes: ({ api, element }) => {
        if (!api.suggestion!.isBlockSuggestion(element)) {
          return null;
        }

        return <BlockSuggestion element={element} />;
      },
    },
  }),
);

// ========== FILE END: plugins/suggestion-plugin.tsx ==========



// ========== FILE START: plugins/table-plugin.ts ==========
"use client";

import { TablePlugin } from "@udecode/plate-table/react";

export const tablePlugin = TablePlugin.configure({
  options: {},
});

// ========== FILE END: plugins/table-plugin.ts ==========



// ========== FILE START: plugins/toc-plugin.ts ==========
"use client";

import { TocPlugin } from "@udecode/plate-heading/react";

export const tocPlugin = TocPlugin.configure({
  options: {
    // isScroll: true,
    topOffset: 80,
  },
});

// ========== FILE END: plugins/toc-plugin.ts ==========



// ========== FILE START: settings.tsx ==========
"use client";

import * as React from "react";

import { CopilotPlugin } from "@udecode/plate-ai/react";
import { useEditorPlugin } from "@udecode/plate/react";
import {
  Check,
  ChevronsUpDown,
  ExternalLinkIcon,
  Eye,
  EyeOff,
  Settings,
  Wand2Icon,
} from "lucide-react";

import { Button } from "@/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";

interface Model {
  label: string;
  value: string;
}

interface ApiKeys {
  uploadthing: string;
}

interface SettingsContextType {
  apiKeys: ApiKeys;
  aiModel: Model;
  setApiKey: (service: keyof ApiKeys, key: string) => void;
  setAiModel: (model: Model) => void;
}

export const models: Model[] = [
  { label: "gpt-4o-mini", value: "gpt-4o-mini" }, // Default
  { label: "gpt-4o", value: "gpt-4o" },
];

const SettingsContext = React.createContext<SettingsContextType | undefined>(
  undefined,
);

export function SettingsProvider({ children }: { children: React.ReactNode }) {
  const [apiKeys, setApiKeys] = React.useState<ApiKeys>({
    uploadthing: "",
  });
  const [aiModel, setAiModel] = React.useState<Model>(models[0]);

  const setApiKey = (service: keyof ApiKeys, key: string) => {
    setApiKeys((prev) => ({ ...prev, [service]: key }));
  };

  return (
    <SettingsContext.Provider
      value={{ apiKeys, aiModel, setApiKey, setAiModel }}
    >
      {children}
    </SettingsContext.Provider>
  );
}

export function useSettings() {
  const context = React.useContext(SettingsContext);

  return (
    context ?? {
      apiKeys: {
        uploadthing: "",
      },
      aiModel: models[0],
      setApiKey: () => {},
      setAiModel: () => {},
    }
  );
}

export function SettingsDialog() {
  const { apiKeys, aiModel, setApiKey, setAiModel } = useSettings();
  const [tempApiKeys, setTempApiKeys] = React.useState(apiKeys);
  const [showKey, setShowKey] = React.useState<Record<string, boolean>>({});
  const [open, setOpen] = React.useState(false);
  const [openModel, setOpenModel] = React.useState(false);

  const { getOptions, setOption } = useEditorPlugin(CopilotPlugin);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    Object.entries(tempApiKeys).forEach(([service, key]) => {
      setApiKey(service as keyof ApiKeys, key);
    });
    setOpen(false);

    // Update AI options if needed
    const completeOptions = getOptions().completeOptions ?? {};
    setOption("completeOptions", {
      ...completeOptions,
      body: {
        ...completeOptions.body,
        model: aiModel.value,
      },
    });
  };

  const toggleKeyVisibility = (key: string) => {
    setShowKey((prev) => ({ ...prev, [key]: !prev[key] }));
  };

  const renderApiKeyInput = (service: keyof ApiKeys, label: string) => (
    <div className="group relative">
      <div className="flex items-center justify-between">
        <label
          className="absolute top-1/2 block -translate-y-1/2 cursor-text px-1 text-sm text-muted-foreground/70 transition-all group-focus-within:pointer-events-none group-focus-within:top-0 group-focus-within:cursor-default group-focus-within:text-xs group-focus-within:font-medium group-focus-within:text-foreground has-[+input:not(:placeholder-shown)]:pointer-events-none has-[+input:not(:placeholder-shown)]:top-0 has-[+input:not(:placeholder-shown)]:cursor-default has-[+input:not(:placeholder-shown)]:text-xs has-[+input:not(:placeholder-shown)]:font-medium has-[+input:not(:placeholder-shown)]:text-foreground"
          htmlFor={label}
        >
          <span className="inline-flex bg-background px-2">{label}</span>
        </label>
        <Button
          asChild
          size="icon"
          variant="ghost"
          className="absolute top-0 right-[28px] h-full"
        >
          <a
            className="flex items-center"
            href={"https://uploadthing.com/dashboard"}
            rel="noopener noreferrer"
            target="_blank"
          >
            <ExternalLinkIcon className="size-4" />
            <span className="sr-only">Get {label}</span>
          </a>
        </Button>
      </div>

      <Input
        id={label}
        className="pr-10"
        value={tempApiKeys[service]}
        onChange={(e) =>
          setTempApiKeys((prev) => ({ ...prev, [service]: e.target.value }))
        }
        placeholder=""
        data-1p-ignore
        type={showKey[service] ? "text" : "password"}
      />
      <Button
        size="icon"
        variant="ghost"
        className="absolute top-0 right-0 h-full"
        onClick={() => toggleKeyVisibility(service)}
        type="button"
      >
        {showKey[service] ? (
          <EyeOff className="size-4" />
        ) : (
          <Eye className="size-4" />
        )}
        <span className="sr-only">
          {showKey[service] ? "Hide" : "Show"} {label}
        </span>
      </Button>
    </div>
  );

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button
          size="icon"
          variant="default"
          className={cn(
            "group fixed right-4 bottom-4 z-50 size-10 overflow-hidden",
            "rounded-full shadow-md hover:shadow-lg",
          )}
          data-block-hide
        >
          <Settings className="size-4" />
        </Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Settings</DialogTitle>
          <DialogDescription>
            {`These API keys are stored in local storage and are not secure.
            Do not use them in production. They are for development and
            demonstration purposes only.`}
          </DialogDescription>
        </DialogHeader>

        <form className="space-y-10" onSubmit={handleSubmit}>
          {/* AI Settings Group */}
          <div className="space-y-4">
            <div className="flex items-center gap-2">
              <div className="size-8 rounded-full bg-purple-100 p-2 dark:bg-purple-900">
                <Wand2Icon className="size-4 text-purple-600 dark:text-purple-400" />
              </div>
              <h4 className="font-semibold">AI</h4>
            </div>

            <div className="space-y-4">
              {renderApiKeyInput("uploadthing", "UploadThing API key")}

              <div className="group relative">
                <label
                  className="absolute start-1 top-0 z-10 block -translate-y-1/2 bg-background px-2 text-xs font-medium text-foreground group-has-disabled:opacity-50"
                  htmlFor="select-model"
                >
                  Model
                </label>
                <Popover open={openModel} onOpenChange={setOpenModel}>
                  <PopoverTrigger id="select-model" asChild>
                    <Button
                      size="lg"
                      variant="outline"
                      className="w-full justify-between"
                      aria-expanded={openModel}
                      role="combobox"
                    >
                      <code>{aiModel.label}</code>
                      <ChevronsUpDown className="ml-2 size-4 shrink-0 opacity-50" />
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-full p-0">
                    <Command>
                      <CommandInput placeholder="Search model..." />
                      <CommandEmpty>No model found.</CommandEmpty>
                      <CommandList>
                        <CommandGroup>
                          {models.map((m) => (
                            <CommandItem
                              key={m.value}
                              value={m.value}
                              onSelect={() => {
                                setAiModel(m);
                                setOpenModel(false);
                              }}
                            >
                              <Check
                                className={cn(
                                  "mr-2 size-4",
                                  aiModel.value === m.value
                                    ? "opacity-100"
                                    : "opacity-0",
                                )}
                              />
                              <code>{m.label}</code>
                            </CommandItem>
                          ))}
                        </CommandGroup>
                      </CommandList>
                    </Command>
                  </PopoverContent>
                </Popover>
              </div>
            </div>
          </div>

          {/* Upload Settings Group */}
          {/* <div className="space-y-4">
            <div className="flex items-center gap-2">
              <div className="size-8 rounded-full bg-red-100 p-2 dark:bg-red-900">
                <Upload className="size-4 text-red-600 dark:text-red-400" />
              </div>
              <h4 className="font-semibold">Upload</h4>
            </div>

            <div className="space-y-4">
              {renderApiKeyInput('uploadthing', 'Uploadthing API key')}
            </div>
          </div> */}

          <Button size="lg" className="w-full" type="submit">
            Save changes
          </Button>
        </form>

        <p className="text-sm text-muted-foreground">
          Not stored anywhere. Used only for current session requests.
        </p>
      </DialogContent>
    </Dialog>
  );
}

// ========== FILE END: settings.tsx ==========



// ========== FILE START: ui/elements/ai/ai-anchor-element.tsx ==========
"use client";

import { type PlateElementProps, PlateElement } from "@udecode/plate/react";

export function AIAnchorElement(props: PlateElementProps) {
  return (
    <PlateElement {...props}>
      <div className="h-[0.1px]" />
    </PlateElement>
  );
}

// ========== FILE END: ui/elements/ai/ai-anchor-element.tsx ==========



// ========== FILE START: ui/elements/ai/ai-chat-editor.tsx ==========
"use client";

import * as React from "react";

import { withProps } from "@udecode/cn";
import { BaseParagraphPlugin, SlateLeaf } from "@udecode/plate";
import { useAIChatEditor } from "@udecode/plate-ai/react";
import {
  BaseBoldPlugin,
  BaseCodePlugin,
  BaseItalicPlugin,
  BaseStrikethroughPlugin,
  BaseSubscriptPlugin,
  BaseSuperscriptPlugin,
  BaseUnderlinePlugin,
} from "@udecode/plate-basic-marks";
import { BaseBlockquotePlugin } from "@udecode/plate-block-quote";
import { BaseCalloutPlugin } from "@udecode/plate-callout";
import {
  BaseCodeBlockPlugin,
  BaseCodeLinePlugin,
  BaseCodeSyntaxPlugin,
} from "@udecode/plate-code-block";
import { BaseDatePlugin } from "@udecode/plate-date";
import {
  BaseFontBackgroundColorPlugin,
  BaseFontColorPlugin,
  BaseFontFamilyPlugin,
  BaseFontSizePlugin,
  BaseFontWeightPlugin,
} from "@udecode/plate-font";
import {
  BaseHeadingPlugin,
  BaseTocPlugin,
  HEADING_KEYS,
} from "@udecode/plate-heading";
import { BaseHighlightPlugin } from "@udecode/plate-highlight";
import { BaseHorizontalRulePlugin } from "@udecode/plate-horizontal-rule";
import { BaseIndentPlugin } from "@udecode/plate-indent";
import { BaseIndentListPlugin } from "@udecode/plate-indent-list";
import { BaseKbdPlugin } from "@udecode/plate-kbd";
import { BaseColumnItemPlugin, BaseColumnPlugin } from "@udecode/plate-layout";
import { BaseLinkPlugin } from "@udecode/plate-link";
import {
  BaseEquationPlugin,
  BaseInlineEquationPlugin,
} from "@udecode/plate-math";
import {
  BaseAudioPlugin,
  BaseFilePlugin,
  BaseImagePlugin,
  BaseVideoPlugin,
} from "@udecode/plate-media";
import { BaseMentionPlugin } from "@udecode/plate-mention";
import {
  BaseTableCellHeaderPlugin,
  BaseTableCellPlugin,
  BaseTablePlugin,
  BaseTableRowPlugin,
} from "@udecode/plate-table";
import { usePlateEditor } from "@udecode/plate/react";
import { all, createLowlight } from "lowlight";

import { markdownPlugin } from "../../../plugins/markdown-plugin";
import {
  TodoLiStatic,
  TodoMarkerStatic,
} from "../../elements/indentation/indent-todo-marker-static";

import { BlockquoteElementStatic } from "../blockquote/blockquote-element-static";
import { CalloutElementStatic } from "../callout/callout-element-static";
import { CodeBlockElementStatic } from "../code/code-block-element-static";
import { CodeLeafStatic } from "../code/code-leaf-static";
import { CodeLineElementStatic } from "../code/code-line-element-static";
import { CodeSyntaxLeafStatic } from "../code/code-syntax-leaf-static";
import { ColumnElementStatic } from "../layout/column-element-static";
import { ColumnGroupElementStatic } from "../layout/column-group-element-static";
import { DateElementStatic } from "../date/date-element-static";
import { EditorStatic } from "../../primitives/editor-static";
import { EquationElementStatic } from "../equation/equation-element-static";
import { HeadingElementStatic } from "../heading/heading-element-static";
import { HighlightLeafStatic } from "../..//elements/leafs/highlight-leaf-static";
import { HrElementStatic } from "../heading/hr-element-static";
import { ImageElementStatic } from "../image/image-element-static";
import { InlineEquationElementStatic } from "../equation/inline-equation-element-static";
import { KbdLeafStatic } from "../..//elements/leafs/kbd-leaf-static";
import { LinkElementStatic } from "../link/link-element-static";
import { MediaAudioElementStatic } from "../media/media-audio-element-static";
import { MediaFileElementStatic } from "../media/media-file-element-static";
import { MediaVideoElementStatic } from "../media/media-video-element-static";
import { MentionElementStatic } from "../mention/mention-element-static";
import { ParagraphElementStatic } from "../paragraph/paragraph-element-static";
import {
  TableCellElementStatic,
  TableCellHeaderStaticElement,
} from "../table/table-cell-element-static";
import { TableElementStatic } from "../table/table-element-static";
import { TableRowElementStatic } from "../table/table-row-element-static";
import { TocElementStatic } from "../toc/toc-element-static";

const components = {
  [BaseAudioPlugin.key]: MediaAudioElementStatic,
  [BaseBlockquotePlugin.key]: BlockquoteElementStatic,
  [BaseBoldPlugin.key]: withProps(SlateLeaf, { as: "strong" }),
  [BaseCalloutPlugin.key]: CalloutElementStatic,
  [BaseCodeBlockPlugin.key]: CodeBlockElementStatic,
  [BaseCodeLinePlugin.key]: CodeLineElementStatic,
  [BaseCodePlugin.key]: CodeLeafStatic,
  [BaseCodeSyntaxPlugin.key]: CodeSyntaxLeafStatic,
  [BaseColumnItemPlugin.key]: ColumnElementStatic,
  [BaseColumnPlugin.key]: ColumnGroupElementStatic,
  [BaseDatePlugin.key]: DateElementStatic,
  [BaseEquationPlugin.key]: EquationElementStatic,
  [BaseFilePlugin.key]: MediaFileElementStatic,
  [BaseHighlightPlugin.key]: HighlightLeafStatic,
  [BaseHorizontalRulePlugin.key]: HrElementStatic,
  [BaseImagePlugin.key]: ImageElementStatic,
  [BaseInlineEquationPlugin.key]: InlineEquationElementStatic,
  [BaseItalicPlugin.key]: withProps(SlateLeaf, { as: "em" }),
  [BaseKbdPlugin.key]: KbdLeafStatic,
  [BaseLinkPlugin.key]: LinkElementStatic,
  [BaseMentionPlugin.key]: MentionElementStatic,
  [BaseParagraphPlugin.key]: ParagraphElementStatic,
  [BaseStrikethroughPlugin.key]: withProps(SlateLeaf, { as: "s" }),
  [BaseSubscriptPlugin.key]: withProps(SlateLeaf, { as: "sub" }),
  [BaseSuperscriptPlugin.key]: withProps(SlateLeaf, { as: "sup" }),
  [BaseTableCellHeaderPlugin.key]: TableCellHeaderStaticElement,
  [BaseTableCellPlugin.key]: TableCellElementStatic,
  [BaseTablePlugin.key]: TableElementStatic,
  [BaseTableRowPlugin.key]: TableRowElementStatic,
  [BaseTocPlugin.key]: TocElementStatic,
  [BaseUnderlinePlugin.key]: withProps(SlateLeaf, { as: "u" }),

  [BaseVideoPlugin.key]: MediaVideoElementStatic,
  [HEADING_KEYS.h1]: withProps(HeadingElementStatic, { variant: "h1" }),

  [HEADING_KEYS.h2]: withProps(HeadingElementStatic, { variant: "h2" }),
  [HEADING_KEYS.h3]: withProps(HeadingElementStatic, { variant: "h3" }),

  // [BaseCommentsPlugin.key]: CommentLeafStatic
  // [BaseTogglePlugin.key]: ToggleElementStatic
};
const lowlight = createLowlight(all);

const plugins = [
  BaseColumnItemPlugin,
  BaseColumnPlugin,
  BaseBlockquotePlugin,
  BaseSubscriptPlugin,
  BaseSuperscriptPlugin,
  BaseImagePlugin,
  BaseKbdPlugin,
  BaseBoldPlugin,
  BaseCodeBlockPlugin.configure({ options: { lowlight } }),
  BaseDatePlugin,
  BaseEquationPlugin,
  BaseInlineEquationPlugin,
  BaseCodePlugin,
  BaseItalicPlugin,
  BaseStrikethroughPlugin,
  BaseUnderlinePlugin,
  BaseFontColorPlugin,
  BaseFontSizePlugin,
  BaseFontFamilyPlugin,
  BaseFontWeightPlugin,
  BaseFontBackgroundColorPlugin,
  BaseHeadingPlugin,
  BaseHorizontalRulePlugin,
  BaseTablePlugin,
  BaseTocPlugin,
  BaseHighlightPlugin,
  BaseLinkPlugin,
  BaseMentionPlugin,
  BaseParagraphPlugin,
  BaseCalloutPlugin,
  BaseIndentPlugin.extend({
    inject: {
      targetPlugins: [BaseParagraphPlugin.key],
    },
  }),
  BaseIndentListPlugin.extend({
    inject: {
      targetPlugins: [BaseParagraphPlugin.key],
    },
    options: {
      listStyleTypes: {
        todo: {
          liComponent: TodoLiStatic,
          markerComponent: TodoMarkerStatic,
          type: "todo",
        },
      },
    },
  }),
  markdownPlugin,
];

export const AIChatEditor = React.memo(function AIChatEditor({
  content,
}: {
  content: string;
}) {
  const aiEditor = usePlateEditor({
    plugins,
  });

  useAIChatEditor(aiEditor, content);

  return (
    <EditorStatic variant="aiChat" components={components} editor={aiEditor} />
  );
});

// ========== FILE END: ui/elements/ai/ai-chat-editor.tsx ==========



// ========== FILE START: ui/elements/ai/ai-leaf.tsx ==========
"use client";

import { AIChatPlugin } from "@udecode/plate-ai/react";
import { type PlateTextProps, PlateText } from "@udecode/plate/react";
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils";

const aiIndicatorVariants = cva(
  'after:ml-1.5 after:inline-block after:h-3 after:w-3 after:animate-pulse after:rounded-full after:bg-primary after:align-middle after:content-[""]',
);

export function AILeaf(props: PlateTextProps) {
  const streamingLeaf = props.editor
    .getApi(AIChatPlugin)
    .aiChat.node({ streaming: true });

  const isLast = streamingLeaf?.[0] === props.text;

  return (
    <PlateText
      className={cn(
        "border-b-2 border-b-purple-100 bg-purple-50 text-purple-800",
        "transition-all duration-200 ease-in-out",
        isLast && aiIndicatorVariants(),
      )}
      {...props}
    />
  );
}

// ========== FILE END: ui/elements/ai/ai-leaf.tsx ==========



// ========== FILE START: ui/elements/ai/ai-loading-bar.tsx ==========
"use client";

import { AIChatPlugin } from "@udecode/plate-ai/react";
import { useEditorPlugin, usePluginOption } from "@udecode/plate/react";
import { Pause } from "lucide-react";

import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

export const AILoadingBar = () => {
  const chat = usePluginOption(AIChatPlugin, "chat");
  const mode = usePluginOption(AIChatPlugin, "mode");

  const { status } = chat;

  const { api } = useEditorPlugin(AIChatPlugin);

  const isLoading = status === "streaming" || status === "submitted";

  const visible = isLoading && mode === "insert";

  if (!visible) return null;

  return (
    <div
      className={cn(
        "absolute bottom-4 left-1/2 z-10 flex -translate-x-1/2 items-center gap-3 rounded-md border border-border bg-muted px-3 py-1.5 text-sm text-muted-foreground shadow-md transition-all duration-300",
      )}
    >
      <span className="h-4 w-4 animate-spin rounded-full border-2 border-muted-foreground border-t-transparent" />
      <span>{status === "submitted" ? "Thinking..." : "Writing..."}</span>
      <Button
        size="sm"
        variant="ghost"
        className="flex items-center gap-1 text-xs"
        onClick={() => api.aiChat.stop()}
      >
        <Pause className="h-4 w-4" />
        Stop
        <kbd className="ml-1 rounded bg-border px-1 font-mono text-[10px] text-muted-foreground shadow-sm">
          Esc
        </kbd>
      </Button>
    </div>
  );
};

// ========== FILE END: ui/elements/ai/ai-loading-bar.tsx ==========



// ========== FILE START: ui/elements/blockquote/blockquote-element-static.tsx ==========
import * as React from "react";

import { type SlateElementProps, SlateElement } from "@udecode/plate";

export function BlockquoteElementStatic(props: SlateElementProps) {
  return (
    <SlateElement
      as="blockquote"
      className="my-1 border-l-2 pl-6 italic"
      {...props}
    />
  );
}

// ========== FILE END: ui/elements/blockquote/blockquote-element-static.tsx ==========



// ========== FILE START: ui/elements/blockquote/blockquote-element.tsx ==========
"use client";

import { type PlateElementProps, PlateElement } from "@udecode/plate/react";

export function BlockquoteElement(props: PlateElementProps) {
  return (
    <PlateElement
      as="blockquote"
      className="my-1 border-l-2 pl-6 italic"
      {...props}
    />
  );
}

// ========== FILE END: ui/elements/blockquote/blockquote-element.tsx ==========



// ========== FILE START: ui/elements/callout/callout-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps, TElement } from "@udecode/plate";

import { cn } from "@udecode/cn";
import { SlateElement } from "@udecode/plate";

export function CalloutElementStatic({
  children,
  className,
  ...props
}: SlateElementProps<TElement & { icon?: string; backgroundColor?: string }>) {
  return (
    <SlateElement
      className={cn("my-1 flex rounded-sm bg-muted p-4 pl-3", className)}
      style={{
        backgroundColor: props.element.backgroundColor as string,
      }}
      {...props}
    >
      <div className="flex w-full gap-2 rounded-md">
        <div
          className="size-6 text-[18px] select-none"
          style={{
            fontFamily:
              '"Apple Color Emoji", "Segoe UI Emoji", NotoColorEmoji, "Noto Color Emoji", "Segoe UI Symbol", "Android Emoji", EmojiSymbols',
          }}
        >
          <span data-plate-prevent-deserialization>
            {(props.element.icon as string) || ""}
          </span>
        </div>
        <div className="w-full">{children}</div>
      </div>
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/callout/callout-element-static.tsx ==========



// ========== FILE START: ui/elements/callout/callout-element.tsx ==========
"use client";

import * as React from "react";
import type { TElement } from "@udecode/plate";

import { cn } from "@udecode/cn";
import { useCalloutEmojiPicker } from "@udecode/plate-callout/react";
import { useEmojiDropdownMenuState } from "@udecode/plate-emoji/react";
import { PlateElement } from "@udecode/plate/react";

import { Button } from "@/components/ui/button";

import {
  emojiCategoryIcons,
  emojiSearchIcons,
} from "../../../constants/emoji-icons";
import { EmojiPicker } from "../../menus/emoji/emoji-picker";
import { EmojiToolbarDropdown } from "../../menus/emoji/emoji-toolbar-dropdown";

export function CalloutElement({
  attributes,
  children,
  className,
  ...props
}: React.ComponentProps<typeof PlateElement> & {
  element: TElement & { icon?: string; backgroundColor?: string };
}) {
  const { emojiPickerState, isOpen, setIsOpen } = useEmojiDropdownMenuState({
    closeOnSelect: true,
  });

  const { emojiToolbarDropdownProps, props: calloutProps } =
    useCalloutEmojiPicker({
      isOpen,
      setIsOpen,
    });

  return (
    <PlateElement
      className={cn("my-1 flex rounded-sm bg-muted p-4 pl-3", className)}
      style={{
        backgroundColor: props.element.backgroundColor as string,
      }}
      attributes={{
        ...attributes,
        "data-plate-open-context-menu": true,
      }}
      {...props}
    >
      <div className="flex w-full gap-2 rounded-md">
        <EmojiToolbarDropdown
          {...emojiToolbarDropdownProps}
          control={
            <Button
              variant="ghost"
              className="size-6 p-1 text-[18px] select-none hover:bg-muted-foreground/15"
              style={{
                fontFamily:
                  '"Apple Color Emoji", "Segoe UI Emoji", NotoColorEmoji, "Noto Color Emoji", "Segoe UI Symbol", "Android Emoji", EmojiSymbols',
              }}
              contentEditable={false}
            >
              {(props.element.icon as string) || ""}
            </Button>
          }
        >
          <EmojiPicker
            {...emojiPickerState}
            {...calloutProps}
            icons={{
              categories: emojiCategoryIcons,
              search: emojiSearchIcons,
            }}
          />
        </EmojiToolbarDropdown>
        <div className="w-full">{children}</div>
      </div>
    </PlateElement>
  );
}

// ========== FILE END: ui/elements/callout/callout-element.tsx ==========



// ========== FILE START: ui/elements/code/code-block-combobox.tsx ==========
"use client";

import * as React from "react";

import type { TCodeBlockElement } from "@udecode/plate-code-block";

import { useEditorRef, useElement, useReadOnly } from "@udecode/plate/react";
import { Check } from "lucide-react";

import { Button } from "@/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";

const languages: { label: string; value: string }[] = [
  { label: "Auto", value: "auto" },
  { label: "Plain Text", value: "plaintext" },
  { label: "ABAP", value: "abap" },
  { label: "Agda", value: "agda" },
  { label: "Arduino", value: "arduino" },
  { label: "ASCII Art", value: "ascii" },
  { label: "Assembly", value: "x86asm" },
  { label: "Bash", value: "bash" },
  { label: "BASIC", value: "basic" },
  { label: "BNF", value: "bnf" },
  { label: "C", value: "c" },
  { label: "C#", value: "csharp" },
  { label: "C++", value: "cpp" },
  { label: "Clojure", value: "clojure" },
  { label: "CoffeeScript", value: "coffeescript" },
  { label: "Coq", value: "coq" },
  { label: "CSS", value: "css" },
  { label: "Dart", value: "dart" },
  { label: "Dhall", value: "dhall" },
  { label: "Diff", value: "diff" },
  { label: "Docker", value: "dockerfile" },
  { label: "EBNF", value: "ebnf" },
  { label: "Elixir", value: "elixir" },
  { label: "Elm", value: "elm" },
  { label: "Erlang", value: "erlang" },
  { label: "F#", value: "fsharp" },
  { label: "Flow", value: "flow" },
  { label: "Fortran", value: "fortran" },
  { label: "Gherkin", value: "gherkin" },
  { label: "GLSL", value: "glsl" },
  { label: "Go", value: "go" },
  { label: "GraphQL", value: "graphql" },
  { label: "Groovy", value: "groovy" },
  { label: "Haskell", value: "haskell" },
  { label: "HCL", value: "hcl" },
  { label: "HTML", value: "html" },
  { label: "Idris", value: "idris" },
  { label: "Java", value: "java" },
  { label: "JavaScript", value: "javascript" },
  { label: "JSON", value: "json" },
  { label: "Julia", value: "julia" },
  { label: "Kotlin", value: "kotlin" },
  { label: "LaTeX", value: "latex" },
  { label: "Less", value: "less" },
  { label: "Lisp", value: "lisp" },
  { label: "LiveScript", value: "livescript" },
  { label: "LLVM IR", value: "llvm" },
  { label: "Lua", value: "lua" },
  { label: "Makefile", value: "makefile" },
  { label: "Markdown", value: "markdown" },
  { label: "Markup", value: "markup" },
  { label: "MATLAB", value: "matlab" },
  { label: "Mathematica", value: "mathematica" },
  { label: "Mermaid", value: "mermaid" },
  { label: "Nix", value: "nix" },
  { label: "Notion Formula", value: "notion" },
  { label: "Objective-C", value: "objectivec" },
  { label: "OCaml", value: "ocaml" },
  { label: "Pascal", value: "pascal" },
  { label: "Perl", value: "perl" },
  { label: "PHP", value: "php" },
  { label: "PowerShell", value: "powershell" },
  { label: "Prolog", value: "prolog" },
  { label: "Protocol Buffers", value: "protobuf" },
  { label: "PureScript", value: "purescript" },
  { label: "Python", value: "python" },
  { label: "R", value: "r" },
  { label: "Racket", value: "racket" },
  { label: "Reason", value: "reasonml" },
  { label: "Ruby", value: "ruby" },
  { label: "Rust", value: "rust" },
  { label: "Sass", value: "scss" },
  { label: "Scala", value: "scala" },
  { label: "Scheme", value: "scheme" },
  { label: "SCSS", value: "scss" },
  { label: "Shell", value: "shell" },
  { label: "Smalltalk", value: "smalltalk" },
  { label: "Solidity", value: "solidity" },
  { label: "SQL", value: "sql" },
  { label: "Swift", value: "swift" },
  { label: "TOML", value: "toml" },
  { label: "TypeScript", value: "typescript" },
  { label: "VB.Net", value: "vbnet" },
  { label: "Verilog", value: "verilog" },
  { label: "VHDL", value: "vhdl" },
  { label: "Visual Basic", value: "vbnet" },
  { label: "WebAssembly", value: "wasm" },
  { label: "XML", value: "xml" },
  { label: "YAML", value: "yaml" },
];

export function CodeBlockCombobox() {
  const [open, setOpen] = React.useState(false);
  const readOnly = useReadOnly();
  const editor = useEditorRef();
  const element = useElement<TCodeBlockElement>();
  const value = element.lang || "plaintext";
  const [searchValue, setSearchValue] = React.useState("");

  const items = React.useMemo(
    () =>
      languages.filter(
        (language) =>
          !searchValue ||
          language.label.toLowerCase().includes(searchValue.toLowerCase()),
      ),
    [searchValue],
  );

  if (readOnly) return null;

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          size="sm"
          variant="ghost"
          className="h-6 justify-between gap-1 px-2 text-xs text-muted-foreground select-none"
          aria-expanded={open}
          role="combobox"
        >
          {languages.find((language) => language.value === value)?.label ??
            "Plain Text"}
        </Button>
      </PopoverTrigger>
      <PopoverContent
        className="w-[200px] p-0"
        onCloseAutoFocus={() => setSearchValue("")}
      >
        <Command shouldFilter={false}>
          <CommandInput
            className="h-9"
            value={searchValue}
            onValueChange={(value) => setSearchValue(value)}
            placeholder="Search language..."
          />
          <CommandEmpty>No language found.</CommandEmpty>

          <CommandList className="h-[344px] overflow-y-auto">
            <CommandGroup>
              {items.map((language) => (
                <CommandItem
                  key={language.label}
                  className="cursor-pointer"
                  value={language.value}
                  onSelect={(value) => {
                    editor.tf.setNodes<TCodeBlockElement>(
                      { lang: value },
                      { at: element },
                    );
                    setSearchValue(value);
                    setOpen(false);
                  }}
                >
                  <Check
                    className={cn(
                      value === language.value ? "opacity-100" : "opacity-0",
                    )}
                  />
                  {language.label}
                </CommandItem>
              ))}
            </CommandGroup>
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
}

// ========== FILE END: ui/elements/code/code-block-combobox.tsx ==========



// ========== FILE START: ui/elements/code/code-block-element-static.tsx ==========
import * as React from "react";

import type { TCodeBlockElement } from "@udecode/plate-code-block";

import { type SlateElementProps, SlateElement } from "@udecode/plate";

export function CodeBlockElementStatic(
  props: SlateElementProps<TCodeBlockElement>,
) {
  return (
    <SlateElement
      className="py-1 **:[.hljs-addition]:bg-[#f0fff4] **:[.hljs-addition]:text-[#22863a] **:[.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-variable]:text-[#005cc5] **:[.hljs-built_in,.hljs-symbol]:text-[#e36209] **:[.hljs-bullet]:text-[#735c0f] **:[.hljs-comment,.hljs-code,.hljs-formula]:text-[#6a737d] **:[.hljs-deletion]:bg-[#ffeef0] **:[.hljs-deletion]:text-[#b31d28] **:[.hljs-emphasis]:italic **:[.hljs-keyword,.hljs-doctag,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_]:text-[#d73a49] **:[.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo]:text-[#22863a] **:[.hljs-regexp,.hljs-string,.hljs-meta_.hljs-string]:text-[#032f62] **:[.hljs-section]:font-bold **:[.hljs-section]:text-[#005cc5] **:[.hljs-strong]:font-bold **:[.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_]:text-[#6f42c1]"
      {...props}
    >
      <div className="relative rounded-md bg-muted/50">
        <pre className="overflow-x-auto p-8 pr-4 font-mono text-sm leading-[normal] [tab-size:2] print:break-inside-avoid">
          <code>{props.children}</code>
        </pre>
      </div>
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/code/code-block-element-static.tsx ==========



// ========== FILE START: ui/elements/code/code-block-element.tsx ==========
"use client";

import * as React from "react";

import { NodeApi } from "@udecode/plate";
import {
  type TCodeBlockElement,
  formatCodeBlock,
  isLangSupported,
} from "@udecode/plate-code-block";
import { type PlateElementProps, PlateElement } from "@udecode/plate/react";
import { BracesIcon, CheckIcon, CopyIcon } from "lucide-react";

import { Button } from "@/components/ui/button";

import { CodeBlockCombobox } from "./code-block-combobox";

export function CodeBlockElement(props: PlateElementProps<TCodeBlockElement>) {
  const { editor, element } = props;

  return (
    <PlateElement
      className="py-1 **:[.hljs-addition]:bg-[#f0fff4] **:[.hljs-addition]:text-[#22863a] **:[.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-variable]:text-[#005cc5] **:[.hljs-built_in,.hljs-symbol]:text-[#e36209] **:[.hljs-bullet]:text-[#735c0f] **:[.hljs-comment,.hljs-code,.hljs-formula]:text-[#6a737d] **:[.hljs-deletion]:bg-[#ffeef0] **:[.hljs-deletion]:text-[#b31d28] **:[.hljs-emphasis]:italic **:[.hljs-keyword,.hljs-doctag,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_]:text-[#d73a49] **:[.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo]:text-[#22863a] **:[.hljs-regexp,.hljs-string,.hljs-meta_.hljs-string]:text-[#032f62] **:[.hljs-section]:font-bold **:[.hljs-section]:text-[#005cc5] **:[.hljs-strong]:font-bold **:[.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_]:text-[#6f42c1]"
      {...props}
    >
      <div className="relative rounded-md bg-muted/50">
        <pre className="overflow-x-auto p-8 pr-4 font-mono text-sm leading-[normal] [tab-size:2] print:break-inside-avoid">
          <code>{props.children}</code>
        </pre>

        <div
          className="absolute top-1 right-1 z-10 flex gap-0.5 select-none"
          contentEditable={false}
        >
          {isLangSupported(element.lang) && (
            <Button
              size="icon"
              variant="ghost"
              className="size-6 text-xs"
              onClick={() => formatCodeBlock(editor, { element })}
              title="Format code"
            >
              <BracesIcon className="!size-3.5 text-muted-foreground" />
            </Button>
          )}

          <CodeBlockCombobox />

          <CopyButton
            size="icon"
            variant="ghost"
            className="size-6 gap-1 text-xs text-muted-foreground"
            value={() => NodeApi.string(element)}
          />
        </div>
      </div>
    </PlateElement>
  );
}

function CopyButton({
  value,
  ...props
}: { value: (() => string) | string } & Omit<
  React.ComponentProps<typeof Button>,
  "value"
>) {
  const [hasCopied, setHasCopied] = React.useState(false);

  React.useEffect(() => {
    setTimeout(() => {
      setHasCopied(false);
    }, 2000);
  }, [hasCopied]);

  return (
    <Button
      onClick={() => {
        void navigator.clipboard.writeText(
          typeof value === "function" ? value() : value,
        );
        setHasCopied(true);
      }}
      {...props}
    >
      <span className="sr-only">Copy</span>
      {hasCopied ? (
        <CheckIcon className="!size-3" />
      ) : (
        <CopyIcon className="!size-3" />
      )}
    </Button>
  );
}

// ========== FILE END: ui/elements/code/code-block-element.tsx ==========



// ========== FILE START: ui/elements/code/code-leaf-static.tsx ==========
import * as React from "react";

import type { SlateLeafProps } from "@udecode/plate";

import { SlateLeaf } from "@udecode/plate";

export function CodeLeafStatic(props: SlateLeafProps) {
  return (
    <SlateLeaf
      {...props}
      as="code"
      className="rounded-md bg-muted px-[0.3em] py-[0.2em] font-mono text-sm whitespace-pre-wrap"
    >
      {props.children}
    </SlateLeaf>
  );
}

// ========== FILE END: ui/elements/code/code-leaf-static.tsx ==========



// ========== FILE START: ui/elements/code/code-leaf.tsx ==========
"use client";

import * as React from "react";

import type { PlateLeafProps } from "@udecode/plate/react";

import { PlateLeaf } from "@udecode/plate/react";

export function CodeLeaf(props: PlateLeafProps) {
  return (
    <PlateLeaf
      {...props}
      as="code"
      className="rounded-md bg-muted px-[0.3em] py-[0.2em] font-mono text-sm whitespace-pre-wrap"
    >
      {props.children}
    </PlateLeaf>
  );
}

// ========== FILE END: ui/elements/code/code-leaf.tsx ==========



// ========== FILE START: ui/elements/code/code-line-element-static.tsx ==========
import * as React from "react";

import { type SlateElementProps, SlateElement } from "@udecode/plate";

export function CodeLineElementStatic(props: SlateElementProps) {
  return <SlateElement {...props} />;
}

// ========== FILE END: ui/elements/code/code-line-element-static.tsx ==========



// ========== FILE START: ui/elements/code/code-line-element.tsx ==========
"use client";

import { type PlateElementProps, PlateElement } from "@udecode/plate/react";

export function CodeLineElement(props: PlateElementProps) {
  return <PlateElement {...props} />;
}

// ========== FILE END: ui/elements/code/code-line-element.tsx ==========



// ========== FILE START: ui/elements/code/code-syntax-leaf-static.tsx ==========
import * as React from "react";

import { type SlateLeafProps, SlateLeaf } from "@udecode/plate";

export function CodeSyntaxLeafStatic(props: SlateLeafProps) {
  const tokenClassName = props.leaf.className as string;

  return <SlateLeaf className={tokenClassName} {...props} />;
}

// ========== FILE END: ui/elements/code/code-syntax-leaf-static.tsx ==========



// ========== FILE START: ui/elements/code/code-syntax-leaf.tsx ==========
"use client";

import { type PlateLeafProps, PlateLeaf } from "@udecode/plate/react";

export function CodeSyntaxLeaf(props: PlateLeafProps) {
  const tokenClassName = props.leaf.className as string;

  return <PlateLeaf className={tokenClassName} {...props} />;
}

// ========== FILE END: ui/elements/code/code-syntax-leaf.tsx ==========



// ========== FILE START: ui/elements/comments-suggestions/block-discussion.tsx ==========
"use client";

import * as React from "react";

import type { TSuggestionText } from "@udecode/plate-suggestion";
import type {
  PlateElementProps,
  RenderNodeWrapper,
} from "@udecode/plate/react";

import {
  type AnyPluginConfig,
  type NodeEntry,
  type Path,
  type TElement,
  PathApi,
  TextApi,
} from "@udecode/plate";
import { type TCommentText, getDraftCommentKey } from "@udecode/plate-comments";
import { SuggestionPlugin } from "@udecode/plate-suggestion/react";
import {
  useEditorPlugin,
  useEditorRef,
  usePluginOption,
} from "@udecode/plate/react";
import {
  MessageSquareTextIcon,
  MessagesSquareIcon,
  PencilLineIcon,
} from "lucide-react";

import { Button } from "@/components/ui/button";
import {
  Popover,
  PopoverAnchor,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { commentsPlugin } from "../../../plugins/comments/comments-plugin";
import {
  type TDiscussion,
  discussionPlugin,
} from "../../../plugins/discussion-plugin";
import { suggestionPlugin } from "../../../plugins/suggestion-plugin";

import {
  BlockSuggestionCard,
  isResolvedSuggestion,
  useResolveSuggestion,
} from "./block-suggestion";
import { Comment } from "./comment";
import { CommentCreateForm } from "./comment-create-form";

export const BlockDiscussion: RenderNodeWrapper<AnyPluginConfig> = (props) => {
  const { editor, element } = props;

  if (!editor || !editor.api) {
    console.error("BlockDiscussion: editor or editor.api is undefined.", {
      editorExists: !!editor,
      apiExists: !!editor?.api,
    });
    return;
  }

  if (!element) {
    console.error("BlockDiscussion: element prop is undefined or null.");
    return;
  }

  let blockPath;
  try {
    blockPath = editor.api.findPath(element);
  } catch (e: any) {
    let safeElementLog = "Could not stringify element";
    try {
      safeElementLog = JSON.stringify(element).substring(0, 200) + "...";
    } catch {
      // ignore stringifyError, safeElementLog will retain its default error message
    }
    console.error(
      "BlockDiscussion: Call to editor.api.findPath(element) failed.",
      "Error Name:",
      e.name,
      "Error Message:",
      e.message,
      "Element Type:",
      (element as any)?.type,
      // "Is Slate Element:", editor.isElement(element), // Temporarily commented out due to type issue
      "Element Snippet:",
      safeElementLog,
      "Stack:",
      e.stack,
    );
    return;
  }

  // New way: Access comments API directly from editor.api
  if (!editor.api.comment) {
    console.error(
      "BlockDiscussion: editor.api.comment is not available.",
      {},
    );
    return;
  }
  const commentsApi = editor.api.comment;

  // avoid duplicate in table or column
  if (!blockPath || blockPath.length > 1) {
    return;
  }

  const draftCommentNode = commentsApi.node({ at: blockPath, isDraft: true });

  const commentNodes = [...commentsApi.nodes({ at: blockPath })];

  const suggestionNodes = [
    ...editor.getApi(SuggestionPlugin).suggestion.nodes({ at: blockPath }),
  ];

  if (
    commentNodes.length === 0 &&
    suggestionNodes.length === 0 &&
    !draftCommentNode
  ) {
    return;
  }

  // Give the returned component a name
  const BlockDiscussionContentWrapper = (contentProps: PlateElementProps) => (
    <BlockCommentsContent
      blockPath={blockPath}
      commentNodes={commentNodes}
      draftCommentNode={draftCommentNode}
      suggestionNodes={suggestionNodes}
      {...contentProps} // Use the props passed to this wrapper
    />
  );
  BlockDiscussionContentWrapper.displayName = "BlockDiscussionContentWrapper";

  return BlockDiscussionContentWrapper; // Return the named component
};

const BlockCommentsContent = ({
  blockPath,
  children,
  commentNodes,
  draftCommentNode,
  suggestionNodes,
}: PlateElementProps & {
  blockPath: Path;
  commentNodes: NodeEntry<TCommentText>[];
  draftCommentNode: NodeEntry<TCommentText> | undefined;
  suggestionNodes: NodeEntry<TElement | TSuggestionText>[];
}) => {
  const editor = useEditorRef();

  const resolvedSuggestions = useResolveSuggestion(suggestionNodes, blockPath);
  const resolvedDiscussions = useResolvedDiscussion(commentNodes, blockPath);

  const suggestionsCount = resolvedSuggestions.length;
  const discussionsCount = resolvedDiscussions.length;
  const totalCount = suggestionsCount + discussionsCount;

  const activeSuggestionId = usePluginOption(suggestionPlugin, "activeId");
  const activeSuggestion =
    activeSuggestionId &&
    resolvedSuggestions.find((s) => s.suggestionId === activeSuggestionId);

  const commentingBlock = usePluginOption(commentsPlugin, "commentingBlock");
  const activeCommentId = usePluginOption(commentsPlugin, "activeId");
  const isCommenting = activeCommentId === getDraftCommentKey();
  const activeDiscussion =
    activeCommentId &&
    resolvedDiscussions.find((d) => d.id === activeCommentId);

  const noneActive = !activeSuggestion && !activeDiscussion;

  const sortedMergedData = [
    ...resolvedDiscussions,
    ...resolvedSuggestions,
  ].sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());

  const selected =
    resolvedDiscussions.some((d) => d.id === activeCommentId) ||
    resolvedSuggestions.some((s) => s.suggestionId === activeSuggestionId);

  const [_open, setOpen] = React.useState(selected);

  // in some cases, we may comment the multiple blocks
  const commentingCurrent =
    !!commentingBlock && PathApi.equals(blockPath, commentingBlock);

  const open =
    _open ||
    selected ||
    (isCommenting && !!draftCommentNode && commentingCurrent);

  const anchorElement = React.useMemo(() => {
    let activeNode: NodeEntry | undefined;

    if (activeSuggestion) {
      activeNode = suggestionNodes.find(
        ([node]) =>
          TextApi.isText(node) &&
          editor.getApi(SuggestionPlugin).suggestion.nodeId(node) ===
            activeSuggestion.suggestionId,
      );
    }

    if (activeCommentId) {
      if (activeCommentId === getDraftCommentKey()) {
        activeNode = draftCommentNode;
      } else {
        activeNode = commentNodes.find(
          ([node]) =>
            editor.api.comment.nodeId(node) ===
            activeCommentId,
        );
      }
    }

    if (!activeNode) return null;

    return editor.api.toDOMNode(activeNode[0])!;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    open,
    activeSuggestion,
    activeCommentId,
    editor.api,
    suggestionNodes,
    draftCommentNode,
    commentNodes,
  ]);

  if (suggestionsCount + resolvedDiscussions.length === 0 && !draftCommentNode)
    return <div className="w-full">{children}</div>;

  return (
    <div className="flex w-full justify-between">
      <Popover
        open={open}
        onOpenChange={(_open_) => {
          if (!_open_ && isCommenting && draftCommentNode) {
            editor.tf.unsetNodes(getDraftCommentKey(), {
              at: [],
              mode: "lowest",
              match: (n) => n[getDraftCommentKey()],
            });
          }
          setOpen(_open_);
        }}
      >
        <div className="w-full">{children}</div>
        {anchorElement && (
          <PopoverAnchor
            asChild
            className="w-full"
            virtualRef={{ current: anchorElement }}
          />
        )}

        <PopoverContent
          className="max-h-[min(50dvh,calc(-24px+var(--radix-popper-available-height)))] w-[380px] max-w-[calc(100vw-24px)] min-w-[130px] overflow-y-auto p-0 data-[state=closed]:opacity-0"
          onCloseAutoFocus={(e) => e.preventDefault()}
          onOpenAutoFocus={(e) => e.preventDefault()}
          align="center"
          side="bottom"
        >
          {isCommenting ? (
            <CommentCreateForm className="p-4" focusOnMount />
          ) : (
            <React.Fragment>
              {noneActive ? (
                sortedMergedData.map((item, index) =>
                  isResolvedSuggestion(item) ? (
                    <BlockSuggestionCard
                      key={item.suggestionId}
                      idx={index}
                      isLast={index === sortedMergedData.length - 1}
                      suggestion={item}
                    />
                  ) : (
                    <BlockComment
                      key={item.id}
                      discussion={item}
                      isLast={index === sortedMergedData.length - 1}
                    />
                  ),
                )
              ) : (
                <React.Fragment>
                  {activeSuggestion && (
                    <BlockSuggestionCard
                      key={activeSuggestion.suggestionId}
                      idx={0}
                      isLast={true}
                      suggestion={activeSuggestion}
                    />
                  )}

                  {activeDiscussion && (
                    <BlockComment discussion={activeDiscussion} isLast={true} />
                  )}
                </React.Fragment>
              )}
            </React.Fragment>
          )}
        </PopoverContent>

        {totalCount > 0 && (
          <div className="relative left-0 size-0 select-none">
            <PopoverTrigger asChild>
              <Button
                variant="ghost"
                className="mt-1 ml-1 flex h-6 gap-1 px-1.5 py-0 text-muted-foreground/80 hover:text-muted-foreground/80 data-[active=true]:bg-muted"
                data-active={open}
                contentEditable={false}
              >
                {suggestionsCount > 0 && discussionsCount === 0 && (
                  <PencilLineIcon className="size-4 shrink-0" />
                )}

                {suggestionsCount === 0 && discussionsCount > 0 && (
                  <MessageSquareTextIcon className="size-4 shrink-0" />
                )}

                {suggestionsCount > 0 && discussionsCount > 0 && (
                  <MessagesSquareIcon className="size-4 shrink-0" />
                )}

                <span className="text-xs font-semibold">{totalCount}</span>
              </Button>
            </PopoverTrigger>
          </div>
        )}
      </Popover>
    </div>
  );
};

BlockCommentsContent.displayName = "BlockCommentsContent";

export const BlockComment = ({
  discussion,
  isLast,
}: {
  discussion: TDiscussion;
  isLast: boolean;
}) => {
  const [editingId, setEditingId] = React.useState<string | null>(null);

  return (
    <React.Fragment key={discussion.id}>
      <div className="p-4">
        {discussion.comments.map((comment, index) => (
          <Comment
            key={comment.id ?? index}
            comment={comment}
            discussionLength={discussion.comments.length}
            documentContent={discussion?.documentContent}
            editingId={editingId}
            index={index}
            setEditingId={setEditingId}
            showDocumentContent
          />
        ))}
        <CommentCreateForm discussionId={discussion.id} />
      </div>

      {!isLast && <div className="h-px w-full bg-muted" />}
    </React.Fragment>
  );
};

export const useResolvedDiscussion = (
  commentNodes: NodeEntry<TCommentText>[],
  blockPath: Path,
) => {
  const editor = useEditorRef();
  const { getOption, setOption } = useEditorPlugin(commentsPlugin);
  const commentsApi = editor.api.comment;
  const discussions = usePluginOption(discussionPlugin, "discussions");

  // Update uniquePathMap only when commentNodes or blockPath change
  React.useEffect(() => {
    commentNodes.forEach(([node]) => {
      const id = commentsApi.nodeId(node);
      const map = getOption("uniquePathMap");

      if (!id) return;

      const previousPath = map.get(id);
      if (PathApi.isPath(previousPath)) {
        const nodes = commentsApi.node({ id, at: previousPath });
        if (!nodes) {
          setOption("uniquePathMap", new Map(map).set(id, blockPath));
        }
        return;
      }
      setOption("uniquePathMap", new Map(map).set(id, blockPath));
    });
  }, [commentNodes, blockPath, commentsApi, getOption, setOption]);

  const commentsIds = new Set(
    commentNodes.map(([node]) => commentsApi.nodeId(node)).filter(Boolean),
  );

  const resolvedDiscussions = discussions
    .map((d: TDiscussion) => ({
      ...d,
      createdAt: new Date(d.createdAt),
    }))
    .filter((item: TDiscussion) => {
      /** If comment cross blocks just show it in the first block */
      const commentsPathMap = getOption("uniquePathMap");
      const firstBlockPath = commentsPathMap.get(item.id);

      if (!firstBlockPath) return false;
      if (!PathApi.equals(firstBlockPath, blockPath)) return false;

      return (
        commentsApi.has({ id: item.id }) &&
        commentsIds.has(item.id) &&
        !item.isResolved
      );
    });

  return resolvedDiscussions;
};

// ========== FILE END: ui/elements/comments-suggestions/block-discussion.tsx ==========



// ========== FILE START: ui/elements/comments-suggestions/block-suggestion.tsx ==========
"use client";

import * as React from "react";

import type {
  TResolvedSuggestion,
  TSuggestionElement,
  TSuggestionText,
} from "@udecode/plate-suggestion";

import {
  type NodeEntry,
  type Path,
  type TElement,
  ElementApi,
  PathApi,
  TextApi,
} from "@udecode/plate";
import { BlockquotePlugin } from "@udecode/plate-block-quote/react";
import { CalloutPlugin } from "@udecode/plate-callout/react";
import { CodeBlockPlugin } from "@udecode/plate-code-block/react";
import { HEADING_KEYS } from "@udecode/plate-heading";
import { TocPlugin } from "@udecode/plate-heading/react";
import { HorizontalRulePlugin } from "@udecode/plate-horizontal-rule/react";
import { INDENT_LIST_KEYS, ListStyleType } from "@udecode/plate-indent-list";
import { IndentListPlugin } from "@udecode/plate-indent-list/react";
import { ColumnPlugin } from "@udecode/plate-layout/react";
import { EquationPlugin } from "@udecode/plate-math/react";
import {
  AudioPlugin,
  FilePlugin,
  ImagePlugin,
  MediaEmbedPlugin,
  VideoPlugin,
} from "@udecode/plate-media/react";
import {
  acceptSuggestion,
  getSuggestionKey,
  keyId2SuggestionId,
  rejectSuggestion,
} from "@udecode/plate-suggestion";
import { SuggestionPlugin } from "@udecode/plate-suggestion/react";
import { TablePlugin } from "@udecode/plate-table/react";
import { TogglePlugin } from "@udecode/plate-toggle/react";
import {
  ParagraphPlugin,
  useEditorPlugin,
  usePluginOption,
} from "@udecode/plate/react";
import { CheckIcon, XIcon } from "lucide-react";

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import {
  type TDiscussion,
  discussionPlugin,
} from "../../../plugins/discussion-plugin";
import { suggestionPlugin } from "../../../plugins/suggestion-plugin";

import { type TComment, Comment, useRelativeDate } from "./comment";
import { CommentCreateForm } from "./comment-create-form";

export interface ResolvedSuggestion extends TResolvedSuggestion {
  comments: TComment[];
}

export const BLOCK_SUGGESTION = "__block__";

export const TYPE_TEXT_MAP: Record<string, (node?: TElement) => string> = {
  [AudioPlugin.key]: () => "Audio",
  [BlockquotePlugin.key]: () => "Blockquote",
  [CalloutPlugin.key]: () => "Callout",
  [CodeBlockPlugin.key]: () => "Code Block",
  [ColumnPlugin.key]: () => "Column",
  [EquationPlugin.key]: () => "Equation",
  [FilePlugin.key]: () => "File",
  [HEADING_KEYS.h1]: () => `Heading 1`,
  [HEADING_KEYS.h2]: () => `Heading 2`,
  [HEADING_KEYS.h3]: () => `Heading 3`,
  [HEADING_KEYS.h4]: () => `Heading 4`,
  [HEADING_KEYS.h5]: () => `Heading 5`,
  [HEADING_KEYS.h6]: () => `Heading 6`,
  [HorizontalRulePlugin.key]: () => "Horizontal Rule",
  [ImagePlugin.key]: () => "Image",
  [MediaEmbedPlugin.key]: () => "Media",
  [ParagraphPlugin.key]: (node) => {
    if (node?.[IndentListPlugin.key] === INDENT_LIST_KEYS.todo)
      return "Todo List";
    if (node?.[IndentListPlugin.key] === ListStyleType.Decimal)
      return "Ordered List";
    if (node?.[IndentListPlugin.key] === ListStyleType.Disc) return "List";

    return "Paragraph";
  },
  [TablePlugin.key]: () => "Table",
  [TocPlugin.key]: () => "Table of Contents",
  [TogglePlugin.key]: () => "Toggle",
  [VideoPlugin.key]: () => "Video",
};

export const BlockSuggestionCard = ({
  idx,
  isLast,
  suggestion,
}: {
  idx: number;
  isLast: boolean;
  suggestion: ResolvedSuggestion;
}) => {
  const { api, editor } = useEditorPlugin(SuggestionPlugin);

  const userInfo = usePluginOption(discussionPlugin, "user", suggestion.userId);
  const relativeDate = useRelativeDate(new Date(suggestion.createdAt));

  const accept = (suggestion: ResolvedSuggestion) => {
    api.suggestion.withoutSuggestions(() => {
      acceptSuggestion(editor, suggestion);
    });
  };

  const reject = (suggestion: ResolvedSuggestion) => {
    api.suggestion.withoutSuggestions(() => {
      rejectSuggestion(editor, suggestion);
    });
  };

  const [hovering, setHovering] = React.useState(false);

  const suggestionText2Array = (text: string) => {
    if (text === BLOCK_SUGGESTION) return ["line breaks"];

    return text.split(BLOCK_SUGGESTION).filter(Boolean);
  };

  const [editingId, setEditingId] = React.useState<string | null>(null);

  return (
    <div
      key={`${suggestion.suggestionId}-${idx}`}
      className="relative"
      onMouseEnter={() => setHovering(true)}
      onMouseLeave={() => setHovering(false)}
    >
      <div className="flex flex-col p-4">
        <div className="relative flex items-center">
          {/* Replace to your own backend or refer to potion */}
          <Avatar className="size-5">
            <AvatarImage alt={userInfo?.name} src={userInfo?.avatarUrl} />
            <AvatarFallback>{userInfo?.name?.[0]}</AvatarFallback>
          </Avatar>
          <h4 className="mx-2 text-sm leading-none font-semibold">
            {userInfo?.name}
          </h4>
          <div className="text-xs leading-none text-muted-foreground/80">
            <span className="mr-1">{relativeDate}</span>
          </div>
        </div>

        <div className="relative mt-1 mb-4 pl-[32px]">
          <div className="flex flex-col gap-2">
            {suggestion.type === "remove" && (
              <React.Fragment>
                {suggestionText2Array(suggestion.text!).map((text, index) => (
                  <div key={index} className="flex items-center gap-2">
                    <span className="text-sm text-muted-foreground">
                      Delete:
                    </span>

                    <span key={index} className="text-sm">
                      {text}
                    </span>
                  </div>
                ))}
              </React.Fragment>
            )}

            {suggestion.type === "insert" && (
              <React.Fragment>
                {suggestionText2Array(suggestion.newText!).map(
                  (text, index) => (
                    <div key={index} className="flex items-center gap-2">
                      <span className="text-sm text-muted-foreground">
                        Add:
                      </span>

                      <span key={index} className="text-sm">
                        {text || "line breaks"}
                      </span>
                    </div>
                  ),
                )}
              </React.Fragment>
            )}

            {suggestion.type === "replace" && (
              <div className="flex flex-col gap-2">
                {suggestionText2Array(suggestion.newText!).map(
                  (text, index) => (
                    <React.Fragment key={index}>
                      <div
                        key={index}
                        className="flex items-start gap-2 text-brand/80"
                      >
                        <span className="text-sm">with:</span>
                        <span className="text-sm">{text || "line breaks"}</span>
                      </div>
                    </React.Fragment>
                  ),
                )}

                {suggestionText2Array(suggestion.text!).map((text, index) => (
                  <React.Fragment key={index}>
                    <div key={index} className="flex items-start gap-2">
                      <span className="text-sm text-muted-foreground">
                        {index === 0 ? "Replace:" : "Delete:"}
                      </span>
                      <span className="text-sm">{text || "line breaks"}</span>
                    </div>
                  </React.Fragment>
                ))}
              </div>
            )}

            {suggestion.type === "update" && (
              <div className="flex items-center gap-2">
                <span className="text-sm text-muted-foreground">
                  {Object.keys(suggestion.properties).map((key) => (
                    <span key={key}>Un{key}</span>
                  ))}

                  {Object.keys(suggestion.newProperties).map((key) => (
                    <span key={key}>
                      {key.charAt(0).toUpperCase() + key.slice(1)}
                    </span>
                  ))}
                </span>
                <span className="text-sm">{suggestion.newText}</span>
              </div>
            )}
          </div>
        </div>

        {suggestion.comments.map((comment, index) => (
          <Comment
            key={comment.id ?? index}
            comment={comment}
            discussionLength={suggestion.comments.length}
            documentContent="__suggestion__"
            editingId={editingId}
            index={index}
            setEditingId={setEditingId}
          />
        ))}

        {hovering && (
          <div className="absolute top-4 right-4 flex gap-2">
            <Button
              variant="ghost"
              className="h-6 p-1 text-muted-foreground"
              onClick={() => accept(suggestion)}
            >
              <CheckIcon className="size-4" />
            </Button>

            <Button
              variant="ghost"
              className="h-6 p-1 text-muted-foreground"
              onClick={() => reject(suggestion)}
            >
              <XIcon className="size-4" />
            </Button>
          </div>
        )}

        <CommentCreateForm discussionId={suggestion.suggestionId} />
      </div>

      {!isLast && <div className="h-px w-full bg-muted" />}
    </div>
  );
};

export const useResolveSuggestion = (
  suggestionNodes: NodeEntry<TElement | TSuggestionText>[],
  blockPath: Path,
) => {
  const discussions = usePluginOption(discussionPlugin, "discussions");

  const { api, editor, getOption, setOption } =
    useEditorPlugin(suggestionPlugin);

  suggestionNodes.forEach(([node]) => {
    const id = api.suggestion.nodeId(node);
    const map = getOption("uniquePathMap");

    if (!id) return;

    const previousPath = map.get(id);

    // If there are no suggestion nodes in the corresponding path in the map, then update it.
    if (PathApi.isPath(previousPath)) {
      const nodes = api.suggestion.node({ id, at: previousPath, isText: true });
      const parentNode = api.node(previousPath);
      let lineBreakId: string | null = null;

      if (parentNode && ElementApi.isElement(parentNode[0])) {
        lineBreakId = api.suggestion.nodeId(parentNode[0]) ?? null;
      }

      if (!nodes && lineBreakId !== id) {
        return setOption("uniquePathMap", new Map(map).set(id, blockPath));
      }

      return;
    }
    setOption("uniquePathMap", new Map(map).set(id, blockPath));
  });

  const resolvedSuggestion: ResolvedSuggestion[] = React.useMemo(() => {
    const map = getOption("uniquePathMap");

    if (suggestionNodes.length === 0) return [];

    const suggestionIds = new Set(
      suggestionNodes
        .flatMap(([node]) => {
          if (TextApi.isText(node)) {
            const dataList = api.suggestion.dataList(node);
            const includeUpdate = dataList.some(
              (data) => data.type === "update",
            );

            if (!includeUpdate) return api.suggestion.nodeId(node);

            return dataList
              .filter((data) => data.type === "update")
              .map((d) => d.id);
          }
          if (ElementApi.isElement(node)) {
            return api.suggestion.nodeId(node);
          }
        })
        .filter(Boolean),
    );

    const res: ResolvedSuggestion[] = [];

    suggestionIds.forEach((id) => {
      if (!id) return;

      const path = map.get(id);

      if (!path || !PathApi.isPath(path)) return;
      if (!PathApi.equals(path, blockPath)) return;

      const entries = [
        ...editor.api.nodes<TElement | TSuggestionText>({
          at: [],
          mode: "all",
          match: (n) =>
            (n[SuggestionPlugin.key] && n[getSuggestionKey(id)]) ||
            api.suggestion.nodeId(n as TElement) === id,
        }),
      ];

      // move line break to the end
      entries.sort(([, path1], [, path2]) => {
        return PathApi.isChild(path1, path2) ? -1 : 1;
      });

      let newText = "";
      let text = "";
      let properties: Record<string, unknown> = {};
      let newProperties: Record<string, unknown> = {};

      // overlapping suggestion
      entries.forEach(([node]) => {
        if (TextApi.isText(node)) {
          const dataList = api.suggestion.dataList(node);

          dataList.forEach((data) => {
            if (data.id !== id) return;

            switch (data.type) {
              case "insert": {
                newText += node.text;

                break;
              }
              case "remove": {
                text += node.text;

                break;
              }
              case "update": {
                properties = {
                  ...properties,
                  ...data.properties,
                };

                newProperties = {
                  ...newProperties,
                  ...data.newProperties,
                };

                newText += node.text;

                break;
              }
              // No default
            }
          });
        } else {
          const lineBreakData = api.suggestion.isBlockSuggestion(node)
            ? node.suggestion
            : undefined;

          if (lineBreakData?.id !== keyId2SuggestionId(id)) return;

          let nodeTypeText = `Unknown Block Type: ${node.type}`;
          const typeTextGenerator = TYPE_TEXT_MAP[node.type];
          if (typeof typeTextGenerator === "function") {
            nodeTypeText = typeTextGenerator(node);
          }

          if (lineBreakData.type === "insert") {
            newText += lineBreakData.isLineBreak
              ? BLOCK_SUGGESTION
              : BLOCK_SUGGESTION + nodeTypeText;
          } else if (lineBreakData.type === "remove") {
            text += lineBreakData.isLineBreak
              ? BLOCK_SUGGESTION
              : BLOCK_SUGGESTION + nodeTypeText;
          }
        }
      });

      if (entries.length === 0) return;

      const nodeData = api.suggestion.suggestionData(entries[0][0]);

      if (!nodeData) return;

      // const comments = data?.discussions.find((d) => d.id === id)?.comments;
      const comments =
        discussions.find((s: TDiscussion) => s.id === id)?.comments || [];
      const createdAt = new Date(nodeData.createdAt);

      const keyId = getSuggestionKey(id);

      if (nodeData.type === "update") {
        return res.push({
          comments,
          createdAt,
          keyId,
          newProperties,
          newText,
          properties,
          suggestionId: keyId2SuggestionId(id),
          type: "update",
          userId: nodeData.userId,
        });
      }
      if (newText.length > 0 && text.length > 0) {
        return res.push({
          comments,
          createdAt,
          keyId,
          newText,
          suggestionId: keyId2SuggestionId(id),
          text,
          type: "replace",
          userId: nodeData.userId,
        });
      }
      if (newText.length > 0) {
        return res.push({
          comments,
          createdAt,
          keyId,
          newText,
          suggestionId: keyId2SuggestionId(id),
          type: "insert",
          userId: nodeData.userId,
        });
      }
      if (text.length > 0) {
        return res.push({
          comments,
          createdAt,
          keyId,
          suggestionId: keyId2SuggestionId(id),
          text,
          type: "remove",
          userId: nodeData.userId,
        });
      }
    });

    return res;
  }, [
    api.suggestion,
    blockPath,
    discussions,
    editor.api,
    getOption,
    suggestionNodes,
  ]);

  return resolvedSuggestion;
};

export const isResolvedSuggestion = (
  suggestion: ResolvedSuggestion | TDiscussion,
): suggestion is ResolvedSuggestion => {
  return "suggestionId" in suggestion;
};

export function BlockSuggestion({ element }: { element: TSuggestionElement }) {
  const suggestionData = element.suggestion;

  if (suggestionData?.isLineBreak) return null;

  const isRemove = suggestionData?.type === "remove";

  return (
    <div
      className={cn(
        "pointer-events-none absolute inset-0 z-1 border-2 border-brand/[0.8] transition-opacity",
        isRemove && "border-gray-300",
      )}
      contentEditable={false}
    />
  );
}

// ========== FILE END: ui/elements/comments-suggestions/block-suggestion.tsx ==========



// ========== FILE START: ui/elements/comments-suggestions/comment-create-form.tsx ==========
"use client";

import * as React from "react";

import { withProps } from "@udecode/cn";
import { type Value, nanoid, NodeApi } from "@udecode/plate";
import { AIPlugin } from "@udecode/plate-ai/react";
import {
  BasicMarksPlugin,
  BoldPlugin,
  ItalicPlugin,
  StrikethroughPlugin,
  UnderlinePlugin,
} from "@udecode/plate-basic-marks/react";
import { getCommentKey, getDraftCommentKey } from "@udecode/plate-comments";
import { useCommentId } from "@udecode/plate-comments/react";
import { commentsPlugin } from "../../../plugins/comments/comments-plugin";
import { DatePlugin } from "@udecode/plate-date/react";
import { EmojiInputPlugin } from "@udecode/plate-emoji/react";
import { LinkPlugin } from "@udecode/plate-link/react";
import { InlineEquationPlugin } from "@udecode/plate-math/react";
import {
  MentionInputPlugin,
  MentionPlugin,
} from "@udecode/plate-mention/react";
import { Plate, useEditorRef, usePluginOption } from "@udecode/plate/react";
import { type CreatePlateEditorOptions, PlateLeaf } from "@udecode/plate/react";
import { ArrowUpIcon } from "lucide-react";

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import {
  type TDiscussion,
  discussionPlugin,
} from "../../../plugins/discussion-plugin";
import { useCreateEditor } from "../../../core/use-create-editor";

import type { TComment } from "./comment";

import { AILeaf } from "../ai/ai-leaf";
import { DateElement } from "../date/date-element";
import { Editor, EditorContainer } from "../../primitives/editor";
import { EmojiInputElement } from "../../menus/emoji/emoji-input-element";
import { InlineEquationElement } from "../equation/inline-equation-element";
import { LinkElement } from "../link/link-element";
import { MentionElement } from "../mention/mention-element";
import { MentionInputElement } from "../mention/mention-input-element";

export const useCommentEditor = (
  options: Omit<CreatePlateEditorOptions, "plugins"> = {},
  deps: React.DependencyList = [],
) => {
  const commentEditor = useCreateEditor(
    {
      id: "comment",
      components: {
        [AIPlugin.key]: AILeaf,
        [BoldPlugin.key]: withProps(PlateLeaf, { as: "strong" }),
        [DatePlugin.key]: DateElement,
        [EmojiInputPlugin.key]: EmojiInputElement,
        [InlineEquationPlugin.key]: InlineEquationElement,
        [ItalicPlugin.key]: withProps(PlateLeaf, { as: "em" }),
        [LinkPlugin.key]: LinkElement,
        [MentionInputPlugin.key]: MentionInputElement,
        [MentionPlugin.key]: MentionElement,
        [StrikethroughPlugin.key]: withProps(PlateLeaf, { as: "s" }),
        [UnderlinePlugin.key]: withProps(PlateLeaf, { as: "u" }),
        // [SlashInputPlugin.key]: SlashInputElement,
      },
      placeholders: false,
      plugins: [BasicMarksPlugin],
      value: [],
      ...options,
    },
    deps,
  );

  return commentEditor;
};

export function CommentCreateForm({
  autoFocus = false,
  className,
  discussionId: discussionIdProp,
  focusOnMount = false,
}: {
  autoFocus?: boolean;
  className?: string;
  discussionId?: string;
  focusOnMount?: boolean;
}) {
  const discussions = usePluginOption(discussionPlugin, "discussions");

  const editor = useEditorRef();
  const commentId = useCommentId();
  const discussionId = discussionIdProp ?? commentId;

  const userInfo = usePluginOption(discussionPlugin, "currentUser");
  const [commentValue, setCommentValue] = React.useState<Value | undefined>();
  const commentContent = React.useMemo(
    () =>
      commentValue ? NodeApi.string({ children: commentValue, type: "p" }) : "",
    [commentValue],
  );
  const commentEditor = useCommentEditor({}, []);

  React.useEffect(() => {
    if (commentEditor && focusOnMount) {
      commentEditor.tf.focus();
    }
  }, [commentEditor, focusOnMount]);

  const onAddComment = React.useCallback(async () => {
    if (!commentValue) return;

    commentEditor.tf.reset();

    if (discussionId) {
      // Get existing discussion
      const discussion = discussions.find((d) => d.id === discussionId);
      if (!discussion) {
        // Mock creating suggestion
        const newDiscussion: TDiscussion = {
          id: discussionId,
          comments: [
            {
              id: nanoid(),
              contentRich: commentValue,
              createdAt: new Date(),
              discussionId,
              isEdited: false,
              userId: editor.getOption(discussionPlugin, "currentUserId"),
            },
          ],
          createdAt: new Date(),
          isResolved: false,
          userId: editor.getOption(discussionPlugin, "currentUserId"),
        };

        editor.setOption(discussionPlugin, "discussions", [
          ...discussions,
          newDiscussion,
        ]);
        return;
      }

      // Create reply comment
      const comment: TComment = {
        id: nanoid(),
        contentRich: commentValue,
        createdAt: new Date(),
        discussionId,
        isEdited: false,
        userId: editor.getOption(discussionPlugin, "currentUserId"),
      };

      // Add reply to discussion comments
      const updatedDiscussion = {
        ...discussion,
        comments: [...discussion.comments, comment],
      };

      // Filter out old discussion and add updated one
      const updatedDiscussions = discussions
        .filter((d) => d.id !== discussionId)
        .concat(updatedDiscussion);

      editor.setOption(discussionPlugin, "discussions", updatedDiscussions);

      return;
    }

    const commentsNodeEntry = editor
      .getApi(commentsPlugin)
      .comment.nodes({ at: [], isDraft: true });

    if (commentsNodeEntry.length === 0) return;

    const documentContent = commentsNodeEntry
      .map(([node]) => node.text)
      .join("");

    const _discussionId = nanoid();
    // Mock creating new discussion
    const newDiscussion: TDiscussion = {
      id: _discussionId,
      comments: [
        {
          id: nanoid(),
          contentRich: commentValue,
          createdAt: new Date(),
          discussionId: _discussionId,
          isEdited: false,
          userId: editor.getOption(discussionPlugin, "currentUserId"),
        },
      ],
      createdAt: new Date(),
      documentContent,
      isResolved: false,
      userId: editor.getOption(discussionPlugin, "currentUserId"),
    };

    editor.setOption(discussionPlugin, "discussions", [
      ...discussions,
      newDiscussion,
    ]);

    const id = newDiscussion.id;

    commentsNodeEntry.forEach(([, path]) => {
      editor.tf.setNodes(
        {
          [getCommentKey(id)]: true,
        },
        { at: path, split: true },
      );
      editor.tf.unsetNodes([getDraftCommentKey()], { at: path });
    });
  }, [commentValue, commentEditor.tf, discussionId, editor, discussions]);

  return (
    <div className={cn("flex w-full", className)}>
      <div className="mt-2 mr-1 shrink-0">
        {/* Replace to your own backend or refer to potion */}
        <Avatar className="size-5">
          <AvatarImage alt={userInfo?.name} src={userInfo?.avatarUrl} />
          <AvatarFallback>{userInfo?.name?.[0]}</AvatarFallback>
        </Avatar>
      </div>

      <div className="relative flex grow gap-2">
        <Plate
          onChange={({ value }) => {
            setCommentValue(value);
          }}
          editor={commentEditor}
        >
          <EditorContainer variant="comment">
            <Editor
              variant="comment"
              className="min-h-[25px] grow pt-0.5 pr-8"
              onKeyDown={(e) => {
                if (e.key === "Enter" && !e.shiftKey) {
                  e.preventDefault();
                  onAddComment();
                }
              }}
              placeholder="Reply..."
              autoComplete="off"
              autoFocus={autoFocus}
            />

            <Button
              size="icon"
              variant="ghost"
              className="absolute right-0.5 bottom-0.5 ml-auto shrink-0"
              disabled={commentContent.trim().length === 0}
              onClick={(e) => {
                e.stopPropagation();
                onAddComment();
              }}
            >
              <div className="flex size-6 items-center justify-center rounded-full">
                <ArrowUpIcon />
              </div>
            </Button>
          </EditorContainer>
        </Plate>
      </div>
    </div>
  );
}

// ========== FILE END: ui/elements/comments-suggestions/comment-create-form.tsx ==========



// ========== FILE START: ui/elements/comments-suggestions/comment-leaf-static.tsx ==========
import * as React from "react";

import type { SlateLeafProps } from "@udecode/plate";
import type { TCommentText } from "@udecode/plate-comments";

import { SlateLeaf } from "@udecode/plate";

export function CommentLeafStatic(props: SlateLeafProps<TCommentText>) {
  return (
    <SlateLeaf
      {...props}
      className="border-b-2 border-b-highlight/35 bg-highlight/15"
    >
      {props.children}
    </SlateLeaf>
  );
}

// ========== FILE END: ui/elements/comments-suggestions/comment-leaf-static.tsx ==========



// ========== FILE START: ui/elements/comments-suggestions/comment-leaf.tsx ==========
"use client";

import * as React from "react";

import type { TCommentText } from "@udecode/plate-comments";
import type { PlateLeafProps } from "@udecode/plate/react";

import { getCommentCount } from "@udecode/plate-comments";
import {
  PlateLeaf,
  useEditorPlugin,
  usePluginOption,
} from "@udecode/plate/react";

import { cn } from "@/lib/utils";
import { commentsPlugin } from "../../../plugins/comments/comments-plugin";

export function CommentLeaf(props: PlateLeafProps<TCommentText>) {
  const { children, leaf } = props;

  const { api, setOption } = useEditorPlugin(commentsPlugin);
  const hoverId = usePluginOption(commentsPlugin, "hoverId");
  const activeId = usePluginOption(commentsPlugin, "activeId");

  const isOverlapping = getCommentCount(leaf) > 1;
  const currentId = api.comment.nodeId(leaf);
  const isActive = activeId === currentId;
  const isHover = hoverId === currentId;

  return (
    <PlateLeaf
      {...props}
      className={cn(
        "border-b-2 border-b-highlight/[.36] bg-highlight/[.13] transition-colors duration-200",
        (isHover || isActive) && "border-b-highlight bg-highlight/25",
        isOverlapping && "border-b-2 border-b-highlight/[.7] bg-highlight/25",
        (isHover || isActive) &&
          isOverlapping &&
          "border-b-highlight bg-highlight/45",
      )}
      attributes={{
        ...props.attributes,
        onClick: () => setOption("activeId", currentId ?? null),
        onMouseEnter: () => setOption("hoverId", currentId ?? null),
        onMouseLeave: () => setOption("hoverId", null),
      }}
    >
      {children}
    </PlateLeaf>
  );
}

// ========== FILE END: ui/elements/comments-suggestions/comment-leaf.tsx ==========



// ========== FILE START: ui/elements/comments-suggestions/comment.tsx ==========
"use client";

import * as React from "react";

import type { Value } from "@udecode/plate";

import {
  Plate,
  useEditorPlugin,
  useEditorRef,
  usePluginOption,
} from "@udecode/plate/react";
import {
  differenceInDays,
  differenceInHours,
  differenceInMinutes,
  format,
} from "date-fns";
import {
  CheckIcon,
  MoreHorizontalIcon,
  PencilIcon,
  TrashIcon,
  XIcon,
} from "lucide-react";

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { cn } from "@/lib/utils";
import { discussionPlugin } from "../../../plugins/discussion-plugin";

import { useCommentEditor } from "./comment-create-form";
import { Editor, EditorContainer } from "../../primitives/editor";
import { commentsPlugin } from "../../../plugins/comments/comments-plugin";

// Return a stable string during SSR to avoid hydration mismatches. We compute the real
// relative time once the component is mounted on the client.
export const formatCommentDate = (date: Date) => {
  if (typeof window === "undefined") {
    return ""; // empty during SSR  will be filled on the client after hydration
  }

  const now = new Date();
  const diffMinutes = differenceInMinutes(now, date);
  const diffHours = differenceInHours(now, date);
  const diffDays = differenceInDays(now, date);

  if (diffMinutes < 60) {
    return `${diffMinutes}m`;
  }
  if (diffHours < 24) {
    return `${diffHours}h`;
  }
  if (diffDays < 2) {
    return `${diffDays}d`;
  }

  return format(date, "MM/dd/yyyy");
};

// Small hook to compute relative date string on the client only.
export const useRelativeDate = (date: Date) => {
  const [text, setText] = React.useState<string>("");

  React.useEffect(() => {
    setText(formatCommentDate(date));
  }, [date]);

  return text;
};

export interface TComment {
  id: string;
  contentRich: Value;
  createdAt: Date;
  discussionId: string;
  isEdited: boolean;
  userId: string;
}

export function Comment(props: {
  comment: TComment;
  discussionLength: number;
  editingId: string | null;
  index: number;
  setEditingId: React.Dispatch<React.SetStateAction<string | null>>;
  documentContent?: string;
  showDocumentContent?: boolean;
  onEditorClick?: () => void;
}) {
  const {
    comment,
    discussionLength,
    documentContent,
    editingId,
    index,
    setEditingId,
    showDocumentContent = false,
    onEditorClick,
  } = props;

  const editor = useEditorRef();
  const userInfo = usePluginOption(discussionPlugin, "user", comment.userId);
  const currentUserId = usePluginOption(discussionPlugin, "currentUserId");
  const relativeDate = useRelativeDate(new Date(comment.createdAt));

  const resolveDiscussion = async (id: string) => {
    const updatedDiscussions = editor
      .getOption(discussionPlugin, "discussions")
      .map((discussion) => {
        if (discussion.id === id) {
          return { ...discussion, isResolved: true };
        }
        return discussion;
      });
    editor.setOption(discussionPlugin, "discussions", updatedDiscussions);
  };

  const removeDiscussion = async (id: string) => {
    const updatedDiscussions = editor
      .getOption(discussionPlugin, "discussions")
      .filter((discussion) => discussion.id !== id);
    editor.setOption(discussionPlugin, "discussions", updatedDiscussions);
  };

  const updateComment = async (input: {
    id: string;
    contentRich: Value;
    discussionId: string;
    isEdited: boolean;
  }) => {
    const updatedDiscussions = editor
      .getOption(discussionPlugin, "discussions")
      .map((discussion) => {
        if (discussion.id === input.discussionId) {
          const updatedComments = discussion.comments.map((comment) => {
            if (comment.id === input.id) {
              return {
                ...comment,
                contentRich: input.contentRich,
                isEdited: true,
                updatedAt: new Date(),
              };
            }
            return comment;
          });
          return { ...discussion, comments: updatedComments };
        }
        return discussion;
      });
    editor.setOption(discussionPlugin, "discussions", updatedDiscussions);
  };

  const { tf } = useEditorPlugin(commentsPlugin);

  // Replace to your own backend or refer to potion
  const isMyComment = currentUserId === comment.userId;

  const initialValue = comment.contentRich;

  const commentEditor = useCommentEditor(
    {
      id: comment.id,
      value: initialValue,
    },
    [initialValue],
  );

  const onCancel = () => {
    setEditingId(null);
    commentEditor.tf.replaceNodes(initialValue, {
      at: [],
      children: true,
    });
  };

  const onSave = () => {
    void updateComment({
      id: comment.id,
      contentRich: commentEditor.children,
      discussionId: comment.discussionId,
      isEdited: true,
    });
    setEditingId(null);
  };

  const onResolveComment = () => {
    void resolveDiscussion(comment.discussionId);
    tf.comment.unsetMark({ id: comment.discussionId });
  };

  const isFirst = index === 0;
  const isLast = index === discussionLength - 1;
  const isEditing = editingId && editingId === comment.id;

  const [hovering, setHovering] = React.useState(false);
  const [dropdownOpen, setDropdownOpen] = React.useState(false);

  return (
    <div
      onMouseEnter={() => setHovering(true)}
      onMouseLeave={() => setHovering(false)}
    >
      <div className="relative flex items-center">
        <Avatar className="size-5">
          <AvatarImage alt={userInfo?.name} src={userInfo?.avatarUrl} />
          <AvatarFallback>{userInfo?.name?.[0]}</AvatarFallback>
        </Avatar>
        <h4 className="mx-2 text-sm leading-none font-semibold">
          {/* Replace to your own backend or refer to potion */}
          {userInfo?.name}
        </h4>

        <div className="text-xs leading-none text-muted-foreground/80">
          <span className="mr-1">{relativeDate}</span>
          {comment.isEdited && <span>(edited)</span>}
        </div>

        {isMyComment && (hovering || dropdownOpen) && (
          <div className="absolute top-0 right-0 flex space-x-1">
            {index === 0 && (
              <Button
                variant="ghost"
                className="h-6 p-1 text-muted-foreground"
                onClick={onResolveComment}
                type="button"
              >
                <CheckIcon className="size-4" />
              </Button>
            )}

            <CommentMoreDropdown
              onCloseAutoFocus={() => {
                setTimeout(() => {
                  commentEditor.tf.focus({ edge: "endEditor" });
                }, 0);
              }}
              onRemoveComment={() => {
                if (discussionLength === 1) {
                  tf.comment.unsetMark({ id: comment.discussionId });
                  void removeDiscussion(comment.discussionId);
                }
              }}
              comment={comment}
              dropdownOpen={dropdownOpen}
              setDropdownOpen={setDropdownOpen}
              setEditingId={setEditingId}
            />
          </div>
        )}
      </div>

      {isFirst && showDocumentContent && (
        <div className="text-subtle-foreground relative mt-1 flex pl-[32px] text-sm">
          {discussionLength > 1 && (
            <div className="absolute top-[5px] left-3 h-full w-0.5 shrink-0 bg-muted" />
          )}
          <div className="my-px w-0.5 shrink-0 bg-highlight" />
          {documentContent && <div className="ml-2">{documentContent}</div>}
        </div>
      )}

      <div className="relative my-1 pl-[26px]">
        {!isLast && (
          <div className="absolute top-0 left-3 h-full w-0.5 shrink-0 bg-muted" />
        )}
        <Plate readOnly={!isEditing} editor={commentEditor}>
          <EditorContainer variant="comment">
            <Editor
              variant="comment"
              className="w-auto grow"
              onClick={() => onEditorClick?.()}
            />

            {isEditing && (
              <div className="ml-auto flex shrink-0 gap-1">
                <Button
                  size="icon"
                  variant="ghost"
                  className="size-[28px]"
                  onClick={(e: React.MouseEvent<HTMLButtonElement>) => {
                    e.stopPropagation();
                    void onCancel();
                  }}
                >
                  <div className="flex size-5 shrink-0 items-center justify-center rounded-[50%] bg-primary/40">
                    <XIcon className="size-3 stroke-[3px] text-background" />
                  </div>
                </Button>

                <Button
                  size="icon"
                  variant="ghost"
                  onClick={(e: React.MouseEvent<HTMLButtonElement>) => {
                    e.stopPropagation();
                    void onSave();
                  }}
                >
                  <div className="flex size-5 shrink-0 items-center justify-center rounded-[50%] bg-brand">
                    <CheckIcon className="size-3 stroke-[3px] text-background" />
                  </div>
                </Button>
              </div>
            )}
          </EditorContainer>
        </Plate>
      </div>
    </div>
  );
}
interface CommentMoreDropdownProps {
  comment: TComment;
  dropdownOpen: boolean;
  setDropdownOpen: React.Dispatch<React.SetStateAction<boolean>>;
  setEditingId: React.Dispatch<React.SetStateAction<string | null>>;
  onCloseAutoFocus?: () => void;
  onRemoveComment?: () => void;
}

export function CommentMoreDropdown(props: CommentMoreDropdownProps) {
  const {
    comment,
    dropdownOpen,
    setDropdownOpen,
    setEditingId,
    onCloseAutoFocus,
    onRemoveComment,
  } = props;

  const editor = useEditorRef();

  const selectedEditCommentRef = React.useRef<boolean>(false);

  const onDeleteComment = React.useCallback(() => {
    if (!comment.id)
      return alert("You are operating too quickly, please try again later.");

    // Find and update the discussion
    const updatedDiscussions = editor
      .getOption(discussionPlugin, "discussions")
      .map((discussion) => {
        if (discussion.id !== comment.discussionId) {
          return discussion;
        }

        const commentIndex = discussion.comments.findIndex(
          (c) => c.id === comment.id,
        );
        if (commentIndex === -1) {
          return discussion;
        }

        return {
          ...discussion,
          comments: [
            ...discussion.comments.slice(0, commentIndex),
            ...discussion.comments.slice(commentIndex + 1),
          ],
        };
      });

    // Save back to session storage
    editor.setOption(discussionPlugin, "discussions", updatedDiscussions);
    onRemoveComment?.();
  }, [comment.discussionId, comment.id, editor, onRemoveComment]);

  const onEditComment = React.useCallback(() => {
    selectedEditCommentRef.current = true;

    if (!comment.id)
      return alert("You are operating too quickly, please try again later.");

    setEditingId(comment.id);
  }, [comment.id, setEditingId]);

  return (
    <DropdownMenu
      open={dropdownOpen}
      onOpenChange={setDropdownOpen}
      modal={false}
    >
      <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>
        <Button variant="ghost" className={cn("h-6 p-1 text-muted-foreground")}>
          <MoreHorizontalIcon className="size-4" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent
        className="w-48"
        onCloseAutoFocus={(e) => {
          if (selectedEditCommentRef.current) {
            onCloseAutoFocus?.();
            selectedEditCommentRef.current = false;
          }

          return e.preventDefault();
        }}
      >
        <DropdownMenuGroup>
          <DropdownMenuItem onClick={onEditComment}>
            <PencilIcon className="size-4" />
            Edit comment
          </DropdownMenuItem>
          <DropdownMenuItem onClick={onDeleteComment}>
            <TrashIcon className="size-4" />
            Delete comment
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

// ========== FILE END: ui/elements/comments-suggestions/comment.tsx ==========



// ========== FILE START: ui/elements/comments-suggestions/suggestion-line-break.tsx ==========
"use client";

import * as React from "react";

import type { TSuggestionData } from "@udecode/plate-suggestion";

import { type RenderNodeWrapper, usePluginOption } from "@udecode/plate/react";
import { CornerDownLeftIcon } from "lucide-react";

import { cn } from "@/lib/utils";
import {
  type SuggestionConfig,
  suggestionPlugin,
} from "../../../plugins/suggestion-plugin";

export const SuggestionBelowNodes: RenderNodeWrapper<SuggestionConfig> = ({
  api,
  element,
}) => {
  if (!api.suggestion.isBlockSuggestion(element)) return;

  const suggestionData = element.suggestion;

  if (!suggestionData?.isLineBreak) return;

  return function Component({ children }) {
    return (
      <React.Fragment>
        {children}
        <SuggestionLineBreak suggestionData={suggestionData} />
      </React.Fragment>
    );
  };
};

function SuggestionLineBreak({
  suggestionData,
}: {
  suggestionData: TSuggestionData;
}) {
  const { type } = suggestionData;
  const isRemove = type === "remove";
  const isInsert = type === "insert";

  const activeSuggestionId = usePluginOption(suggestionPlugin, "activeId");
  const hoverSuggestionId = usePluginOption(suggestionPlugin, "hoverId");

  const isActive = activeSuggestionId === suggestionData.id;
  const isHover = hoverSuggestionId === suggestionData.id;

  const spanRef = React.useRef<HTMLSpanElement>(null);

  return (
    <span
      ref={spanRef}
      className={cn(
        "absolute border-b-2 border-b-brand/[.24] bg-brand/[.08] text-justify text-brand/80 no-underline transition-colors duration-200",
        isInsert &&
          (isActive || isHover) &&
          "border-b-brand/[.60] bg-brand/[.13]",
        isRemove &&
          "border-b-gray-300 bg-gray-300/25 text-gray-400 line-through",
        isRemove &&
          (isActive || isHover) &&
          "border-b-gray-500 bg-gray-400/25 text-gray-500 no-underline",
      )}
      style={{
        bottom: 4.5,
        height: 21,
      }}
      contentEditable={false}
    >
      <CornerDownLeftIcon className="mt-0.5 size-4" />
    </span>
  );
}

// ========== FILE END: ui/elements/comments-suggestions/suggestion-line-break.tsx ==========



// ========== FILE START: ui/elements/date/date-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps } from "@udecode/plate";
import type { TDateElement } from "@udecode/plate-date";

import { SlateElement } from "@udecode/plate";

export function DateElementStatic(props: SlateElementProps<TDateElement>) {
  const { element } = props;

  return (
    <SlateElement className="inline-block" {...props}>
      <span className="w-fit rounded-sm bg-muted px-1 text-muted-foreground">
        {element.date ? (
          (() => {
            const today = new Date();
            const elementDate = new Date(element.date);
            const isToday =
              elementDate.getDate() === today.getDate() &&
              elementDate.getMonth() === today.getMonth() &&
              elementDate.getFullYear() === today.getFullYear();

            const isYesterday =
              new Date(today.setDate(today.getDate() - 1)).toDateString() ===
              elementDate.toDateString();
            const isTomorrow =
              new Date(today.setDate(today.getDate() + 2)).toDateString() ===
              elementDate.toDateString();

            if (isToday) return "Today";
            if (isYesterday) return "Yesterday";
            if (isTomorrow) return "Tomorrow";

            return elementDate.toLocaleDateString(undefined, {
              day: "numeric",
              month: "long",
              year: "numeric",
            });
          })()
        ) : (
          <span>Pick a date</span>
        )}
      </span>
      {props.children}
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/date/date-element-static.tsx ==========



// ========== FILE START: ui/elements/date/date-element.tsx ==========
"use client";

import type { TDateElement } from "@udecode/plate-date";
import type { PlateElementProps } from "@udecode/plate/react";

import { PlateElement, useReadOnly } from "@udecode/plate/react";

import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";

export function DateElement(props: PlateElementProps<TDateElement>) {
  const { editor, element } = props;

  const readOnly = useReadOnly();

  const trigger = (
    <span
      className={cn(
        "w-fit cursor-pointer rounded-sm bg-muted px-1 text-muted-foreground",
      )}
      contentEditable={false}
      draggable
    >
      {element.date ? (
        (() => {
          const today = new Date();
          const elementDate = new Date(element.date);
          const isToday =
            elementDate.getDate() === today.getDate() &&
            elementDate.getMonth() === today.getMonth() &&
            elementDate.getFullYear() === today.getFullYear();

          const isYesterday =
            new Date(today.setDate(today.getDate() - 1)).toDateString() ===
            elementDate.toDateString();
          const isTomorrow =
            new Date(today.setDate(today.getDate() + 2)).toDateString() ===
            elementDate.toDateString();

          if (isToday) return "Today";
          if (isYesterday) return "Yesterday";
          if (isTomorrow) return "Tomorrow";

          return elementDate.toLocaleDateString(undefined, {
            day: "numeric",
            month: "long",
            year: "numeric",
          });
        })()
      ) : (
        <span>Pick a date</span>
      )}
    </span>
  );

  if (readOnly) {
    return trigger;
  }

  return (
    <PlateElement
      {...props}
      className="inline-block"
      attributes={{
        ...props.attributes,
        contentEditable: false,
      }}
    >
      <Popover>
        <PopoverTrigger asChild>{trigger}</PopoverTrigger>
        <PopoverContent className="w-auto p-0">
          <Calendar
            selected={new Date(element.date as string)}
            onSelect={(date) => {
              if (!date) return;

              editor.tf.setNodes(
                { date: date.toDateString() },
                { at: element },
              );
            }}
            mode="single"
            initialFocus
          />
        </PopoverContent>
      </Popover>
      {props.children}
    </PlateElement>
  );
}

// ========== FILE END: ui/elements/date/date-element.tsx ==========



// ========== FILE START: ui/elements/equation/equation-element-static.tsx ==========
import * as React from "react";

import { type SlateElementProps, SlateElement } from "@udecode/plate";
import { type TEquationElement, getEquationHtml } from "@udecode/plate-math";
import { RadicalIcon } from "lucide-react";

import { cn } from "@/lib/utils";

export function EquationElementStatic(
  props: SlateElementProps<TEquationElement>,
) {
  const { element } = props;

  const html = getEquationHtml({
    element,
    options: {
      displayMode: true,
      errorColor: "#cc0000",
      fleqn: false,
      leqno: false,
      macros: { "\\f": "#1f(#2)" },
      output: "htmlAndMathml",
      strict: "warn",
      throwOnError: false,
      trust: false,
    },
  });

  return (
    <SlateElement className="my-1" {...props}>
      <div
        className={cn(
          "group flex items-center justify-center rounded-sm select-none hover:bg-primary/10 data-[selected=true]:bg-primary/10",
          element.texExpression.length === 0
            ? "bg-muted p-3 pr-9"
            : "px-2 py-1",
        )}
      >
        {element.texExpression.length > 0 ? (
          <span
            dangerouslySetInnerHTML={{
              __html: html,
            }}
          />
        ) : (
          <div className="flex h-7 w-full items-center gap-2 text-sm whitespace-nowrap text-muted-foreground">
            <RadicalIcon className="size-6 text-muted-foreground/80" />
            <div>Add a Tex equation</div>
          </div>
        )}
      </div>
      {props.children}
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/equation/equation-element-static.tsx ==========



// ========== FILE START: ui/elements/equation/equation-element.tsx ==========
"use client";

import * as React from "react";

import type { TEquationElement } from "@udecode/plate-math";
import type { PlateElementProps } from "@udecode/plate/react";

import { useEquationElement } from "@udecode/plate-math/react";
import { PlateElement, useSelected } from "@udecode/plate/react";
import { RadicalIcon } from "lucide-react";

import { Popover, PopoverTrigger } from "@/components/ui/popover";
import { cn } from "@/lib/utils";

import { EquationPopoverContent } from "./equation-popover";

export function EquationElement(props: PlateElementProps<TEquationElement>) {
  const selected = useSelected();
  const [open, setOpen] = React.useState(selected);
  const katexRef = React.useRef<HTMLDivElement | null>(null);

  useEquationElement({
    element: props.element,
    katexRef: katexRef,
    options: {
      displayMode: true,
      errorColor: "#cc0000",
      fleqn: false,
      leqno: false,
      macros: { "\\f": "#1f(#2)" },
      output: "htmlAndMathml",
      strict: "warn",
      throwOnError: false,
      trust: false,
    },
  });

  return (
    <PlateElement className="my-1" {...props}>
      <Popover open={open} onOpenChange={setOpen} modal={false}>
        <PopoverTrigger asChild>
          <div
            className={cn(
              "group flex cursor-pointer items-center justify-center rounded-sm select-none hover:bg-primary/10 data-[selected=true]:bg-primary/10",
              props.element.texExpression.length === 0
                ? "bg-muted p-3 pr-9"
                : "px-2 py-1",
            )}
            data-selected={selected}
            contentEditable={false}
            role="button"
          >
            {props.element.texExpression.length > 0 ? (
              <span ref={katexRef} />
            ) : (
              <div className="flex h-7 w-full items-center gap-2 text-sm whitespace-nowrap text-muted-foreground">
                <RadicalIcon className="size-6 text-muted-foreground/80" />
                <div>Add a Tex equation</div>
              </div>
            )}
          </div>
        </PopoverTrigger>

        <EquationPopoverContent
          open={open}
          placeholder={`f(x) = \\begin{cases}\n  x^2, &\\quad x > 0 \\\\\n  0, &\\quad x = 0 \\\\\n  -x^2, &\\quad x < 0\n\\end{cases}`}
          isInline={false}
          setOpen={setOpen}
        />
      </Popover>

      {props.children}
    </PlateElement>
  );
}

// ========== FILE END: ui/elements/equation/equation-element.tsx ==========



// ========== FILE START: ui/elements/equation/equation-popover.tsx ==========
"use client";

import * as React from "react";
import TextareaAutosize, {
  type TextareaAutosizeProps,
} from "react-textarea-autosize";

import type { TEquationElement } from "@udecode/plate-math";

import { useEquationInput } from "@udecode/plate-math/react";
import { BlockSelectionPlugin } from "@udecode/plate-selection/react";
import {
  createPrimitiveComponent,
  useEditorRef,
  useElement,
  useReadOnly,
} from "@udecode/plate/react";
import { CornerDownLeftIcon } from "lucide-react";

import { Button } from "@/components/ui/button";
import { PopoverContent } from "@/components/ui/popover";
import { cn } from "@/lib/utils";

const EquationInput = createPrimitiveComponent(TextareaAutosize)({
  propsHook: useEquationInput,
});

const EquationPopoverContent = ({
  className,
  isInline,
  open,
  setOpen,
  ...props
}: {
  isInline: boolean;
  open: boolean;
  setOpen: (open: boolean) => void;
} & TextareaAutosizeProps) => {
  const editor = useEditorRef();
  const readOnly = useReadOnly();
  const element = useElement<TEquationElement>();

  React.useEffect(() => {
    if (isInline && open) {
      setOpen(true);
    }
  }, [isInline, open, setOpen]);

  if (readOnly) return null;

  const onClose = () => {
    setOpen(false);

    if (isInline) {
      editor.tf.select(element, { next: true });
    } else {
      editor
        .getApi(BlockSelectionPlugin)
        .blockSelection.set(element.id as string);
    }
  };

  return (
    <PopoverContent
      className="flex gap-2"
      onEscapeKeyDown={(e) => {
        e.preventDefault();
      }}
      contentEditable={false}
    >
      <EquationInput
        className={cn("max-h-[50vh] grow resize-none p-2 text-sm", className)}
        state={{ isInline, open, onClose }}
        autoFocus
        {...props}
      />

      <Button variant="secondary" className="px-3" onClick={onClose}>
        Done <CornerDownLeftIcon className="size-3.5" />
      </Button>
    </PopoverContent>
  );
};

export { EquationPopoverContent };

// ========== FILE END: ui/elements/equation/equation-popover.tsx ==========



// ========== FILE START: ui/elements/equation/inline-equation-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps } from "@udecode/plate";
import type { TEquationElement } from "@udecode/plate-math";

import { SlateElement } from "@udecode/plate";
import { getEquationHtml } from "@udecode/plate-math";

import { cn } from "@/lib/utils";

export function InlineEquationElementStatic(
  props: SlateElementProps<TEquationElement>,
) {
  const html = getEquationHtml({
    element: props.element,
    options: {
      displayMode: true,
      errorColor: "#cc0000",
      fleqn: false,
      leqno: false,
      macros: { "\\f": "#1f(#2)" },
      output: "htmlAndMathml",
      strict: "warn",
      throwOnError: false,
      trust: false,
    },
  });

  return (
    <SlateElement
      {...props}
      className="inline-block rounded-sm select-none [&_.katex-display]:my-0"
    >
      <div
        className={cn(
          'after:absolute after:inset-0 after:-top-0.5 after:-left-1 after:z-1 after:h-[calc(100%)+4px] after:w-[calc(100%+8px)] after:rounded-sm after:content-[""]',
          "h-6",
          props.element.texExpression.length === 0 &&
            "text-muted-foreground after:bg-neutral-500/10",
        )}
      >
        <span
          className={cn(
            props.element.texExpression.length === 0 && "hidden",
            "font-mono leading-none",
          )}
          dangerouslySetInnerHTML={{ __html: html }}
        />
      </div>
      {props.children}
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/equation/inline-equation-element-static.tsx ==========



// ========== FILE START: ui/elements/equation/inline-equation-element.tsx ==========
"use client";

import * as React from "react";

import type { TEquationElement } from "@udecode/plate-math";
import type { PlateElementProps } from "@udecode/plate/react";

import { useEquationElement } from "@udecode/plate-math/react";
import {
  PlateElement,
  useEditorSelector,
  useSelected,
} from "@udecode/plate/react";
import { RadicalIcon } from "lucide-react";

import { Popover, PopoverTrigger } from "@/components/ui/popover";
import { cn } from "@/lib/utils";

import { EquationPopoverContent } from "./equation-popover";

export function InlineEquationElement(
  props: PlateElementProps<TEquationElement>,
) {
  const element = props.element;
  const katexRef = React.useRef<HTMLDivElement | null>(null);
  const selected = useSelected();
  const isCollapsed = useEditorSelector(
    (editor) => editor.api.isCollapsed(),
    [],
  );
  const [open, setOpen] = React.useState(selected && isCollapsed);

  useEquationElement({
    element,
    katexRef: katexRef,
    options: {
      displayMode: true,
      errorColor: "#cc0000",
      fleqn: false,
      leqno: false,
      macros: { "\\f": "#1f(#2)" },
      output: "htmlAndMathml",
      strict: "warn",
      throwOnError: false,
      trust: false,
    },
  });

  return (
    <PlateElement
      {...props}
      className={cn(
        "inline-block rounded-sm select-none [&_.katex-display]:my-0",
      )}
    >
      <Popover open={open} onOpenChange={setOpen} modal={false}>
        <PopoverTrigger asChild>
          <div
            className={cn(
              'after:absolute after:inset-0 after:-top-0.5 after:-left-1 after:z-1 after:h-[calc(100%)+4px] after:w-[calc(100%+8px)] after:rounded-sm after:content-[""]',
              "h-6",
              element.texExpression.length > 0 && open && "after:bg-brand/15",
              element.texExpression.length === 0 &&
                "text-muted-foreground after:bg-neutral-500/10",
            )}
            contentEditable={false}
          >
            <span
              ref={katexRef}
              className={cn(
                element.texExpression.length === 0 && "hidden",
                "font-mono leading-none",
              )}
            />
            {element.texExpression.length === 0 && (
              <span>
                <RadicalIcon className="mr-1 inline-block h-[19px] w-4 py-[1.5px] align-text-bottom" />
                New equation
              </span>
            )}
          </div>
        </PopoverTrigger>

        <EquationPopoverContent
          className="my-auto"
          open={open}
          placeholder="E = mc^2"
          setOpen={setOpen}
          isInline
        />
      </Popover>

      {props.children}
    </PlateElement>
  );
}

// ========== FILE END: ui/elements/equation/inline-equation-element.tsx ==========



// ========== FILE START: ui/elements/excalidraw/excalidraw-element.tsx ==========
"use client";

import * as React from "react";

import type { TExcalidrawElement } from "@udecode/plate-excalidraw";
import type { PlateElementProps } from "@udecode/plate/react";

import { useExcalidrawElement } from "@udecode/plate-excalidraw/react";
import { PlateElement } from "@udecode/plate/react";

export function ExcalidrawElement(
  props: PlateElementProps<TExcalidrawElement>,
) {
  const { children, element } = props;

  const { Excalidraw, excalidrawProps } = useExcalidrawElement({
    element,
  });

  return (
    <PlateElement {...props}>
      <div contentEditable={false}>
        <div className="mx-auto aspect-video h-[600px] w-[min(100%,600px)] overflow-hidden rounded-sm border">
          {Excalidraw && <Excalidraw {...(excalidrawProps as any)} />}
        </div>
      </div>
      {children}
    </PlateElement>
  );
}

// ========== FILE END: ui/elements/excalidraw/excalidraw-element.tsx ==========



// ========== FILE START: ui/elements/heading/heading-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps } from "@udecode/plate";

import { SlateElement } from "@udecode/plate";
import { type VariantProps, cva } from "class-variance-authority";

const headingVariants = cva("relative mb-1", {
  variants: {
    variant: {
      h1: "mt-[1.6em] pb-1 font-heading text-4xl font-bold",
      h2: "mt-[1.4em] pb-px font-heading text-2xl font-semibold tracking-tight",
      h3: "mt-[1em] pb-px font-heading text-xl font-semibold tracking-tight",
      h4: "mt-[0.75em] font-heading text-lg font-semibold tracking-tight",
      h5: "mt-[0.75em] text-lg font-semibold tracking-tight",
      h6: "mt-[0.75em] text-base font-semibold tracking-tight",
    },
  },
});

export function HeadingElementStatic({
  variant = "h1",
  ...props
}: SlateElementProps & VariantProps<typeof headingVariants>) {
  return (
    <SlateElement
      as={variant!}
      className={headingVariants({ variant })}
      {...props}
    >
      {props.children}
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/heading/heading-element-static.tsx ==========



// ========== FILE START: ui/elements/heading/heading-element.tsx ==========
"use client";

import * as React from "react";

import type { PlateElementProps } from "@udecode/plate/react";

import { PlateElement } from "@udecode/plate/react";
import { type VariantProps, cva } from "class-variance-authority";

const headingVariants = cva("relative mb-1", {
  variants: {
    variant: {
      h1: "mt-[1.6em] pb-1 font-heading text-4xl font-bold",
      h2: "mt-[1.4em] pb-px font-heading text-2xl font-semibold tracking-tight",
      h3: "mt-[1em] pb-px font-heading text-xl font-semibold tracking-tight",
      h4: "mt-[0.75em] font-heading text-lg font-semibold tracking-tight",
      h5: "mt-[0.75em] text-lg font-semibold tracking-tight",
      h6: "mt-[0.75em] text-base font-semibold tracking-tight",
    },
  },
});

export function HeadingElement({
  variant = "h1",
  ...props
}: PlateElementProps & VariantProps<typeof headingVariants>) {
  return (
    <PlateElement
      as={variant!}
      className={headingVariants({ variant })}
      {...props}
    >
      {props.children}
    </PlateElement>
  );
}

// ========== FILE END: ui/elements/heading/heading-element.tsx ==========



// ========== FILE START: ui/elements/heading/hr-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps } from "@udecode/plate";

import { SlateElement } from "@udecode/plate";

import { cn } from "@/lib/utils";

export function HrElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div className="cursor-text py-6" contentEditable={false}>
        <hr
          className={cn(
            "h-0.5 rounded-sm border-none bg-muted bg-clip-content",
          )}
        />
      </div>
      {props.children}
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/heading/hr-element-static.tsx ==========



// ========== FILE START: ui/elements/heading/hr-element.tsx ==========
"use client";

import * as React from "react";

import type { PlateElementProps } from "@udecode/plate/react";

import {
  PlateElement,
  useFocused,
  useReadOnly,
  useSelected,
} from "@udecode/plate/react";

import { cn } from "@/lib/utils";

export function HrElement(props: PlateElementProps) {
  const readOnly = useReadOnly();
  const selected = useSelected();
  const focused = useFocused();

  return (
    <PlateElement {...props}>
      <div className="py-6" contentEditable={false}>
        <hr
          className={cn(
            "h-0.5 rounded-sm border-none bg-muted bg-clip-content",
            selected && focused && "ring-2 ring-ring ring-offset-2",
            !readOnly && "cursor-pointer",
          )}
        />
      </div>
      {props.children}
    </PlateElement>
  );
}

// ========== FILE END: ui/elements/heading/hr-element.tsx ==========



// ========== FILE START: ui/elements/image/image-element-static.tsx ==========
import * as React from "react";
import Image from "next/image";

import type { SlateElementProps } from "@udecode/plate";
import type { TCaptionElement } from "@udecode/plate-caption";
import type { TImageElement } from "@udecode/plate-media";

import { NodeApi, SlateElement } from "@udecode/plate";

import { cn } from "@/lib/utils";

export function ImageElementStatic(
  props: SlateElementProps<TImageElement & TCaptionElement & { width: number }>,
) {
  const { align = "center", caption, url, width } = props.element;

  return (
    <SlateElement {...props} className="py-2.5">
      <figure className="group relative m-0 inline-block" style={{ width }}>
        <div
          className="relative max-w-full min-w-[92px]"
          style={{ textAlign: align }}
        >
          <Image
            className={cn(
              "w-full max-w-full cursor-default object-cover px-0",
              "rounded-sm",
            )}
            alt={(props.attributes as any).alt || ""}
            src={url}
            width={width}
            height={0}
            style={{ height: "auto" }}
          />
          {caption && (
            <figcaption className="mx-auto mt-2 h-[24px] max-w-full">
              {NodeApi.string(caption[0])}
            </figcaption>
          )}
        </div>
      </figure>
      {props.children}
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/image/image-element-static.tsx ==========



// ========== FILE START: ui/elements/image/image-element.tsx ==========
"use client";

import * as React from "react";

import type { TImageElement } from "@udecode/plate-media";
import type { PlateElementProps } from "@udecode/plate/react";

import { useDraggable } from "@udecode/plate-dnd";
import { Image, ImagePlugin, useMediaState } from "@udecode/plate-media/react";
import { ResizableProvider, useResizableValue } from "@udecode/plate-resizable";
import { PlateElement, withHOC } from "@udecode/plate/react";

import { cn } from "@/lib/utils";

import { Caption, CaptionTextarea } from "../../primitives/caption";
import { MediaPopover } from "../media/media-popover";
import {
  mediaResizeHandleVariants,
  Resizable,
  ResizeHandle,
} from "../../primitives/resize-handle";

export const ImageElement = withHOC(
  ResizableProvider,
  function ImageElement(props: PlateElementProps<TImageElement>) {
    const { align = "center", focused, readOnly, selected } = useMediaState();
    const width = useResizableValue("width");

    const { isDragging, handleRef } = useDraggable({
      element: props.element,
    });

    return (
      <MediaPopover plugin={ImagePlugin}>
        <PlateElement {...props} className="py-2.5">
          <figure className="group relative m-0" contentEditable={false}>
            <Resizable
              align={align}
              options={{
                align,
                readOnly,
              }}
            >
              <ResizeHandle
                className={mediaResizeHandleVariants({ direction: "left" })}
                options={{ direction: "left" }}
              />
              <Image
                ref={handleRef}
                className={cn(
                  "block w-full max-w-full cursor-pointer object-cover px-0",
                  "rounded-sm",
                  focused && selected && "ring-2 ring-ring ring-offset-2",
                  isDragging && "opacity-50",
                )}
                alt={(props.attributes as any).alt}
              />
              <ResizeHandle
                className={mediaResizeHandleVariants({
                  direction: "right",
                })}
                options={{ direction: "right" }}
              />
            </Resizable>

            <Caption style={{ width }} align={align}>
              <CaptionTextarea
                readOnly={readOnly}
                onFocus={(e) => {
                  e.preventDefault();
                }}
                placeholder="Write a caption..."
              />
            </Caption>
          </figure>

          {props.children}
        </PlateElement>
      </MediaPopover>
    );
  },
);

// ========== FILE END: ui/elements/image/image-element.tsx ==========



// ========== FILE START: ui/elements/indentation/indent-fire-marker.tsx ==========
import * as React from "react";

import type { SlateRenderElementProps } from "@udecode/plate";
import type { TIndentElement } from "@udecode/plate-indent";

export const FireMarker = (
  props: Omit<SlateRenderElementProps, "children">,
) => {
  const { element } = props;

  return (
    <div contentEditable={false}>
      <span
        className="select-none"
        style={{ left: -26, position: "absolute", top: -1 }}
        data-plate-prevent-deserialization
        contentEditable={false}
      >
        {(element as TIndentElement).indent % 2 === 0 ? "" : ""}
      </span>
    </div>
  );
};

export const FireLiComponent = (props: SlateRenderElementProps) => {
  const { children } = props;

  return <li className="list-none">{children}</li>;
};

// ========== FILE END: ui/elements/indentation/indent-fire-marker.tsx ==========



// ========== FILE START: ui/elements/indentation/indent-todo-marker-static.tsx ==========
import * as React from "react";

import type { SlateRenderElementProps } from "@udecode/plate";

import { CheckIcon } from "lucide-react";

import { cn } from "@/lib/utils";

export function TodoMarkerStatic(
  props: Omit<SlateRenderElementProps, "children">,
) {
  return (
    <div contentEditable={false}>
      <CheckboxStatic
        className="pointer-events-none absolute top-1 -left-6"
        checked={props.element.checked as boolean}
      />
    </div>
  );
}

export function TodoLiStatic(props: SlateRenderElementProps) {
  return (
    <li
      className={cn(
        "list-none",
        (props.element.checked as boolean) &&
          "text-muted-foreground line-through",
      )}
    >
      {props.children}
    </li>
  );
}

type CheckboxStaticProps = {
  checked: boolean;
  className?: string;
  style?: React.CSSProperties;
};

function CheckboxStatic(props: CheckboxStaticProps) {
  return (
    <button
      className={cn(
        "peer size-4 shrink-0 rounded-sm border border-primary bg-background ring-offset-background focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
        props.className,
      )}
      style={props.style}
      data-state={props.checked ? "checked" : "unchecked"}
      type="button"
    >
      <div className={cn("flex items-center justify-center text-current")}>
        {props.checked && <CheckIcon className="size-4" />}
      </div>
    </button>
  );
}

// ========== FILE END: ui/elements/indentation/indent-todo-marker-static.tsx ==========



// ========== FILE START: ui/elements/indentation/indent-todo-marker.tsx ==========
"use client";

import * as React from "react";

import type { SlateRenderElementProps } from "@udecode/plate";

import {
  useIndentTodoListElement,
  useIndentTodoListElementState,
} from "@udecode/plate-indent-list/react";
import { useReadOnly } from "@udecode/plate/react";

import { Checkbox } from "@/components/ui/checkbox";
import { cn } from "@/lib/utils";

export function TodoMarker(props: Omit<SlateRenderElementProps, "children">) {
  const state = useIndentTodoListElementState({ element: props.element });
  const { checkboxProps } = useIndentTodoListElement(state);
  const readOnly = useReadOnly();

  return (
    <div contentEditable={false}>
      <Checkbox
        className={cn(
          "absolute top-1 -left-6",
          readOnly && "pointer-events-none",
        )}
        {...checkboxProps}
      />
    </div>
  );
}

export function TodoLi(props: SlateRenderElementProps) {
  return (
    <li
      className={cn(
        "list-none",
        (props.element.checked as boolean) &&
          "text-muted-foreground line-through",
      )}
    >
      {props.children}
    </li>
  );
}

// ========== FILE END: ui/elements/indentation/indent-todo-marker.tsx ==========



// ========== FILE START: ui/elements/layout/column-element-static.tsx ==========
import * as React from "react";

import type { TColumnElement } from "@udecode/plate-layout";

import { type SlateElementProps, SlateElement } from "@udecode/plate";

export function ColumnElementStatic(props: SlateElementProps<TColumnElement>) {
  const { width } = props.element;

  return (
    <div className="group/column relative" style={{ width: width ?? "100%" }}>
      <SlateElement
        className="h-full px-2 pt-2 group-first/column:pl-0 group-last/column:pr-0"
        {...props}
      >
        <div className="relative h-full border border-transparent p-1.5">
          {props.children}
        </div>
      </SlateElement>
    </div>
  );
}

// ========== FILE END: ui/elements/layout/column-element-static.tsx ==========



// ========== FILE START: ui/elements/layout/column-element.tsx ==========
"use client";

import * as React from "react";

import type { TColumnElement } from "@udecode/plate-layout";
import type { PlateElementProps } from "@udecode/plate/react";

import { useComposedRef } from "@udecode/cn";
import { PathApi } from "@udecode/plate";
import { useDraggable, useDropLine } from "@udecode/plate-dnd";
import { ResizableProvider } from "@udecode/plate-resizable";
import { BlockSelectionPlugin } from "@udecode/plate-selection/react";
import {
  PlateElement,
  usePluginOption,
  useReadOnly,
  withHOC,
} from "@udecode/plate/react";
import { GripHorizontal } from "lucide-react";

import { Button } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";

export const ColumnElement = withHOC(
  ResizableProvider,
  function ColumnElement(props: PlateElementProps<TColumnElement>) {
    const { width } = props.element;
    const readOnly = useReadOnly();
    const isSelectionAreaVisible = usePluginOption(
      BlockSelectionPlugin,
      "isSelectionAreaVisible",
    );

    const { isDragging, previewRef, handleRef } = useDraggable({
      element: props.element,
      orientation: "horizontal",
      type: "column",
      canDropNode: ({ dragEntry, dropEntry }) =>
        PathApi.equals(
          PathApi.parent(dragEntry[1]),
          PathApi.parent(dropEntry[1]),
        ),
    });

    return (
      <div className="group/column relative" style={{ width: width ?? "100%" }}>
        {!readOnly && !isSelectionAreaVisible && (
          <div
            ref={handleRef}
            className={cn(
              "absolute top-2 left-1/2 z-50 -translate-x-1/2 -translate-y-1/2",
              "pointer-events-auto flex items-center",
              "opacity-0 transition-opacity group-hover/column:opacity-100",
            )}
          >
            <ColumnDragHandle />
          </div>
        )}

        <PlateElement
          {...props}
          ref={useComposedRef(props.ref, previewRef)}
          className="h-full px-2 pt-2 group-first/column:pl-0 group-last/column:pr-0"
        >
          <div
            className={cn(
              "relative h-full border border-transparent p-1.5",
              !readOnly && "rounded-lg border-dashed border-border",
              isDragging && "opacity-50",
            )}
          >
            {props.children}

            {!readOnly && !isSelectionAreaVisible && <DropLine />}
          </div>
        </PlateElement>
      </div>
    );
  },
);

const ColumnDragHandle = React.memo(function ColumnDragHandle() {
  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button variant="ghost" className="h-5 !px-1">
            <GripHorizontal
              className="text-muted-foreground"
              onClick={(event) => {
                event.stopPropagation();
                event.preventDefault();
              }}
            />
          </Button>
        </TooltipTrigger>

        <TooltipContent>Drag to move column</TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
});

function DropLine() {
  const { dropLine } = useDropLine({ orientation: "horizontal" });

  if (!dropLine) return null;

  return (
    <div
      className={cn(
        "slate-dropLine",
        "absolute bg-brand/50",
        dropLine === "left" &&
          "inset-y-0 left-[-10.5px] w-1 group-first/column:-left-1",
        dropLine === "right" &&
          "inset-y-0 right-[-11px] w-1 group-last/column:-right-1",
      )}
    />
  );
}

// ========== FILE END: ui/elements/layout/column-element.tsx ==========



// ========== FILE START: ui/elements/layout/column-group-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps } from "@udecode/plate";

import { SlateElement } from "@udecode/plate";

export function ColumnGroupElementStatic(props: SlateElementProps) {
  return (
    <SlateElement className="mb-2" {...props}>
      <div className="flex size-full rounded">{props.children}</div>
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/layout/column-group-element-static.tsx ==========



// ========== FILE START: ui/elements/layout/column-group-element.tsx ==========
"use client";

import * as React from "react";

import type { TColumnElement } from "@udecode/plate-layout";
import type { PlateElementProps } from "@udecode/plate/react";

import { setColumns } from "@udecode/plate-layout";
import { useDebouncePopoverOpen } from "@udecode/plate-layout/react";
import {
  PlateElement,
  useEditorRef,
  useElement,
  useReadOnly,
  useRemoveNodeButton,
} from "@udecode/plate/react";
import { type LucideProps, Trash2Icon } from "lucide-react";

import { Button } from "@/components/ui/button";
import {
  Popover,
  PopoverAnchor,
  PopoverContent,
} from "@/components/ui/popover";
import { Separator } from "@/components/ui/separator";

export function ColumnGroupElement(props: PlateElementProps) {
  return (
    <PlateElement className="mb-2" {...props}>
      <ColumnFloatingToolbar>
        <div className="flex size-full rounded">{props.children}</div>
      </ColumnFloatingToolbar>
    </PlateElement>
  );
}

export function ColumnFloatingToolbar({ children }: React.PropsWithChildren) {
  const editor = useEditorRef();
  const readOnly = useReadOnly();
  const element = useElement<TColumnElement>();

  const { props: buttonProps } = useRemoveNodeButton({ element });

  const isOpen = useDebouncePopoverOpen();

  const onColumnChange = (widths: string[]) => {
    setColumns(editor, {
      at: element,
      widths,
    });
  };

  if (readOnly) return <>{children}</>;

  return (
    <Popover open={isOpen} modal={false}>
      <PopoverAnchor>{children}</PopoverAnchor>
      <PopoverContent
        className="w-auto p-1"
        onOpenAutoFocus={(e) => e.preventDefault()}
        align="center"
        side="top"
        sideOffset={10}
      >
        <div className="box-content flex h-8 items-center">
          <Button
            variant="ghost"
            className="size-8"
            onClick={() => onColumnChange(["50%", "50%"])}
          >
            <DoubleColumnOutlined />
          </Button>
          <Button
            variant="ghost"
            className="size-8"
            onClick={() => onColumnChange(["33%", "33%", "33%"])}
          >
            <ThreeColumnOutlined />
          </Button>
          <Button
            variant="ghost"
            className="size-8"
            onClick={() => onColumnChange(["70%", "30%"])}
          >
            <RightSideDoubleColumnOutlined />
          </Button>
          <Button
            variant="ghost"
            className="size-8"
            onClick={() => onColumnChange(["30%", "70%"])}
          >
            <LeftSideDoubleColumnOutlined />
          </Button>
          <Button
            variant="ghost"
            className="size-8"
            onClick={() => onColumnChange(["25%", "50%", "25%"])}
          >
            <DoubleSideDoubleColumnOutlined />
          </Button>

          <Separator orientation="vertical" className="mx-1 h-6" />
          <Button variant="ghost" className="size-8" {...buttonProps}>
            <Trash2Icon />
          </Button>
        </div>
      </PopoverContent>
    </Popover>
  );
}

const DoubleColumnOutlined = (props: LucideProps) => (
  <svg
    fill="none"
    height="16"
    viewBox="0 0 16 16"
    width="16"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M8.5 3H13V13H8.5V3ZM7.5 2H8.5H13C13.5523 2 14 2.44772 14 3V13C14 13.5523 13.5523 14 13 14H8.5H7.5H3C2.44772 14 2 13.5523 2 13V3C2 2.44772 2.44772 2 3 2H7.5ZM7.5 13H3L3 3H7.5V13Z"
      fill="currentColor"
      fillRule="evenodd"
    />
  </svg>
);

const ThreeColumnOutlined = (props: LucideProps) => (
  <svg
    fill="none"
    height="16"
    viewBox="0 0 16 16"
    width="16"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M9.25 3H6.75V13H9.25V3ZM9.25 2H6.75H5.75H3C2.44772 2 2 2.44772 2 3V13C2 13.5523 2.44772 14 3 14H5.75H6.75H9.25H10.25H13C13.5523 14 14 13.5523 14 13V3C14 2.44772 13.5523 2 13 2H10.25H9.25ZM10.25 3V13H13V3H10.25ZM3 13H5.75V3H3L3 13Z"
      fill="currentColor"
      fillRule="evenodd"
    />
  </svg>
);

const RightSideDoubleColumnOutlined = (props: LucideProps) => (
  <svg
    fill="none"
    height="16"
    viewBox="0 0 16 16"
    width="16"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M11.25 3H13V13H11.25V3ZM10.25 2H11.25H13C13.5523 2 14 2.44772 14 3V13C14 13.5523 13.5523 14 13 14H11.25H10.25H3C2.44772 14 2 13.5523 2 13V3C2 2.44772 2.44772 2 3 2H10.25ZM10.25 13H3L3 3H10.25V13Z"
      fill="currentColor"
      fillRule="evenodd"
    />
  </svg>
);

const LeftSideDoubleColumnOutlined = (props: LucideProps) => (
  <svg
    fill="none"
    height="16"
    viewBox="0 0 16 16"
    width="16"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M5.75 3H13V13H5.75V3ZM4.75 2H5.75H13C13.5523 2 14 2.44772 14 3V13C14 13.5523 13.5523 14 13 14H5.75H4.75H3C2.44772 14 2 13.5523 2 13V3C2 2.44772 2.44772 2 3 2H4.75ZM4.75 13H3L3 3H4.75V13Z"
      fill="currentColor"
      fillRule="evenodd"
    />
  </svg>
);

const DoubleSideDoubleColumnOutlined = (props: LucideProps) => (
  <svg
    fill="none"
    height="16"
    viewBox="0 0 16 16"
    width="16"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M10.25 3H5.75V13H10.25V3ZM10.25 2H5.75H4.75H3C2.44772 2 2 2.44772 2 3V13C2 13.5523 2.44772 14 3 14H4.75H5.75H10.25H11.25H13C13.5523 14 14 13.5523 14 13V3C14 2.44772 13.5523 2 13 2H11.25H10.25ZM11.25 3V13H13V3H11.25ZM3 13H4.75V3H3L3 13Z"
      fill="currentColor"
      fillRule="evenodd"
    />
  </svg>
);

// ========== FILE END: ui/elements/layout/column-group-element.tsx ==========



// ========== FILE START: ui/elements/leafs/highlight-leaf-static.tsx ==========
import * as React from "react";

import type { SlateLeafProps } from "@udecode/plate";

import { SlateLeaf } from "@udecode/plate";

export function HighlightLeafStatic(props: SlateLeafProps) {
  return (
    <SlateLeaf {...props} as="mark" className="bg-highlight/30 text-inherit">
      {props.children}
    </SlateLeaf>
  );
}

// ========== FILE END: ui/elements/leafs/highlight-leaf-static.tsx ==========



// ========== FILE START: ui/elements/leafs/highlight-leaf.tsx ==========
"use client";

import * as React from "react";

import type { PlateLeafProps } from "@udecode/plate/react";

import { PlateLeaf } from "@udecode/plate/react";

export function HighlightLeaf(props: PlateLeafProps) {
  return (
    <PlateLeaf {...props} as="mark" className="bg-highlight/30 text-inherit">
      {props.children}
    </PlateLeaf>
  );
}

// ========== FILE END: ui/elements/leafs/highlight-leaf.tsx ==========



// ========== FILE START: ui/elements/leafs/index.ts ==========
export * from "./highlight-leaf-static";
export * from "./highlight-leaf";
export * from "./kbd-leaf-static";
export * from "./kbd-leaf";
export * from "./suggestion-leaf-static";
export * from "./suggestion-leaf";

// ========== FILE END: ui/elements/leafs/index.ts ==========



// ========== FILE START: ui/elements/leafs/kbd-leaf-static.tsx ==========
import * as React from "react";

import type { SlateLeafProps } from "@udecode/plate";

import { SlateLeaf } from "@udecode/plate";

export function KbdLeafStatic(props: SlateLeafProps) {
  return (
    <SlateLeaf
      {...props}
      as="kbd"
      className="rounded border border-border bg-muted px-1.5 py-0.5 font-mono text-sm shadow-[rgba(255,_255,_255,_0.1)_0px_0.5px_0px_0px_inset,_rgb(248,_249,_250)_0px_1px_5px_0px_inset,_rgb(193,_200,_205)_0px_0px_0px_0.5px,_rgb(193,_200,_205)_0px_2px_1px_-1px,_rgb(193,_200,_205)_0px_1px_0px_0px] dark:shadow-[rgba(255,_255,_255,_0.1)_0px_0.5px_0px_0px_inset,_rgb(26,_29,_30)_0px_1px_5px_0px_inset,_rgb(76,_81,_85)_0px_0px_0px_0.5px,_rgb(76,_81,_85)_0px_2px_1px_-1px,_rgb(76,_81,_85)_0px_1px_0px_0px]"
    >
      {props.children}
    </SlateLeaf>
  );
}

// ========== FILE END: ui/elements/leafs/kbd-leaf-static.tsx ==========



// ========== FILE START: ui/elements/leafs/kbd-leaf.tsx ==========
"use client";

import * as React from "react";

import type { PlateLeafProps } from "@udecode/plate/react";

import { PlateLeaf } from "@udecode/plate/react";

export function KbdLeaf(props: PlateLeafProps) {
  return (
    <PlateLeaf
      {...props}
      as="kbd"
      className="rounded border border-border bg-muted px-1.5 py-0.5 font-mono text-sm shadow-[rgba(255,_255,_255,_0.1)_0px_0.5px_0px_0px_inset,_rgb(248,_249,_250)_0px_1px_5px_0px_inset,_rgb(193,_200,_205)_0px_0px_0px_0.5px,_rgb(193,_200,_205)_0px_2px_1px_-1px,_rgb(193,_200,_205)_0px_1px_0px_0px] dark:shadow-[rgba(255,_255,_255,_0.1)_0px_0.5px_0px_0px_inset,_rgb(26,_29,_30)_0px_1px_5px_0px_inset,_rgb(76,_81,_85)_0px_0px_0px_0.5px,_rgb(76,_81,_85)_0px_2px_1px_-1px,_rgb(76,_81,_85)_0px_1px_0px_0px]"
    >
      {props.children}
    </PlateLeaf>
  );
}

// ========== FILE END: ui/elements/leafs/kbd-leaf.tsx ==========



// ========== FILE START: ui/elements/leafs/suggestion-leaf-static.tsx ==========
import * as React from "react";

import type { SlateLeafProps } from "@udecode/plate";
import type { TSuggestionText } from "@udecode/plate-suggestion";

import { SlateLeaf } from "@udecode/plate";
import { BaseSuggestionPlugin } from "@udecode/plate-suggestion";
import { useEditorPlugin } from "@udecode/plate/react";

import { cn } from "@/lib/utils";

export function SuggestionLeafStatic(props: SlateLeafProps<TSuggestionText>) {
  const { api } = useEditorPlugin(BaseSuggestionPlugin);
  const leaf = props.leaf;

  const dataList = api.suggestion.dataList(leaf);
  const hasRemove = dataList.some((data) => data.type === "remove");
  const diffOperation = { type: hasRemove ? "delete" : "insert" } as const;

  const Component = ({ delete: "del", insert: "ins", update: "span" } as const)[
    diffOperation.type
  ];

  return (
    <SlateLeaf
      {...props}
      as={Component}
      className={cn(
        "border-b-2 border-b-brand/[.24] bg-brand/[.08] text-brand/80 no-underline transition-colors duration-200",
        hasRemove &&
          "border-b-gray-300 bg-gray-300/25 text-gray-400 line-through",
      )}
    >
      {props.children}
    </SlateLeaf>
  );
}

// ========== FILE END: ui/elements/leafs/suggestion-leaf-static.tsx ==========



// ========== FILE START: ui/elements/leafs/suggestion-leaf.tsx ==========
"use client";

import * as React from "react";

import type { TSuggestionText } from "@udecode/plate-suggestion";
import type { PlateLeafProps } from "@udecode/plate/react";

import {
  PlateLeaf,
  useEditorPlugin,
  usePluginOption,
} from "@udecode/plate/react";

import { cn } from "@/lib/utils";
import { suggestionPlugin } from "../../../plugins/suggestion-plugin";

export function SuggestionLeaf(props: PlateLeafProps<TSuggestionText>) {
  const { api, setOption } = useEditorPlugin(suggestionPlugin);
  const leaf = props.leaf;

  const leafId: string = api.suggestion.nodeId(leaf) ?? "";
  const activeSuggestionId = usePluginOption(suggestionPlugin, "activeId");
  const hoverSuggestionId = usePluginOption(suggestionPlugin, "hoverId");
  const dataList = api.suggestion.dataList(leaf);

  const hasRemove = dataList.some((data) => data.type === "remove");
  const hasActive = dataList.some((data) => data.id === activeSuggestionId);
  const hasHover = dataList.some((data) => data.id === hoverSuggestionId);

  const diffOperation = { type: hasRemove ? "delete" : "insert" } as const;

  const Component = ({ delete: "del", insert: "ins", update: "span" } as const)[
    diffOperation.type
  ];

  return (
    <PlateLeaf
      {...props}
      as={Component}
      className={cn(
        "bg-emerald-100 text-emerald-700 no-underline transition-colors duration-200",
        (hasActive || hasHover) && "bg-emerald-200/80",
        hasRemove && "bg-red-100 text-red-700",
        (hasActive || hasHover) && hasRemove && "bg-red-200/80 no-underline",
      )}
      attributes={{
        ...props.attributes,
        onMouseEnter: () => setOption("hoverId", leafId),
        onMouseLeave: () => setOption("hoverId", null),
      }}
    >
      {props.children}
    </PlateLeaf>
  );
}

// ========== FILE END: ui/elements/leafs/suggestion-leaf.tsx ==========



// ========== FILE START: ui/elements/link/link-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps } from "@udecode/plate";
import type { TLinkElement } from "@udecode/plate-link";

import { SlateElement } from "@udecode/plate";

export function LinkElementStatic(props: SlateElementProps<TLinkElement>) {
  return (
    <SlateElement
      {...props}
      as="a"
      className="font-medium text-primary underline decoration-primary underline-offset-4"
    >
      {props.children}
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/link/link-element-static.tsx ==========



// ========== FILE START: ui/elements/link/link-element.tsx ==========
"use client";

import * as React from "react";

import type { TLinkElement } from "@udecode/plate-link";
import type { PlateElementProps } from "@udecode/plate/react";

import { useLink } from "@udecode/plate-link/react";
import { PlateElement } from "@udecode/plate/react";

export function LinkElement(props: PlateElementProps<TLinkElement>) {
  const { props: linkProps } = useLink({ element: props.element });

  return (
    <PlateElement
      {...props}
      as="a"
      className="font-medium text-primary underline decoration-primary underline-offset-4"
      attributes={{
        ...props.attributes,
        ...(linkProps as any),
      }}
    >
      {props.children}
    </PlateElement>
  );
}

// ========== FILE END: ui/elements/link/link-element.tsx ==========



// ========== FILE START: ui/elements/media/image-preview.tsx ==========
"use client";

import {
  PreviewImage,
  useImagePreview,
  useImagePreviewValue,
  useScaleInput,
} from "@udecode/plate-media/react";
import { useEditorRef } from "@udecode/plate/react";
import { cva } from "class-variance-authority";
import { ArrowLeft, ArrowRight, Download, Minus, Plus, X } from "lucide-react";

import { cn } from "@/lib/utils";

const toolButtonVariants = cva("rounded bg-[rgba(0,0,0,0.5)] px-1", {
  defaultVariants: {
    variant: "default",
  },
  variants: {
    variant: {
      default: "text-white",
      disabled: "cursor-not-allowed text-gray-400",
    },
  },
});

const SCROLL_SPEED = 4;

export const ImagePreview = () => {
  const editor = useEditorRef();
  const isOpen = useImagePreviewValue("isOpen", editor.id);
  const scale = useImagePreviewValue("scale");
  const isEditingScale = useImagePreviewValue("isEditingScale");
  const {
    closeProps,
    currentUrlIndex,
    maskLayerProps,
    nextDisabled,
    nextProps,
    prevDisabled,
    prevProps,
    scaleTextProps,
    zommOutProps,
    zoomInDisabled,
    zoomInProps,
    zoomOutDisabled,
  } = useImagePreview({ scrollSpeed: SCROLL_SPEED });

  return (
    <div
      className={cn(
        "fixed top-0 left-0 z-50 h-screen w-screen select-none",
        !isOpen && "hidden",
      )}
      onContextMenu={(e) => e.stopPropagation()}
      {...maskLayerProps}
    >
      <div className="absolute inset-0 size-full bg-black opacity-30"></div>
      <div className="absolute inset-0 size-full bg-black opacity-30"></div>
      <div className="absolute inset-0 flex items-center justify-center">
        <div className="relative flex max-h-screen w-full items-center">
          <PreviewImage
            className={cn(
              "mx-auto block max-h-[calc(100vh-4rem)] w-auto object-contain transition-transform",
            )}
          />
          <div
            className="absolute bottom-0 left-1/2 z-40 flex w-fit -translate-x-1/2 justify-center gap-4 p-2 text-center text-white"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="flex gap-1">
              <button
                {...prevProps}
                className={cn(
                  toolButtonVariants({
                    variant: prevDisabled ? "disabled" : "default",
                  }),
                )}
                type="button"
              >
                <ArrowLeft />
              </button>
              {(currentUrlIndex ?? 0) + 1}
              <button
                {...nextProps}
                className={cn(
                  toolButtonVariants({
                    variant: nextDisabled ? "disabled" : "default",
                  }),
                )}
                type="button"
              >
                <ArrowRight />
              </button>
            </div>
            <div className="flex">
              <button
                className={cn(
                  toolButtonVariants({
                    variant: zoomOutDisabled ? "disabled" : "default",
                  }),
                )}
                {...zommOutProps}
                type="button"
              >
                <Minus className="size-4" />
              </button>
              <div className="mx-px">
                {isEditingScale ? (
                  <>
                    <ScaleInput className="w-10 rounded px-1 text-slate-500 outline" />{" "}
                    <span>%</span>
                  </>
                ) : (
                  <span {...scaleTextProps}>{scale * 100 + "%"}</span>
                )}
              </div>
              <button
                className={cn(
                  toolButtonVariants({
                    variant: zoomInDisabled ? "disabled" : "default",
                  }),
                )}
                {...zoomInProps}
                type="button"
              >
                <Plus className="size-4" />
              </button>
            </div>
            {/* TODO: downLoad the image */}
            <button className={cn(toolButtonVariants())} type="button">
              <Download className="size-4" />
            </button>
            <button
              {...closeProps}
              className={cn(toolButtonVariants())}
              type="button"
            >
              <X className="size-4" />
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export function ScaleInput(props: React.ComponentProps<"input">) {
  const { props: scaleInputProps, ref } = useScaleInput();

  return <input {...scaleInputProps} {...props} ref={ref} />;
}

// ========== FILE END: ui/elements/media/image-preview.tsx ==========



// ========== FILE START: ui/elements/media/media-audio-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps } from "@udecode/plate";
import type { TAudioElement } from "@udecode/plate-media";

import { SlateElement } from "@udecode/plate";

export function MediaAudioElementStatic(
  props: SlateElementProps<TAudioElement>,
) {
  return (
    <SlateElement {...props} className="mb-1">
      <figure className="group relative cursor-default">
        <div className="h-16">
          <audio className="size-full" src={props.element.url} controls />
        </div>
      </figure>
      {props.children}
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/media/media-audio-element-static.tsx ==========



// ========== FILE START: ui/elements/media/media-audio-element.tsx ==========
"use client";

import * as React from "react";

import type { TAudioElement } from "@udecode/plate-media";
import type { PlateElementProps } from "@udecode/plate/react";

import { useMediaState } from "@udecode/plate-media/react";
import { ResizableProvider } from "@udecode/plate-resizable";
import { PlateElement, withHOC } from "@udecode/plate/react";

import { Caption, CaptionTextarea } from "../../primitives/caption";

export const MediaAudioElement = withHOC(
  ResizableProvider,
  function MediaAudioElement(props: PlateElementProps<TAudioElement>) {
    const { align = "center", readOnly, unsafeUrl } = useMediaState();

    return (
      <PlateElement {...props} className="mb-1">
        <figure
          className="group relative cursor-default"
          contentEditable={false}
        >
          <div className="h-16">
            <audio className="size-full" src={unsafeUrl} controls />
          </div>

          <Caption style={{ width: "100%" }} align={align}>
            <CaptionTextarea
              className="h-20"
              readOnly={readOnly}
              placeholder="Write a caption..."
            />
          </Caption>
        </figure>
        {props.children}
      </PlateElement>
    );
  },
);

// ========== FILE END: ui/elements/media/media-audio-element.tsx ==========



// ========== FILE START: ui/elements/media/media-embed-element.tsx ==========
"use client";

import * as React from "react";
import LiteYouTubeEmbed from "react-lite-youtube-embed";
import { Tweet } from "react-tweet";

import type { TMediaEmbedElement } from "@udecode/plate-media";
import type { PlateElementProps } from "@udecode/plate/react";

import { parseTwitterUrl, parseVideoUrl } from "@udecode/plate-media";
import { MediaEmbedPlugin, useMediaState } from "@udecode/plate-media/react";
import { ResizableProvider, useResizableValue } from "@udecode/plate-resizable";
import { PlateElement, withHOC } from "@udecode/plate/react";

import { cn } from "@/lib/utils";

import { Caption, CaptionTextarea } from "../../primitives/caption";
import { MediaPopover } from "./media-popover";
import {
  mediaResizeHandleVariants,
  Resizable,
  ResizeHandle,
} from "../../primitives/resize-handle";

export const MediaEmbedElement = withHOC(
  ResizableProvider,
  function MediaEmbedElement(props: PlateElementProps<TMediaEmbedElement>) {
    const {
      align = "center",
      embed,
      focused,
      isTweet,
      isVideo,
      isYoutube,
      readOnly,
      selected,
    } = useMediaState({
      urlParsers: [parseTwitterUrl, parseVideoUrl],
    });
    const width = useResizableValue("width");
    const provider = embed?.provider;

    return (
      <MediaPopover plugin={MediaEmbedPlugin}>
        <PlateElement className="py-2.5" {...props}>
          <figure
            className="group relative m-0 w-full cursor-default"
            contentEditable={false}
          >
            <Resizable
              align={align}
              options={{
                align,
                maxWidth: isTweet ? 550 : "100%",
                minWidth: isTweet ? 300 : 100,
              }}
            >
              <ResizeHandle
                className={mediaResizeHandleVariants({ direction: "left" })}
                options={{ direction: "left" }}
              />

              {isVideo ? (
                isYoutube ? (
                  <LiteYouTubeEmbed
                    id={embed!.id!}
                    title="youtube"
                    wrapperClass={cn(
                      "rounded-sm",
                      focused && selected && "ring-2 ring-ring ring-offset-2",
                      "relative block cursor-pointer bg-black bg-cover bg-center [contain:content]",
                      "[&.lyt-activated]:before:absolute [&.lyt-activated]:before:top-0 [&.lyt-activated]:before:h-[60px] [&.lyt-activated]:before:w-full [&.lyt-activated]:before:bg-top [&.lyt-activated]:before:bg-repeat-x [&.lyt-activated]:before:pb-[50px] [&.lyt-activated]:before:[transition:all_0.2s_cubic-bezier(0,_0,_0.2,_1)]",
                      "[&.lyt-activated]:before:bg-[url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADGCAYAAAAT+OqFAAAAdklEQVQoz42QQQ7AIAgEF/T/D+kbq/RWAlnQyyazA4aoAB4FsBSA/bFjuF1EOL7VbrIrBuusmrt4ZZORfb6ehbWdnRHEIiITaEUKa5EJqUakRSaEYBJSCY2dEstQY7AuxahwXFrvZmWl2rh4JZ07z9dLtesfNj5q0FU3A5ObbwAAAABJRU5ErkJggg==)]",
                      'after:block after:pb-[var(--aspect-ratio)] after:content-[""]',
                      "[&_>_iframe]:absolute [&_>_iframe]:top-0 [&_>_iframe]:left-0 [&_>_iframe]:size-full",
                      "[&_>_.lty-playbtn]:z-1 [&_>_.lty-playbtn]:h-[46px] [&_>_.lty-playbtn]:w-[70px] [&_>_.lty-playbtn]:rounded-[14%] [&_>_.lty-playbtn]:bg-[#212121] [&_>_.lty-playbtn]:opacity-80 [&_>_.lty-playbtn]:[transition:all_0.2s_cubic-bezier(0,_0,_0.2,_1)]",
                      "[&:hover_>_.lty-playbtn]:bg-[red] [&:hover_>_.lty-playbtn]:opacity-100",
                      '[&_>_.lty-playbtn]:before:border-y-[11px] [&_>_.lty-playbtn]:before:border-r-0 [&_>_.lty-playbtn]:before:border-l-[19px] [&_>_.lty-playbtn]:before:border-[transparent_transparent_transparent_#fff] [&_>_.lty-playbtn]:before:content-[""]',
                      "[&_>_.lty-playbtn]:absolute [&_>_.lty-playbtn]:top-1/2 [&_>_.lty-playbtn]:left-1/2 [&_>_.lty-playbtn]:[transform:translate3d(-50%,-50%,0)]",
                      "[&_>_.lty-playbtn]:before:absolute [&_>_.lty-playbtn]:before:top-1/2 [&_>_.lty-playbtn]:before:left-1/2 [&_>_.lty-playbtn]:before:[transform:translate3d(-50%,-50%,0)]",
                      "[&.lyt-activated]:cursor-[unset]",
                      "[&.lyt-activated]:before:pointer-events-none [&.lyt-activated]:before:opacity-0",
                      "[&.lyt-activated_>_.lty-playbtn]:pointer-events-none [&.lyt-activated_>_.lty-playbtn]:opacity-0!",
                    )}
                  />
                ) : (
                  <div
                    className={cn(
                      provider === "vimeo" && "pb-[75%]",
                      provider === "youku" && "pb-[56.25%]",
                      provider === "dailymotion" && "pb-[56.0417%]",
                      provider === "coub" && "pb-[51.25%]",
                    )}
                  >
                    <iframe
                      className={cn(
                        "absolute top-0 left-0 size-full rounded-sm",
                        isVideo && "border-0",
                        focused && selected && "ring-2 ring-ring ring-offset-2",
                      )}
                      title="embed"
                      src={embed!.url}
                      allowFullScreen
                    />
                  </div>
                )
              ) : null}

              {isTweet && (
                <div
                  className={cn(
                    "[&_.react-tweet-theme]:my-0",
                    !readOnly &&
                      selected &&
                      "[&_.react-tweet-theme]:ring-2 [&_.react-tweet-theme]:ring-ring [&_.react-tweet-theme]:ring-offset-2",
                  )}
                >
                  <Tweet id={embed!.id!} />
                </div>
              )}

              <ResizeHandle
                className={mediaResizeHandleVariants({ direction: "right" })}
                options={{ direction: "right" }}
              />
            </Resizable>

            <Caption style={{ width }} align={align}>
              <CaptionTextarea placeholder="Write a caption..." />
            </Caption>
          </figure>

          {props.children}
        </PlateElement>
      </MediaPopover>
    );
  },
);

// ========== FILE END: ui/elements/media/media-embed-element.tsx ==========



// ========== FILE START: ui/elements/media/media-file-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps } from "@udecode/plate";
import type { TFileElement } from "@udecode/plate-media";

import { SlateElement } from "@udecode/plate";
import { FileUp } from "lucide-react";

export function MediaFileElementStatic(props: SlateElementProps<TFileElement>) {
  const { name, url } = props.element;

  return (
    <SlateElement className="my-px rounded-sm" {...props}>
      <a
        className="group relative m-0 flex cursor-pointer items-center rounded px-0.5 py-[3px] hover:bg-muted"
        contentEditable={false}
        download={name}
        href={url}
        rel="noopener noreferrer"
        role="button"
        target="_blank"
      >
        <div className="flex items-center gap-1 p-1">
          <FileUp className="size-5" />
          <div>{name}</div>
        </div>
      </a>
      {props.children}
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/media/media-file-element-static.tsx ==========



// ========== FILE START: ui/elements/media/media-file-element.tsx ==========
"use client";

import * as React from "react";

import type { TFileElement } from "@udecode/plate-media";
import type { PlateElementProps } from "@udecode/plate/react";

import { useMediaState } from "@udecode/plate-media/react";
import { ResizableProvider } from "@udecode/plate-resizable";
import { PlateElement, useReadOnly, withHOC } from "@udecode/plate/react";
import { FileUp } from "lucide-react";

import { Caption, CaptionTextarea } from "../../primitives/caption";

export const MediaFileElement = withHOC(
  ResizableProvider,
  function MediaFileElement(props: PlateElementProps<TFileElement>) {
    const readOnly = useReadOnly();
    const { name, unsafeUrl } = useMediaState();

    return (
      <PlateElement className="my-px rounded-sm" {...props}>
        <a
          className="group relative m-0 flex cursor-pointer items-center rounded px-0.5 py-[3px] hover:bg-muted"
          contentEditable={false}
          download={name}
          href={unsafeUrl}
          rel="noopener noreferrer"
          role="button"
          target="_blank"
        >
          <div className="flex items-center gap-1 p-1">
            <FileUp className="size-5" />
            <div>{name}</div>
          </div>

          <Caption align="left">
            <CaptionTextarea
              className="text-left"
              readOnly={readOnly}
              placeholder="Write a caption..."
            />
          </Caption>
        </a>
        {props.children}
      </PlateElement>
    );
  },
);

// ========== FILE END: ui/elements/media/media-file-element.tsx ==========



// ========== FILE START: ui/elements/media/media-placeholder-element.tsx ==========
"use client";

import * as React from "react";
import Image from "next/image";

import type { TPlaceholderElement } from "@udecode/plate-media";
import type { PlateElementProps } from "@udecode/plate/react";

import {
  AudioPlugin,
  FilePlugin,
  ImagePlugin,
  PlaceholderPlugin,
  PlaceholderProvider,
  updateUploadHistory,
  VideoPlugin,
} from "@udecode/plate-media/react";
import { PlateElement, useEditorPlugin, withHOC } from "@udecode/plate/react";
import { AudioLines, FileUp, Film, ImageIcon, Loader2Icon } from "lucide-react";
import { useFilePicker } from "use-file-picker";

import { cn } from "@/lib/utils";
import { useUploadFile } from "@/hooks/use-upload-file";

const CONTENT: Record<
  string,
  {
    accept: string[];
    content: React.ReactNode;
    icon: React.ReactNode;
  }
> = {
  [AudioPlugin.key]: {
    accept: ["audio/*"],
    content: "Add an audio file",
    icon: <AudioLines />,
  },
  [FilePlugin.key]: {
    accept: ["*"],
    content: "Add a file",
    icon: <FileUp />,
  },
  [ImagePlugin.key]: {
    accept: ["image/*"],
    content: "Add an image",
    icon: <ImageIcon />,
  },
  [VideoPlugin.key]: {
    accept: ["video/*"],
    content: "Add a video",
    icon: <Film />,
  },
};

export const MediaPlaceholderElement = withHOC(
  PlaceholderProvider,
  function MediaPlaceholderElement(
    props: PlateElementProps<TPlaceholderElement>,
  ) {
    const { editor, element } = props;

    const { api } = useEditorPlugin(PlaceholderPlugin);

    const { isUploading, progress, uploadedFile, uploadFile, uploadingFile } =
      useUploadFile();

    const loading = isUploading && uploadingFile;

    const currentContent = CONTENT[element.mediaType];

    const isImage = element.mediaType === ImagePlugin.key;

    const imageRef = React.useRef<HTMLImageElement>(null);

    const { openFilePicker } = useFilePicker({
      accept: currentContent.accept,
      multiple: true,
      onFilesSelected: ({ plainFiles: updatedFiles }) => {
        const firstFile = updatedFiles[0];
        const restFiles = updatedFiles.slice(1);

        replaceCurrentPlaceholder(firstFile);

        if (restFiles.length > 0) {
          editor.getTransforms(PlaceholderPlugin).insert.media(restFiles);
        }
      },
    });

    const replaceCurrentPlaceholder = React.useCallback(
      (file: File) => {
        void uploadFile(file);
        api.placeholder.addUploadingFile(element.id as string, file);
      },
      [api.placeholder, element.id, uploadFile],
    );

    React.useEffect(() => {
      if (!uploadedFile) return;

      const path = editor.api.findPath(element);

      editor.tf.withoutSaving(() => {
        editor.tf.removeNodes({ at: path });

        const node = {
          children: [{ text: "" }],
          initialHeight: imageRef.current?.height,
          initialWidth: imageRef.current?.width,
          isUpload: true,
          name: element.mediaType === FilePlugin.key ? uploadedFile.name : "",
          placeholderId: element.id as string,
          type: element.mediaType!,
          url: uploadedFile.url,
        };

        editor.tf.insertNodes(node, { at: path });

        updateUploadHistory(editor, node);
      });

      api.placeholder.removeUploadingFile(element.id as string);
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [uploadedFile, element.id]);

    // React dev mode will call React.useEffect twice
    const isReplaced = React.useRef(false);

    /** Paste and drop */
    React.useEffect(() => {
      if (isReplaced.current) return;

      isReplaced.current = true;
      const currentFiles = api.placeholder.getUploadingFile(
        element.id as string,
      );

      if (!currentFiles) return;

      replaceCurrentPlaceholder(currentFiles);

      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isReplaced]);

    return (
      <PlateElement className="my-1" {...props}>
        {(!loading || !isImage) && (
          <div
            className={cn(
              "flex cursor-pointer items-center rounded-sm bg-muted p-3 pr-9 select-none hover:bg-primary/10",
            )}
            onClick={() => !loading && openFilePicker()}
            contentEditable={false}
          >
            <div className="relative mr-3 flex text-muted-foreground/80 [&_svg]:size-6">
              {currentContent.icon}
            </div>
            <div className="text-sm whitespace-nowrap text-muted-foreground">
              <div>
                {loading ? uploadingFile?.name : currentContent.content}
              </div>

              {loading && !isImage && (
                <div className="mt-1 flex items-center gap-1.5">
                  <div>{formatBytes(uploadingFile?.size ?? 0)}</div>
                  <div></div>
                  <div className="flex items-center">
                    <Loader2Icon className="mr-1 size-3.5 animate-spin text-muted-foreground" />
                    {progress ?? 0}%
                  </div>
                </div>
              )}
            </div>
          </div>
        )}

        {isImage && loading && (
          <ImageProgress
            file={uploadingFile}
            imageRef={imageRef}
            progress={progress}
          />
        )}

        {props.children}
      </PlateElement>
    );
  },
);

export function ImageProgress({
  className,
  file,
  imageRef,
  progress = 0,
}: {
  file: File;
  className?: string;
  imageRef?: React.RefObject<HTMLImageElement | null>;
  progress?: number;
}) {
  const [objectUrl, setObjectUrl] = React.useState<string | null>(null);

  React.useEffect(() => {
    const url = URL.createObjectURL(file);
    setObjectUrl(url);

    return () => {
      URL.revokeObjectURL(url);
    };
  }, [file]);

  if (!objectUrl) {
    return null;
  }

  return (
    <div className={cn("relative", className)} contentEditable={false}>
      <Image
        ref={imageRef as React.RefObject<HTMLImageElement>}
        className="h-auto w-full rounded-sm object-cover"
        alt={file.name}
        src={objectUrl}
        width={0}
        height={0}
        sizes="100vw"
        style={{ objectFit: "cover" }}
        onLoadingComplete={(img) => {
          if (imageRef?.current) {
            imageRef.current.width = img.naturalWidth;
            imageRef.current.height = img.naturalHeight;
          }
        }}
      />
      {progress < 100 && (
        <div className="absolute right-1 bottom-1 flex items-center space-x-2 rounded-full bg-black/50 px-1 py-0.5">
          <Loader2Icon className="size-3.5 animate-spin text-muted-foreground" />
          <span className="text-xs font-medium text-white">
            {Math.round(progress)}%
          </span>
        </div>
      )}
    </div>
  );
}

export function formatBytes(
  bytes: number,
  opts: {
    decimals?: number;
    sizeType?: "accurate" | "normal";
  } = {},
) {
  const { decimals = 0, sizeType = "normal" } = opts;

  const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
  const accurateSizes = ["Bytes", "KiB", "MiB", "GiB", "TiB"];

  if (bytes === 0) return "0 Byte";

  const i = Math.floor(Math.log(bytes) / Math.log(1024));

  return `${(bytes / Math.pow(1024, i)).toFixed(decimals)} ${
    sizeType === "accurate"
      ? (accurateSizes[i] ?? "Bytest")
      : (sizes[i] ?? "Bytes")
  }`;
}

// ========== FILE END: ui/elements/media/media-placeholder-element.tsx ==========



// ========== FILE START: ui/elements/media/media-popover.tsx ==========
"use client";

import * as React from "react";

import type { WithRequiredKey } from "@udecode/plate";

import {
  FloatingMedia as FloatingMediaPrimitive,
  FloatingMediaStore,
  useFloatingMediaValue,
  useImagePreviewValue,
} from "@udecode/plate-media/react";
import {
  useEditorRef,
  useEditorSelector,
  useElement,
  useReadOnly,
  useRemoveNodeButton,
  useSelected,
} from "@udecode/plate/react";
import { cva } from "class-variance-authority";
import { Link, Trash2Icon } from "lucide-react";

import { Button, buttonVariants } from "@/components/ui/button";
import {
  Popover,
  PopoverAnchor,
  PopoverContent,
} from "@/components/ui/popover";
import { Separator } from "@/components/ui/separator";

import { CaptionButton } from "../../primitives/caption";

const inputVariants = cva(
  "flex h-[28px] w-full rounded-md border-none bg-transparent px-1.5 py-1 text-base placeholder:text-muted-foreground focus-visible:ring-transparent focus-visible:outline-none md:text-sm",
);

export interface MediaPopoverProps {
  children: React.ReactNode;
  plugin: WithRequiredKey;
}

export function MediaPopover({ children, plugin }: MediaPopoverProps) {
  const editor = useEditorRef();
  const readOnly = useReadOnly();
  const selected = useSelected();

  const selectionCollapsed = useEditorSelector(
    (editor) => !editor.api.isExpanded(),
    [],
  );
  const isImagePreviewOpen = useImagePreviewValue("isOpen", editor.id);
  const isOpen =
    !readOnly && selected && selectionCollapsed && !isImagePreviewOpen;
  const isEditing = useFloatingMediaValue("isEditing");

  React.useEffect(() => {
    if (!isOpen && isEditing) {
      FloatingMediaStore.set("isEditing", false);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isOpen]);

  const element = useElement();
  const { props: buttonProps } = useRemoveNodeButton({ element });

  if (readOnly) return <>{children}</>;

  return (
    <Popover open={isOpen} modal={false}>
      <PopoverAnchor>{children}</PopoverAnchor>

      <PopoverContent
        className="w-auto p-1"
        onOpenAutoFocus={(e) => e.preventDefault()}
      >
        {isEditing ? (
          <div className="flex w-[330px] flex-col">
            <div className="flex items-center">
              <div className="flex items-center pr-1 pl-2 text-muted-foreground">
                <Link className="size-4" />
              </div>

              <FloatingMediaPrimitive.UrlInput
                className={inputVariants()}
                placeholder="Paste the embed link..."
                options={{ plugin }}
              />
            </div>
          </div>
        ) : (
          <div className="box-content flex items-center">
            <FloatingMediaPrimitive.EditButton
              className={buttonVariants({ size: "sm", variant: "ghost" })}
            >
              Edit link
            </FloatingMediaPrimitive.EditButton>

            <CaptionButton variant="ghost">Caption</CaptionButton>

            <Separator orientation="vertical" className="mx-1 h-6" />

            <Button size="icon" variant="ghost" {...buttonProps}>
              <Trash2Icon />
            </Button>
          </div>
        )}
      </PopoverContent>
    </Popover>
  );
}

// ========== FILE END: ui/elements/media/media-popover.tsx ==========



// ========== FILE START: ui/elements/media/media-upload-toast.tsx ==========
"use client";

import * as React from "react";

import { PlaceholderPlugin, UploadErrorCode } from "@udecode/plate-media/react";
import { usePluginOption } from "@udecode/plate/react";
import { toast } from "sonner";

export const useUploadErrorToast = () => {
  const uploadError = usePluginOption(PlaceholderPlugin, "error");

  React.useEffect(() => {
    if (!uploadError) return;

    const { code, data } = uploadError;

    switch (code) {
      case UploadErrorCode.INVALID_FILE_SIZE: {
        toast.error(
          `The size of files ${data.files
            .map((f) => f.name)
            .join(", ")} is invalid`,
        );

        break;
      }
      case UploadErrorCode.INVALID_FILE_TYPE: {
        toast.error(
          `The type of files ${data.files
            .map((f) => f.name)
            .join(", ")} is invalid`,
        );

        break;
      }
      case UploadErrorCode.TOO_LARGE: {
        toast.error(
          `The size of files ${data.files
            .map((f) => f.name)
            .join(", ")} is too large than ${data.maxFileSize}`,
        );

        break;
      }
      case UploadErrorCode.TOO_LESS_FILES: {
        toast.error(
          `The mini um number of files is ${data.minFileCount} for ${data.fileType}`,
        );

        break;
      }
      case UploadErrorCode.TOO_MANY_FILES: {
        toast.error(
          `The maximum number of files is ${data.maxFileCount} ${
            data.fileType ? `for ${data.fileType}` : ""
          }`,
        );

        break;
      }
    }
  }, [uploadError]);
};

export const MediaUploadToast = () => {
  useUploadErrorToast();

  return null;
};

// ========== FILE END: ui/elements/media/media-upload-toast.tsx ==========



// ========== FILE START: ui/elements/media/media-video-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps } from "@udecode/plate";
import type { TCaptionElement } from "@udecode/plate-caption";
import type { TVideoElement } from "@udecode/plate-media";

import { NodeApi, SlateElement } from "@udecode/plate";

export function MediaVideoElementStatic(
  props: SlateElementProps<TVideoElement & TCaptionElement & { width: number }>,
) {
  const { align = "center", caption, url, width } = props.element;

  return (
    <SlateElement className="py-2.5" {...props}>
      <div style={{ textAlign: align }}>
        <figure
          className="group relative m-0 inline-block cursor-default"
          style={{ width }}
        >
          <video
            className="w-full max-w-full rounded-sm object-cover px-0"
            src={url}
            controls
          />
          {caption && <figcaption>{NodeApi.string(caption[0])}</figcaption>}
        </figure>
      </div>
      {props.children}
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/media/media-video-element-static.tsx ==========



// ========== FILE START: ui/elements/media/media-video-element.tsx ==========
"use client";

import * as React from "react";
import LiteYouTubeEmbed from "react-lite-youtube-embed";
import ReactPlayer from "react-player";

import type { TVideoElement } from "@udecode/plate-media";
import type { PlateElementProps } from "@udecode/plate/react";

import { useDraggable } from "@udecode/plate-dnd";
import { parseTwitterUrl, parseVideoUrl } from "@udecode/plate-media";
import { useMediaState } from "@udecode/plate-media/react";
import { ResizableProvider, useResizableValue } from "@udecode/plate-resizable";
import { PlateElement, useEditorMounted, withHOC } from "@udecode/plate/react";

import { cn } from "@/lib/utils";

import { Caption, CaptionTextarea } from "../../primitives/caption";
import {
  mediaResizeHandleVariants,
  Resizable,
  ResizeHandle,
} from "../../primitives/resize-handle";

export const MediaVideoElement = withHOC(
  ResizableProvider,
  function MediaVideoElement(props: PlateElementProps<TVideoElement>) {
    const {
      align = "center",
      embed,
      isUpload,
      isYoutube,
      readOnly,
      unsafeUrl,
    } = useMediaState({
      urlParsers: [parseTwitterUrl, parseVideoUrl],
    });
    const width = useResizableValue("width");

    const isEditorMounted = useEditorMounted();

    const isTweet = true;

    const { isDragging, handleRef } = useDraggable({
      element: props.element,
    });

    return (
      <PlateElement className="py-2.5" {...props}>
        <figure className="relative m-0 cursor-default" contentEditable={false}>
          <Resizable
            className={cn(isDragging && "opacity-50")}
            align={align}
            options={{
              align,
              maxWidth: isTweet ? 550 : "100%",
              minWidth: isTweet ? 300 : 100,
              readOnly,
            }}
          >
            <div className="group/media">
              <ResizeHandle
                className={mediaResizeHandleVariants({ direction: "left" })}
                options={{ direction: "left" }}
              />

              <ResizeHandle
                className={mediaResizeHandleVariants({ direction: "right" })}
                options={{ direction: "right" }}
              />

              {!isUpload && isYoutube && (
                <div ref={handleRef}>
                  <LiteYouTubeEmbed
                    id={embed!.id!}
                    title="youtube"
                    wrapperClass={cn(
                      "aspect-video rounded-sm",
                      "relative block cursor-pointer bg-black bg-cover bg-center [contain:content]",
                      "[&.lyt-activated]:before:absolute [&.lyt-activated]:before:top-0 [&.lyt-activated]:before:h-[60px] [&.lyt-activated]:before:w-full [&.lyt-activated]:before:bg-top [&.lyt-activated]:before:bg-repeat-x [&.lyt-activated]:before:pb-[50px] [&.lyt-activated]:before:[transition:all_0.2s_cubic-bezier(0,_0,_0.2,_1)]",
                      "[&.lyt-activated]:before:bg-[url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADGCAYAAAAT+OqFAAAAdklEQVQoz42QQQ7AIAgEF/T/D+kbq/RWAlnQyyazA4aoAB4FsBSA/bFjuF1EOL7VbrIrBuusmrt4ZZORfb6ehbWdnRHEIiITaEUKa5EJqUakRSaEYBJSCY2dEstQY7AuxahwXFrvZmWl2rh4JZ07z9dLtesfNj5q0FU3A5ObbwAAAABJRU5ErkJggg==)]",
                      'after:block after:pb-[var(--aspect-ratio)] after:content-[""]',
                      "[&_>_iframe]:absolute [&_>_iframe]:top-0 [&_>_iframe]:left-0 [&_>_iframe]:size-full",
                      "[&_>_.lty-playbtn]:z-1 [&_>_.lty-playbtn]:h-[46px] [&_>_.lty-playbtn]:w-[70px] [&_>_.lty-playbtn]:rounded-[14%] [&_>_.lty-playbtn]:bg-[#212121] [&_>_.lty-playbtn]:opacity-80 [&_>_.lty-playbtn]:[transition:all_0.2s_cubic-bezier(0,_0,_0.2,_1)]",
                      "[&:hover_>_.lty-playbtn]:bg-[red] [&:hover_>_.lty-playbtn]:opacity-100",
                      '[&_>_.lty-playbtn]:before:border-y-[11px] [&_>_.lty-playbtn]:before:border-r-0 [&_>_.lty-playbtn]:before:border-l-[19px] [&_>_.lty-playbtn]:before:border-[transparent_transparent_transparent_#fff] [&_>_.lty-playbtn]:before:content-[""]',
                      "[&_>_.lty-playbtn]:absolute [&_>_.lty-playbtn]:top-1/2 [&_>_.lty-playbtn]:left-1/2 [&_>_.lty-playbtn]:[transform:translate3d(-50%,-50%,0)]",
                      "[&_>_.lty-playbtn]:before:absolute [&_>_.lty-playbtn]:before:top-1/2 [&_>_.lty-playbtn]:before:left-1/2 [&_>_.lty-playbtn]:before:[transform:translate3d(-50%,-50%,0)]",
                      "[&.lyt-activated]:cursor-[unset]",
                      "[&.lyt-activated]:before:pointer-events-none [&.lyt-activated]:before:opacity-0",
                      "[&.lyt-activated_>_.lty-playbtn]:pointer-events-none [&.lyt-activated_>_.lty-playbtn]:opacity-0!",
                    )}
                  />
                </div>
              )}

              {isUpload && isEditorMounted && (
                <div ref={handleRef}>
                  <ReactPlayer
                    height="100%"
                    url={unsafeUrl}
                    width="100%"
                    controls
                  />
                </div>
              )}
            </div>
          </Resizable>

          <Caption style={{ width }} align={align}>
            <CaptionTextarea
              readOnly={readOnly}
              placeholder="Write a caption..."
            />
          </Caption>
        </figure>
        {props.children}
      </PlateElement>
    );
  },
);

// ========== FILE END: ui/elements/media/media-video-element.tsx ==========



// ========== FILE START: ui/elements/mention/mention-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps } from "@udecode/plate";
import type { TMentionElement } from "@udecode/plate-mention";

import { IS_APPLE, SlateElement } from "@udecode/plate";

import { cn } from "@/lib/utils";

export function MentionElementStatic(
  props: SlateElementProps<TMentionElement> & {
    prefix?: string;
  },
) {
  const { prefix } = props;
  const element = props.element;

  return (
    <SlateElement
      className={cn(
        "inline-block rounded-md bg-muted px-1.5 py-0.5 align-baseline text-sm font-medium",
        element.children[0].bold === true && "font-bold",
        element.children[0].italic === true && "italic",
        element.children[0].underline === true && "underline",
      )}
      data-slate-value={element.value}
      {...props}
    >
      {IS_APPLE ? (
        // Mac OS IME https://github.com/ianstormtaylor/slate/issues/3490
        <React.Fragment>
          {props.children}
          {prefix}
          {element.value}
        </React.Fragment>
      ) : (
        // Others like Android https://github.com/ianstormtaylor/slate/pull/5360
        <React.Fragment>
          {prefix}
          {element.value}
          {props.children}
        </React.Fragment>
      )}
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/mention/mention-element-static.tsx ==========



// ========== FILE START: ui/elements/mention/mention-element.tsx ==========
"use client";

import * as React from "react";

import type { TMentionElement } from "@udecode/plate-mention";
import type { PlateElementProps } from "@udecode/plate/react";

import { IS_APPLE } from "@udecode/plate";
import {
  PlateElement,
  useFocused,
  useReadOnly,
  useSelected,
} from "@udecode/plate/react";

import { cn } from "@/lib/utils";
import { useMounted } from "@/hooks/use-mounted";

export function MentionElement(
  props: PlateElementProps<TMentionElement> & {
    prefix?: string;
  },
) {
  const element = props.element;
  const selected = useSelected();
  const focused = useFocused();
  const mounted = useMounted();
  const readOnly = useReadOnly();

  return (
    <PlateElement
      {...props}
      className={cn(
        "inline-block rounded-md bg-muted px-1.5 py-0.5 align-baseline text-sm font-medium",
        !readOnly && "cursor-pointer",
        selected && focused && "ring-2 ring-ring",
        element.children[0].bold === true && "font-bold",
        element.children[0].italic === true && "italic",
        element.children[0].underline === true && "underline",
      )}
      attributes={{
        ...props.attributes,
        contentEditable: false,
        "data-slate-value": element.value,
        draggable: true,
      }}
    >
      {mounted && IS_APPLE ? (
        // Mac OS IME https://github.com/ianstormtaylor/slate/issues/3490
        <React.Fragment>
          {props.children}
          {props.prefix}
          {element.value}
        </React.Fragment>
      ) : (
        // Others like Android https://github.com/ianstormtaylor/slate/pull/5360
        <React.Fragment>
          {props.prefix}
          {element.value}
          {props.children}
        </React.Fragment>
      )}
    </PlateElement>
  );
}

// ========== FILE END: ui/elements/mention/mention-element.tsx ==========



// ========== FILE START: ui/elements/mention/mention-input-element.tsx ==========
"use client";

import * as React from "react";

import type { TMentionInputElement } from "@udecode/plate-mention";
import type { PlateElementProps } from "@udecode/plate/react";

import { getMentionOnSelectItem } from "@udecode/plate-mention";
import { PlateElement } from "@udecode/plate/react";

import {
  InlineCombobox,
  InlineComboboxContent,
  InlineComboboxEmpty,
  InlineComboboxGroup,
  InlineComboboxInput,
  InlineComboboxItem,
} from "../../menus/inline-combobox";

const onSelectItem = getMentionOnSelectItem();

export function MentionInputElement(
  props: PlateElementProps<TMentionInputElement>,
) {
  const { editor, element } = props;
  const [search, setSearch] = React.useState("");

  return (
    <PlateElement {...props} as="span" data-slate-value={element.value}>
      <InlineCombobox
        value={search}
        element={element}
        setValue={setSearch}
        showTrigger={false}
        trigger="@"
      >
        <span className="inline-block rounded-md bg-muted px-1.5 py-0.5 align-baseline text-sm ring-ring focus-within:ring-2">
          <InlineComboboxInput />
        </span>

        <InlineComboboxContent className="my-1.5">
          <InlineComboboxEmpty>No results</InlineComboboxEmpty>

          <InlineComboboxGroup>
            {MENTIONABLES.map((item) => (
              <InlineComboboxItem
                key={item.key}
                value={item.text}
                onClick={() => onSelectItem(editor, item, search)}
              >
                {item.text}
              </InlineComboboxItem>
            ))}
          </InlineComboboxGroup>
        </InlineComboboxContent>
      </InlineCombobox>

      {props.children}
    </PlateElement>
  );
}

export const MENTIONABLES = [
  { key: "0", text: "Aayla Secura" },
  { key: "1", text: "Adi Gallia" },
  {
    key: "2",
    text: "Admiral Dodd Rancit",
  },
  {
    key: "3",
    text: "Admiral Firmus Piett",
  },
  {
    key: "4",
    text: "Admiral Gial Ackbar",
  },
  { key: "5", text: "Admiral Ozzel" },
  { key: "6", text: "Admiral Raddus" },
  {
    key: "7",
    text: "Admiral Terrinald Screed",
  },
  { key: "8", text: "Admiral Trench" },
  {
    key: "9",
    text: "Admiral U.O. Statura",
  },
  { key: "10", text: "Agen Kolar" },
  { key: "11", text: "Agent Kallus" },
  {
    key: "12",
    text: "Aiolin and Morit Astarte",
  },
  { key: "13", text: "Aks Moe" },
  { key: "14", text: "Almec" },
  { key: "15", text: "Alton Kastle" },
  { key: "16", text: "Amee" },
  { key: "17", text: "AP-5" },
  { key: "18", text: "Armitage Hux" },
  { key: "19", text: "Artoo" },
  { key: "20", text: "Arvel Crynyd" },
  { key: "21", text: "Asajj Ventress" },
  { key: "22", text: "Aurra Sing" },
  { key: "23", text: "AZI-3" },
  { key: "24", text: "Bala-Tik" },
  { key: "25", text: "Barada" },
  { key: "26", text: "Bargwill Tomder" },
  { key: "27", text: "Baron Papanoida" },
  { key: "28", text: "Barriss Offee" },
  { key: "29", text: "Baze Malbus" },
  { key: "30", text: "Bazine Netal" },
  { key: "31", text: "BB-8" },
  { key: "32", text: "BB-9E" },
  { key: "33", text: "Ben Quadinaros" },
  { key: "34", text: "Berch Teller" },
  { key: "35", text: "Beru Lars" },
  { key: "36", text: "Bib Fortuna" },
  {
    key: "37",
    text: "Biggs Darklighter",
  },
  { key: "38", text: "Black Krrsantan" },
  { key: "39", text: "Bo-Katan Kryze" },
  { key: "40", text: "Boba Fett" },
  { key: "41", text: "Bobbajo" },
  { key: "42", text: "Bodhi Rook" },
  { key: "43", text: "Borvo the Hutt" },
  { key: "44", text: "Boss Nass" },
  { key: "45", text: "Bossk" },
  {
    key: "46",
    text: "Breha Antilles-Organa",
  },
  { key: "47", text: "Bren Derlin" },
  { key: "48", text: "Brendol Hux" },
  { key: "49", text: "BT-1" },
];

// ========== FILE END: ui/elements/mention/mention-input-element.tsx ==========



// ========== FILE START: ui/elements/paragraph/paragraph-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps } from "@udecode/plate";

import { SlateElement } from "@udecode/plate";

import { cn } from "@/lib/utils";

export function ParagraphElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props} className={cn("m-0 px-0 py-1")}>
      {props.children}
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/paragraph/paragraph-element-static.tsx ==========



// ========== FILE START: ui/elements/paragraph/paragraph-element.tsx ==========
"use client";

import * as React from "react";

import type { PlateElementProps } from "@udecode/plate/react";

import { PlateElement } from "@udecode/plate/react";

import { cn } from "@/lib/utils";

export function ParagraphElement(props: PlateElementProps) {
  return (
    <PlateElement {...props} className={cn("m-0 px-0 py-1")}>
      {props.children}
    </PlateElement>
  );
}

// ========== FILE END: ui/elements/paragraph/paragraph-element.tsx ==========



// ========== FILE START: ui/elements/slash-input/slash-input-element.tsx ==========
"use client";

import * as React from "react";

import type { TSlashInputElement } from "@udecode/plate-slash-command";

import { AIChatPlugin } from "@udecode/plate-ai/react";
import { BlockquotePlugin } from "@udecode/plate-block-quote/react";
import { CalloutPlugin } from "@udecode/plate-callout/react";
import { CodeBlockPlugin } from "@udecode/plate-code-block/react";
import { DatePlugin } from "@udecode/plate-date/react";
import { HEADING_KEYS } from "@udecode/plate-heading";
import { TocPlugin } from "@udecode/plate-heading/react";
import { INDENT_LIST_KEYS, ListStyleType } from "@udecode/plate-indent-list";
import {
  EquationPlugin,
  InlineEquationPlugin,
} from "@udecode/plate-math/react";
import { TablePlugin } from "@udecode/plate-table/react";
import { TogglePlugin } from "@udecode/plate-toggle/react";
import {
  type PlateEditor,
  type PlateElementProps,
  ParagraphPlugin,
} from "@udecode/plate/react";
import { PlateElement } from "@udecode/plate/react";
import {
  CalendarIcon,
  ChevronRightIcon,
  Code2,
  Columns3Icon,
  Heading1Icon,
  Heading2Icon,
  Heading3Icon,
  LightbulbIcon,
  ListIcon,
  ListOrdered,
  PilcrowIcon,
  Quote,
  RadicalIcon,
  SparklesIcon,
  Square,
  Table,
  TableOfContentsIcon,
} from "lucide-react";

import { insertBlock, insertInlineElement } from "../../../core/transforms";

import {
  InlineCombobox,
  InlineComboboxContent,
  InlineComboboxEmpty,
  InlineComboboxGroup,
  InlineComboboxGroupLabel,
  InlineComboboxInput,
  InlineComboboxItem,
} from "../../menus/inline-combobox";

type Group = {
  group: string;
  items: Item[];
};

interface Item {
  icon: React.ReactNode;
  value: string;
  onSelect: (editor: PlateEditor, value: string) => void;
  className?: string;
  focusEditor?: boolean;
  keywords?: string[];
  label?: string;
}

const groups: Group[] = [
  {
    group: "AI",
    items: [
      {
        focusEditor: false,
        icon: <SparklesIcon />,
        value: "AI",
        onSelect: (editor) => {
          editor.getApi(AIChatPlugin).aiChat.show();
        },
      },
    ],
  },
  {
    group: "Basic blocks",
    items: [
      {
        icon: <PilcrowIcon />,
        keywords: ["paragraph"],
        label: "Text",
        value: ParagraphPlugin.key,
      },
      {
        icon: <Heading1Icon />,
        keywords: ["title", "h1"],
        label: "Heading 1",
        value: HEADING_KEYS.h1,
      },
      {
        icon: <Heading2Icon />,
        keywords: ["subtitle", "h2"],
        label: "Heading 2",
        value: HEADING_KEYS.h2,
      },
      {
        icon: <Heading3Icon />,
        keywords: ["subtitle", "h3"],
        label: "Heading 3",
        value: HEADING_KEYS.h3,
      },
      {
        icon: <ListIcon />,
        keywords: ["unordered", "ul", "-"],
        label: "Bulleted list",
        value: ListStyleType.Disc,
      },
      {
        icon: <ListOrdered />,
        keywords: ["ordered", "ol", "1"],
        label: "Numbered list",
        value: ListStyleType.Decimal,
      },
      {
        icon: <Square />,
        keywords: ["checklist", "task", "checkbox", "[]"],
        label: "To-do list",
        value: INDENT_LIST_KEYS.todo,
      },
      {
        icon: <ChevronRightIcon />,
        keywords: ["collapsible", "expandable"],
        label: "Toggle",
        value: TogglePlugin.key,
      },
      {
        icon: <Code2 />,
        keywords: ["```"],
        label: "Code Block",
        value: CodeBlockPlugin.key,
      },
      {
        icon: <Table />,
        label: "Table",
        value: TablePlugin.key,
      },
      {
        icon: <Quote />,
        keywords: ["citation", "blockquote", "quote", ">"],
        label: "Blockquote",
        value: BlockquotePlugin.key,
      },
      {
        description: "Insert a highlighted block.",
        icon: <LightbulbIcon />,
        keywords: ["note"],
        label: "Callout",
        value: CalloutPlugin.key,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Advanced blocks",
    items: [
      {
        icon: <TableOfContentsIcon />,
        keywords: ["toc"],
        label: "Table of contents",
        value: TocPlugin.key,
      },
      {
        icon: <Columns3Icon />,
        label: "3 columns",
        value: "action_three_columns",
      },
      {
        focusEditor: false,
        icon: <RadicalIcon />,
        label: "Equation",
        value: EquationPlugin.key,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Inline",
    items: [
      {
        focusEditor: true,
        icon: <CalendarIcon />,
        keywords: ["time"],
        label: "Date",
        value: DatePlugin.key,
      },
      {
        focusEditor: false,
        icon: <RadicalIcon />,
        label: "Inline Equation",
        value: InlineEquationPlugin.key,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertInlineElement(editor, value);
      },
    })),
  },
];

export function SlashInputElement(
  props: PlateElementProps<TSlashInputElement>,
) {
  const { editor, element } = props;

  return (
    <PlateElement {...props} as="span" data-slate-value={element.value}>
      <InlineCombobox element={element} trigger="/">
        <InlineComboboxInput />

        <InlineComboboxContent>
          <InlineComboboxEmpty>No results</InlineComboboxEmpty>

          {groups.map(({ group, items }) => (
            <InlineComboboxGroup key={group}>
              <InlineComboboxGroupLabel>{group}</InlineComboboxGroupLabel>

              {items.map(
                ({ focusEditor, icon, keywords, label, value, onSelect }) => (
                  <InlineComboboxItem
                    key={value}
                    value={value}
                    onClick={() => onSelect(editor, value)}
                    label={label}
                    focusEditor={focusEditor}
                    group={group}
                    keywords={keywords}
                  >
                    <div className="mr-2 text-muted-foreground">{icon}</div>
                    {label ?? value}
                  </InlineComboboxItem>
                ),
              )}
            </InlineComboboxGroup>
          ))}
        </InlineComboboxContent>
      </InlineCombobox>

      {props.children}
    </PlateElement>
  );
}

// ========== FILE END: ui/elements/slash-input/slash-input-element.tsx ==========



// ========== FILE START: ui/elements/table/table-cell-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps } from "@udecode/plate";
import type { TTableCellElement } from "@udecode/plate-table";

import { SlateElement } from "@udecode/plate";
import { BaseTablePlugin } from "@udecode/plate-table";

import { cn } from "@/lib/utils";

export function TableCellElementStatic({
  isHeader,
  ...props
}: SlateElementProps<TTableCellElement> & {
  isHeader?: boolean;
}) {
  const { editor, element } = props;
  const { api } = editor.getPlugin(BaseTablePlugin);

  const { minHeight, width } = api.table.getCellSize({ element });
  const borders = api.table.getCellBorders({ element });

  return (
    <SlateElement
      {...props}
      as={isHeader ? "th" : "td"}
      className={cn(
        "h-full overflow-visible border-none bg-background p-0",
        element.background ? "bg-(--cellBackground)" : "bg-background",
        isHeader && "text-left font-normal *:m-0",
        "before:size-full",
        "before:absolute before:box-border before:content-[''] before:select-none",
        borders &&
          cn(
            borders.bottom?.size && `before:border-b before:border-b-border`,
            borders.right?.size && `before:border-r before:border-r-border`,
            borders.left?.size && `before:border-l before:border-l-border`,
            borders.top?.size && `before:border-t before:border-t-border`,
          ),
      )}
      style={
        {
          "--cellBackground": element.background,
          maxWidth: width || 240,
          minWidth: width || 120,
        } as React.CSSProperties
      }
      attributes={{
        ...props.attributes,
        colSpan: api.table.getColSpan(element),
        rowSpan: api.table.getRowSpan(element),
      }}
    >
      <div
        className="relative z-20 box-border h-full px-4 py-2"
        style={{ minHeight }}
      >
        {props.children}
      </div>
    </SlateElement>
  );
}

export function TableCellHeaderStaticElement(
  props: SlateElementProps<TTableCellElement>,
) {
  return <TableCellElementStatic {...props} isHeader />;
}

// ========== FILE END: ui/elements/table/table-cell-element-static.tsx ==========



// ========== FILE START: ui/elements/table/table-cell-element.tsx ==========
"use client";

import * as React from "react";

import type { TTableCellElement } from "@udecode/plate-table";
import type { PlateElementProps } from "@udecode/plate/react";

import {
  BlockSelectionPlugin,
  useBlockSelected,
} from "@udecode/plate-selection/react";
import {
  TablePlugin,
  TableRowPlugin,
  useTableCellElement,
  useTableCellElementResizable,
} from "@udecode/plate-table/react";
import {
  PlateElement,
  useEditorPlugin,
  useElementSelector,
  usePluginOption,
  useReadOnly,
} from "@udecode/plate/react";
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils";

import { blockSelectionVariants } from "../../primitives/block-selection";
import { ResizeHandle } from "../../primitives/resize-handle";

export function TableCellElement({
  isHeader,
  ...props
}: PlateElementProps<TTableCellElement> & {
  isHeader?: boolean;
}) {
  const { api } = useEditorPlugin(TablePlugin);
  const readOnly = useReadOnly();
  const element = props.element;

  const rowId = useElementSelector(([node]) => node.id as string, [], {
    key: TableRowPlugin.key,
  });
  const isSelectingRow = useBlockSelected(rowId);
  const isSelectionAreaVisible = usePluginOption(
    BlockSelectionPlugin,
    "isSelectionAreaVisible",
  );

  const { borders, colIndex, colSpan, minHeight, rowIndex, selected, width } =
    useTableCellElement();

  const { bottomProps, hiddenLeft, leftProps, rightProps } =
    useTableCellElementResizable({
      colIndex,
      colSpan,
      rowIndex,
    });

  return (
    <PlateElement
      {...props}
      as={isHeader ? "th" : "td"}
      className={cn(
        "h-full overflow-visible border-none bg-background p-0",
        element.background ? "bg-(--cellBackground)" : "bg-background",
        isHeader && "text-left *:m-0",
        "before:size-full",
        selected && "before:z-10 before:bg-brand/5",
        "before:absolute before:box-border before:content-[''] before:select-none",
        borders.bottom?.size && `before:border-b before:border-b-border`,
        borders.right?.size && `before:border-r before:border-r-border`,
        borders.left?.size && `before:border-l before:border-l-border`,
        borders.top?.size && `before:border-t before:border-t-border`,
      )}
      style={
        {
          "--cellBackground": element.background,
          maxWidth: width || 240,
          minWidth: width || 120,
        } as React.CSSProperties
      }
      attributes={{
        ...props.attributes,
        colSpan: api.table.getColSpan(element),
        rowSpan: api.table.getRowSpan(element),
      }}
    >
      <div
        className="relative z-20 box-border h-full px-3 py-2"
        style={{ minHeight }}
      >
        {props.children}
      </div>

      {!isSelectionAreaVisible && (
        <div
          className="group absolute top-0 size-full select-none"
          contentEditable={false}
          suppressContentEditableWarning={true}
        >
          {!readOnly && (
            <>
              <ResizeHandle
                {...rightProps}
                className="-top-2 -right-1 h-[calc(100%_+_8px)] w-2"
                data-col={colIndex}
              />
              <ResizeHandle {...bottomProps} className="-bottom-1 h-2" />
              {!hiddenLeft && (
                <ResizeHandle
                  {...leftProps}
                  className="top-0 -left-1 w-2"
                  data-resizer-left={colIndex === 0 ? "true" : undefined}
                />
              )}

              <div
                className={cn(
                  "absolute top-0 z-30 hidden h-full w-1 bg-ring",
                  "right-[-1.5px]",
                  columnResizeVariants({ colIndex: colIndex as any }),
                )}
              />
              {colIndex === 0 && (
                <div
                  className={cn(
                    "absolute top-0 z-30 h-full w-1 bg-ring",
                    "left-[-1.5px]",
                    'hidden animate-in fade-in group-has-[[data-resizer-left]:hover]/table:block group-has-[[data-resizer-left][data-resizing="true"]]/table:block',
                  )}
                />
              )}
            </>
          )}
        </div>
      )}

      {isSelectingRow && (
        <div className={blockSelectionVariants()} contentEditable={false} />
      )}
    </PlateElement>
  );
}

export function TableCellHeaderElement(
  props: React.ComponentProps<typeof TableCellElement>,
) {
  return <TableCellElement {...props} isHeader />;
}

const columnResizeVariants = cva("hidden animate-in fade-in", {
  variants: {
    colIndex: {
      0: 'group-has-[[data-col="0"]:hover]/table:block group-has-[[data-col="0"][data-resizing="true"]]/table:block',
      1: 'group-has-[[data-col="1"]:hover]/table:block group-has-[[data-col="1"][data-resizing="true"]]/table:block',
      2: 'group-has-[[data-col="2"]:hover]/table:block group-has-[[data-col="2"][data-resizing="true"]]/table:block',
      3: 'group-has-[[data-col="3"]:hover]/table:block group-has-[[data-col="3"][data-resizing="true"]]/table:block',
      4: 'group-has-[[data-col="4"]:hover]/table:block group-has-[[data-col="4"][data-resizing="true"]]/table:block',
      5: 'group-has-[[data-col="5"]:hover]/table:block group-has-[[data-col="5"][data-resizing="true"]]/table:block',
      6: 'group-has-[[data-col="6"]:hover]/table:block group-has-[[data-col="6"][data-resizing="true"]]/table:block',
      7: 'group-has-[[data-col="7"]:hover]/table:block group-has-[[data-col="7"][data-resizing="true"]]/table:block',
      8: 'group-has-[[data-col="8"]:hover]/table:block group-has-[[data-col="8"][data-resizing="true"]]/table:block',
      9: 'group-has-[[data-col="9"]:hover]/table:block group-has-[[data-col="9"][data-resizing="true"]]/table:block',
      10: 'group-has-[[data-col="10"]:hover]/table:block group-has-[[data-col="10"][data-resizing="true"]]/table:block',
    },
  },
});

// ========== FILE END: ui/elements/table/table-cell-element.tsx ==========



// ========== FILE START: ui/elements/table/table-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps } from "@udecode/plate";
import type { TTableElement } from "@udecode/plate-table";

import { SlateElement } from "@udecode/plate";
import { BaseTablePlugin } from "@udecode/plate-table";

export function TableElementStatic({
  children,
  ...props
}: SlateElementProps<TTableElement>) {
  const { disableMarginLeft } = props.editor.getOptions(BaseTablePlugin);
  const marginLeft = disableMarginLeft ? 0 : props.element.marginLeft;

  return (
    <SlateElement
      {...props}
      className="overflow-x-auto py-5"
      style={{ paddingLeft: marginLeft }}
    >
      <div className="group/table relative w-fit">
        <table className="mr-0 ml-px table h-px table-fixed border-collapse">
          <tbody className="min-w-full">{children}</tbody>
        </table>
      </div>
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/table/table-element-static.tsx ==========



// ========== FILE START: ui/elements/table/table-element.tsx ==========
"use client";

import * as React from "react";

import type * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import type { TTableElement } from "@udecode/plate-table";

import { PopoverAnchor } from "@radix-ui/react-popover";
import { BlockSelectionPlugin } from "@udecode/plate-selection/react";
import { setCellBackground } from "@udecode/plate-table";
import {
  TablePlugin,
  TableProvider,
  useTableBordersDropdownMenuContentState,
  useTableElement,
  useTableMergeState,
} from "@udecode/plate-table/react";
import {
  type PlateElementProps,
  PlateElement,
  useEditorPlugin,
  useEditorRef,
  useEditorSelector,
  useElement,
  usePluginOption,
  useReadOnly,
  useRemoveNodeButton,
  useSelected,
  withHOC,
} from "@udecode/plate/react";
import {
  ArrowDown,
  ArrowLeft,
  ArrowRight,
  ArrowUp,
  CombineIcon,
  EraserIcon,
  Grid2X2Icon,
  PaintBucketIcon,
  SquareSplitHorizontalIcon,
  Trash2Icon,
  XIcon,
} from "lucide-react";

import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuPortal,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Popover, PopoverContent } from "@/components/ui/popover";
import { cn } from "@/lib/utils";

import { DEFAULT_COLORS } from "../../../constants/color-constants";
import { ColorDropdownMenuItems } from "../../primitives/color-picker/color-dropdown-menu-items";
import {
  Toolbar,
  ToolbarButton,
  ToolbarGroup,
  ToolbarMenuGroup,
} from "../../menus/toolbars/toolbar";
import {
  BorderAll,
  BorderBottom,
  BorderLeft,
  BorderNone,
  BorderRight,
  BorderTop,
} from "../../../constants/table-icons";

export const TableElement = withHOC(
  TableProvider,
  function TableElement({
    children,
    ...props
  }: PlateElementProps<TTableElement>) {
    const readOnly = useReadOnly();
    const isSelectionAreaVisible = usePluginOption(
      BlockSelectionPlugin,
      "isSelectionAreaVisible",
    );
    const hasControls = !readOnly && !isSelectionAreaVisible;
    const selected = useSelected();
    const {
      isSelectingCell,
      marginLeft,
      props: tableProps,
    } = useTableElement();

    const content = (
      <PlateElement
        {...props}
        className={cn(
          "overflow-x-auto py-5",
          hasControls && "-ml-2 *:data-[slot=block-selection]:left-2",
        )}
        style={{ paddingLeft: marginLeft }}
      >
        <div className="group/table relative w-fit">
          <table
            className={cn(
              "mr-0 ml-px table h-px table-fixed border-collapse",
              isSelectingCell && "selection:bg-transparent",
            )}
            {...tableProps}
          >
            <tbody className="min-w-full">{children}</tbody>
          </table>
        </div>
      </PlateElement>
    );

    if (readOnly || !selected) {
      return content;
    }

    return <TableFloatingToolbar>{content}</TableFloatingToolbar>;
  },
);

export function TableFloatingToolbar({
  children,
  ...props
}: React.ComponentProps<typeof PopoverContent>) {
  const { tf } = useEditorPlugin(TablePlugin);
  const element = useElement<TTableElement>();
  const { props: buttonProps } = useRemoveNodeButton({ element });
  const collapsed = useEditorSelector((editor) => !editor.api.isExpanded(), []);

  const { canMerge, canSplit } = useTableMergeState();

  return (
    <Popover open={canMerge || canSplit || collapsed} modal={false}>
      <PopoverAnchor asChild>{children}</PopoverAnchor>
      <PopoverContent
        asChild
        onOpenAutoFocus={(e) => e.preventDefault()}
        contentEditable={false}
        {...props}
      >
        <Toolbar
          className="scrollbar-hide flex w-auto max-w-[80vw] flex-row overflow-x-auto rounded-md border bg-popover p-1 shadow-md print:hidden"
          contentEditable={false}
        >
          <ToolbarGroup>
            <ColorDropdownMenu tooltip="Background color">
              <PaintBucketIcon />
            </ColorDropdownMenu>
            {canMerge && (
              <ToolbarButton
                onClick={() => tf.table.merge()}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Merge cells"
              >
                <CombineIcon />
              </ToolbarButton>
            )}
            {canSplit && (
              <ToolbarButton
                onClick={() => tf.table.split()}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Split cell"
              >
                <SquareSplitHorizontalIcon />
              </ToolbarButton>
            )}

            <DropdownMenu modal={false}>
              <DropdownMenuTrigger asChild>
                <ToolbarButton tooltip="Cell borders">
                  <Grid2X2Icon />
                </ToolbarButton>
              </DropdownMenuTrigger>

              <DropdownMenuPortal>
                <TableBordersDropdownMenuContent />
              </DropdownMenuPortal>
            </DropdownMenu>

            {collapsed && (
              <ToolbarGroup>
                <ToolbarButton tooltip="Delete table" {...buttonProps}>
                  <Trash2Icon />
                </ToolbarButton>
              </ToolbarGroup>
            )}
          </ToolbarGroup>

          {collapsed && (
            <ToolbarGroup>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableRow({ before: true });
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert row before"
              >
                <ArrowUp />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableRow();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert row after"
              >
                <ArrowDown />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.remove.tableRow();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Delete row"
              >
                <XIcon />
              </ToolbarButton>
            </ToolbarGroup>
          )}

          {collapsed && (
            <ToolbarGroup>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableColumn({ before: true });
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert column before"
              >
                <ArrowLeft />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableColumn();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert column after"
              >
                <ArrowRight />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.remove.tableColumn();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Delete column"
              >
                <XIcon />
              </ToolbarButton>
            </ToolbarGroup>
          )}
        </Toolbar>
      </PopoverContent>
    </Popover>
  );
}

export function TableBordersDropdownMenuContent(
  props: React.ComponentProps<typeof DropdownMenuPrimitive.Content>,
) {
  const editor = useEditorRef();
  const {
    getOnSelectTableBorder,
    hasBottomBorder,
    hasLeftBorder,
    hasNoBorders,
    hasOuterBorders,
    hasRightBorder,
    hasTopBorder,
  } = useTableBordersDropdownMenuContentState();

  return (
    <DropdownMenuContent
      className="min-w-[220px]"
      onCloseAutoFocus={(e) => {
        e.preventDefault();
        editor.tf.focus();
      }}
      align="start"
      side="right"
      sideOffset={0}
      {...props}
    >
      <DropdownMenuGroup>
        <DropdownMenuCheckboxItem
          checked={hasTopBorder}
          onCheckedChange={getOnSelectTableBorder("top")}
        >
          <BorderTop />
          <div>Top Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasRightBorder}
          onCheckedChange={getOnSelectTableBorder("right")}
        >
          <BorderRight />
          <div>Right Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasBottomBorder}
          onCheckedChange={getOnSelectTableBorder("bottom")}
        >
          <BorderBottom />
          <div>Bottom Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasLeftBorder}
          onCheckedChange={getOnSelectTableBorder("left")}
        >
          <BorderLeft />
          <div>Left Border</div>
        </DropdownMenuCheckboxItem>
      </DropdownMenuGroup>

      <DropdownMenuGroup>
        <DropdownMenuCheckboxItem
          checked={hasNoBorders}
          onCheckedChange={getOnSelectTableBorder("none")}
        >
          <BorderNone />
          <div>No Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasOuterBorders}
          onCheckedChange={getOnSelectTableBorder("outer")}
        >
          <BorderAll />
          <div>Outside Borders</div>
        </DropdownMenuCheckboxItem>
      </DropdownMenuGroup>
    </DropdownMenuContent>
  );
}

type ColorDropdownMenuProps = {
  children: React.ReactNode;
  tooltip: string;
};

function ColorDropdownMenu({ children, tooltip }: ColorDropdownMenuProps) {
  const [open, setOpen] = React.useState(false);
  const editor = useEditorRef();
  const selectedCells = usePluginOption(TablePlugin, "selectedCells");

  const onUpdateColor = React.useCallback(
    (color: string) => {
      setOpen(false);
      setCellBackground(editor, { color, selectedCells: selectedCells ?? [] });
    },
    [selectedCells, editor],
  );

  const onClearColor = React.useCallback(() => {
    setOpen(false);
    setCellBackground(editor, {
      color: null,
      selectedCells: selectedCells ?? [],
    });
  }, [selectedCells, editor]);

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton tooltip={tooltip}>{children}</ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="start">
        <ToolbarMenuGroup label="Colors">
          <ColorDropdownMenuItems
            colors={DEFAULT_COLORS}
            updateColor={onUpdateColor}
          />
        </ToolbarMenuGroup>
        <DropdownMenuGroup>
          <DropdownMenuItem className="p-2" onClick={onClearColor}>
            <EraserIcon />
            <span>Clear</span>
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

// ========== FILE END: ui/elements/table/table-element.tsx ==========



// ========== FILE START: ui/elements/table/table-row-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps } from "@udecode/plate";

import { SlateElement } from "@udecode/plate";

export function TableRowElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props} as="tr" className="h-full">
      {props.children}
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/table/table-row-element-static.tsx ==========



// ========== FILE START: ui/elements/table/table-row-element.tsx ==========
"use client";

import * as React from "react";

import type { TTableRowElement } from "@udecode/plate-table";

import { useComposedRef } from "@udecode/cn";
import { type TElement, PathApi } from "@udecode/plate";
import { useDraggable, useDropLine } from "@udecode/plate-dnd";
import { BlockSelectionPlugin } from "@udecode/plate-selection/react";
import {
  type PlateElementProps,
  PlateElement,
  useEditorRef,
  useElement,
  usePluginOption,
  useReadOnly,
  useSelected,
} from "@udecode/plate/react";
import { GripVertical } from "lucide-react";

import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

export function TableRowElement(props: PlateElementProps<TTableRowElement>) {
  const { element } = props;
  const readOnly = useReadOnly();
  const selected = useSelected();
  const editor = useEditorRef();
  const isSelectionAreaVisible = usePluginOption(
    BlockSelectionPlugin,
    "isSelectionAreaVisible",
  );
  const hasControls = !readOnly && !isSelectionAreaVisible;

  const { isDragging, previewRef, handleRef } = useDraggable({
    element,
    type: element.type,
    canDropNode: ({ dragEntry, dropEntry }) =>
      PathApi.equals(
        PathApi.parent(dragEntry[1]),
        PathApi.parent(dropEntry[1]),
      ),
    onDropHandler: (_, { dragItem }) => {
      const dragElement = (dragItem as { element: TElement }).element;

      if (dragElement) {
        editor.tf.select(dragElement);
      }
    },
  });

  return (
    <PlateElement
      {...props}
      ref={useComposedRef(props.ref, previewRef)}
      as="tr"
      className={cn("group/row", isDragging && "opacity-50")}
      attributes={{
        ...props.attributes,
        "data-selected": selected ? "true" : undefined,
      }}
    >
      {hasControls && (
        <td className="w-2 select-none" contentEditable={false}>
          <RowDragHandle dragRef={handleRef} />
          <DropLine />
        </td>
      )}

      {props.children}
    </PlateElement>
  );
}

function RowDragHandle({ dragRef }: { dragRef: React.Ref<any> }) {
  const editor = useEditorRef();
  const element = useElement();

  return (
    <Button
      ref={dragRef}
      variant="outline"
      className={cn(
        "absolute top-1/2 left-0 z-51 h-6 w-4 -translate-y-1/2 p-0 focus-visible:ring-0 focus-visible:ring-offset-0",
        "cursor-grab active:cursor-grabbing",
        'opacity-0 transition-opacity duration-100 group-hover/row:opacity-100 group-has-data-[resizing="true"]/row:opacity-0',
      )}
      onClick={() => {
        editor.tf.select(element);
      }}
    >
      <GripVertical className="text-muted-foreground" />
    </Button>
  );
}

function DropLine() {
  const { dropLine } = useDropLine();

  if (!dropLine) return null;

  return (
    <div
      className={cn(
        "absolute inset-x-0 left-2 z-50 h-0.5 bg-brand/50",
        dropLine === "top" ? "-top-px" : "-bottom-px",
      )}
    />
  );
}

// ========== FILE END: ui/elements/table/table-row-element.tsx ==========



// ========== FILE START: ui/elements/toc/toc-element-static.tsx ==========
import * as React from "react";

import type { SlateEditor, SlateElementProps, TElement } from "@udecode/plate";

import { NodeApi, SlateElement } from "@udecode/plate";
import {
  type Heading,
  BaseTocPlugin,
  HEADING_KEYS,
  isHeading,
} from "@udecode/plate-heading";
import { cva } from "class-variance-authority";

import { Button } from "@/components/ui/button";

const headingItemVariants = cva(
  "block h-auto w-full cursor-pointer truncate rounded-none px-0.5 py-1.5 text-left font-medium text-muted-foreground underline decoration-[0.5px] underline-offset-4 hover:bg-accent hover:text-muted-foreground",
  {
    variants: {
      depth: {
        1: "pl-0.5",
        2: "pl-[26px]",
        3: "pl-[50px]",
      },
    },
  },
);

export function TocElementStatic(props: SlateElementProps) {
  const { editor } = props;
  const headingList = getHeadingList(editor);

  return (
    <SlateElement {...props} className="mb-1 p-0">
      <div>
        {headingList.length > 0 ? (
          headingList.map((item) => (
            <Button
              key={item.title}
              variant="ghost"
              className={headingItemVariants({
                depth: item.depth as 1 | 2 | 3,
              })}
            >
              {item.title}
            </Button>
          ))
        ) : (
          <div className="text-sm text-gray-500">
            Create a heading to display the table of contents.
          </div>
        )}
      </div>
      {props.children}
    </SlateElement>
  );
}

const headingDepth: Record<string, number> = {
  [HEADING_KEYS.h1]: 1,
  [HEADING_KEYS.h2]: 2,
  [HEADING_KEYS.h3]: 3,
  [HEADING_KEYS.h4]: 4,
  [HEADING_KEYS.h5]: 5,
  [HEADING_KEYS.h6]: 6,
};

const getHeadingList = (editor?: SlateEditor) => {
  if (!editor) return [];

  const options = editor.getOptions(BaseTocPlugin);

  if (options.queryHeading) {
    return options.queryHeading(editor);
  }

  const headingList: Heading[] = [];

  const values = editor.api.nodes<TElement>({
    at: [],
    match: (n) => isHeading(n),
  });

  if (!values) return [];

  Array.from(values, ([node, path]) => {
    const { type } = node;
    const title = NodeApi.string(node);
    const depth = headingDepth[type];
    const id = node.id as string;

    if (title) {
      headingList.push({ id, depth, path, title, type });
    }
  });

  return headingList;
};

// ========== FILE END: ui/elements/toc/toc-element-static.tsx ==========



// ========== FILE START: ui/elements/toc/toc-element.tsx ==========
"use client";

import * as React from "react";

import type { PlateElementProps } from "@udecode/plate/react";

import {
  useTocElement,
  useTocElementState,
} from "@udecode/plate-heading/react";
import { PlateElement } from "@udecode/plate/react";
import { cva } from "class-variance-authority";

import { Button } from "@/components/ui/button";

const headingItemVariants = cva(
  "block h-auto w-full cursor-pointer truncate rounded-none px-0.5 py-1.5 text-left font-medium text-muted-foreground underline decoration-[0.5px] underline-offset-4 hover:bg-accent hover:text-muted-foreground",
  {
    variants: {
      depth: {
        1: "pl-0.5",
        2: "pl-[26px]",
        3: "pl-[50px]",
      },
    },
  },
);

export function TocElement(props: PlateElementProps) {
  const state = useTocElementState();
  const { props: btnProps } = useTocElement(state);
  const { headingList } = state;

  return (
    <PlateElement {...props} className="mb-1 p-0">
      <div contentEditable={false}>
        {headingList.length > 0 ? (
          headingList.map((item) => (
            <Button
              key={item.id}
              variant="ghost"
              className={headingItemVariants({
                depth: item.depth as 1 | 2 | 3,
              })}
              onClick={(e) => btnProps.onClick(e, item, "smooth")}
              aria-current
            >
              {item.title}
            </Button>
          ))
        ) : (
          <div className="text-sm text-gray-500">
            Create a heading to display the table of contents.
          </div>
        )}
      </div>
      {props.children}
    </PlateElement>
  );
}

// ========== FILE END: ui/elements/toc/toc-element.tsx ==========



// ========== FILE START: ui/elements/toggle/toggle-element-static.tsx ==========
import * as React from "react";

import type { SlateElementProps } from "@udecode/plate";

import { SlateElement } from "@udecode/plate";
import { ChevronRight } from "lucide-react";

export function ToggleElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props} className="pl-6">
      <div
        className="absolute top-0 -left-0.5 size-6 cursor-pointer items-center justify-center rounded-md p-px text-muted-foreground transition-colors select-none hover:bg-accent [&_svg]:size-4"
        contentEditable={false}
      >
        <ChevronRight className="rotate-0 transition-transform duration-75" />
      </div>
      {props.children}
    </SlateElement>
  );
}

// ========== FILE END: ui/elements/toggle/toggle-element-static.tsx ==========



// ========== FILE START: ui/elements/toggle/toggle-element.tsx ==========
"use client";

import * as React from "react";

import type { PlateElementProps } from "@udecode/plate/react";

import {
  useToggleButton,
  useToggleButtonState,
} from "@udecode/plate-toggle/react";
import { PlateElement } from "@udecode/plate/react";
import { ChevronRight } from "lucide-react";

import { Button } from "@/components/ui/button";

export function ToggleElement(props: PlateElementProps) {
  const element = props.element;
  const state = useToggleButtonState(element.id as string);
  const { buttonProps, open } = useToggleButton(state);

  return (
    <PlateElement {...props} className="pl-6">
      <Button
        size="icon"
        variant="ghost"
        className="absolute top-0 -left-0.5 size-6 cursor-pointer items-center justify-center rounded-md p-px text-muted-foreground transition-colors select-none hover:bg-accent [&_svg]:size-4"
        contentEditable={false}
        {...buttonProps}
      >
        <ChevronRight
          className={
            open
              ? "rotate-90 transition-transform duration-75"
              : "rotate-0 transition-transform duration-75"
          }
        />
      </Button>
      {props.children}
    </PlateElement>
  );
}

// ========== FILE END: ui/elements/toggle/toggle-element.tsx ==========



// ========== FILE START: ui/menus/ai/ai-menu-items.tsx ==========
"use client";

import * as React from "react";

import { type SlateEditor, NodeApi } from "@udecode/plate";
import { AIChatPlugin, AIPlugin } from "@udecode/plate-ai/react";
import { useIsSelecting } from "@udecode/plate-selection/react";
import {
  type PlateEditor,
  useEditorRef,
  usePluginOption,
} from "@udecode/plate/react";
import {
  Album,
  BadgeHelp,
  BookOpenCheck,
  Check,
  CornerUpLeft,
  FeatherIcon,
  ListEnd,
  ListMinus,
  ListPlus,
  PenLine,
  SmileIcon,
  Wand,
  X,
} from "lucide-react";

import { CommandGroup, CommandItem } from "@/components/ui/command";

export type EditorChatState =
  | "cursorCommand"
  | "cursorSuggestion"
  | "selectionCommand"
  | "selectionSuggestion";

export const aiChatItems = {
  accept: {
    icon: <Check />,
    label: "Accept",
    value: "accept",
    onSelect: ({ editor }) => {
      editor.getTransforms(AIChatPlugin).aiChat.accept();
      editor.tf.focus({ edge: "end" });
    },
  },
  continueWrite: {
    icon: <PenLine />,
    label: "Continue writing",
    value: "continueWrite",
    onSelect: ({ editor }) => {
      const ancestorNode = editor.api.block({ highest: true });

      if (!ancestorNode) return;

      const isEmpty = NodeApi.string(ancestorNode[0]).trim().length === 0;

      void editor.getApi(AIChatPlugin).aiChat.submit({
        mode: "insert",
        prompt: isEmpty
          ? `<Document>
{editor}
</Document>
Start writing a new paragraph AFTER <Document> ONLY ONE SENTENCE`
          : "Continue writing AFTER <Block> ONLY ONE SENTENCE. DONT REPEAT THE TEXT.",
      });
    },
  },
  discard: {
    icon: <X />,
    label: "Discard",
    shortcut: "Escape",
    value: "discard",
    onSelect: ({ editor }) => {
      editor.getTransforms(AIPlugin).ai.undo();
      editor.getApi(AIChatPlugin).aiChat.hide();
    },
  },
  emojify: {
    icon: <SmileIcon />,
    label: "Emojify",
    value: "emojify",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Emojify",
      });
    },
  },
  explain: {
    icon: <BadgeHelp />,
    label: "Explain",
    value: "explain",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: {
          default: "Explain {editor}",
          selecting: "Explain",
        },
      });
    },
  },
  fixSpelling: {
    icon: <Check />,
    label: "Fix spelling & grammar",
    value: "fixSpelling",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Fix spelling and grammar",
      });
    },
  },
  generateMarkdownSample: {
    icon: <BookOpenCheck />,
    label: "Generate Markdown sample",
    value: "generateMarkdownSample",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Generate a markdown sample",
      });
    },
  },
  generateMdxSample: {
    icon: <BookOpenCheck />,
    label: "Generate MDX sample",
    value: "generateMdxSample",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Generate a mdx sample",
      });
    },
  },
  improveWriting: {
    icon: <Wand />,
    label: "Improve writing",
    value: "improveWriting",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Improve the writing",
      });
    },
  },
  insertBelow: {
    icon: <ListEnd />,
    label: "Insert below",
    value: "insertBelow",
    onSelect: ({ aiEditor, editor }) => {
      void editor.getTransforms(AIChatPlugin).aiChat.insertBelow(aiEditor);
    },
  },
  makeLonger: {
    icon: <ListPlus />,
    label: "Make longer",
    value: "makeLonger",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Make longer",
      });
    },
  },
  makeShorter: {
    icon: <ListMinus />,
    label: "Make shorter",
    value: "makeShorter",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Make shorter",
      });
    },
  },
  replace: {
    icon: <Check />,
    label: "Replace selection",
    value: "replace",
    onSelect: ({ aiEditor, editor }) => {
      void editor.getTransforms(AIChatPlugin).aiChat.replaceSelection(aiEditor);
    },
  },
  simplifyLanguage: {
    icon: <FeatherIcon />,
    label: "Simplify language",
    value: "simplifyLanguage",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Simplify the language",
      });
    },
  },
  summarize: {
    icon: <Album />,
    label: "Add a summary",
    value: "summarize",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        mode: "insert",
        prompt: {
          default: "Summarize {editor}",
          selecting: "Summarize",
        },
      });
    },
  },
  tryAgain: {
    icon: <CornerUpLeft />,
    label: "Try again",
    value: "tryAgain",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.reload();
    },
  },
} satisfies Record<
  string,
  {
    icon: React.ReactNode;
    label: string;
    value: string;
    component?: React.ComponentType<{ menuState: EditorChatState }>;
    filterItems?: boolean;
    items?: { label: string; value: string }[];
    shortcut?: string;
    onSelect?: ({
      aiEditor,
      editor,
    }: {
      aiEditor: SlateEditor;
      editor: PlateEditor;
    }) => void;
  }
>;

const menuStateItems: Record<
  EditorChatState,
  {
    items: (typeof aiChatItems)[keyof typeof aiChatItems][];
    heading?: string;
  }[]
> = {
  cursorCommand: [
    {
      items: [
        aiChatItems.generateMdxSample,
        aiChatItems.generateMarkdownSample,
        aiChatItems.continueWrite,
        aiChatItems.summarize,
        aiChatItems.explain,
      ],
    },
  ],
  cursorSuggestion: [
    {
      items: [aiChatItems.accept, aiChatItems.discard, aiChatItems.tryAgain],
    },
  ],
  selectionCommand: [
    {
      items: [
        aiChatItems.improveWriting,
        aiChatItems.emojify,
        aiChatItems.makeLonger,
        aiChatItems.makeShorter,
        aiChatItems.fixSpelling,
        aiChatItems.simplifyLanguage,
      ],
    },
  ],
  selectionSuggestion: [
    {
      items: [
        aiChatItems.replace,
        aiChatItems.insertBelow,
        aiChatItems.discard,
        aiChatItems.tryAgain,
      ],
    },
  ],
};

export const AIMenuItems = ({
  setValue,
}: {
  setValue: (value: string) => void;
}) => {
  const editor = useEditorRef();
  const { messages } = usePluginOption(AIChatPlugin, "chat");
  const aiEditor = usePluginOption(AIChatPlugin, "aiEditor")!;
  const isSelecting = useIsSelecting();

  const menuState = React.useMemo(() => {
    if (messages && messages.length > 0) {
      return isSelecting ? "selectionSuggestion" : "cursorSuggestion";
    }

    return isSelecting ? "selectionCommand" : "cursorCommand";
  }, [isSelecting, messages]);

  const menuGroups = React.useMemo(() => {
    const items = menuStateItems[menuState];

    return items;
  }, [menuState]);

  React.useEffect(() => {
    if (menuGroups.length > 0 && menuGroups[0].items.length > 0) {
      setValue(menuGroups[0].items[0].value);
    }
  }, [menuGroups, setValue]);

  return (
    <>
      {menuGroups.map((group, index) => (
        <CommandGroup key={index} heading={group.heading}>
          {group.items.map((menuItem) => (
            <CommandItem
              key={menuItem.value}
              className="[&_svg]:text-muted-foreground"
              value={menuItem.value}
              onSelect={() => {
                menuItem.onSelect?.({
                  aiEditor,
                  editor: editor,
                });
              }}
            >
              {menuItem.icon}
              <span>{menuItem.label}</span>
            </CommandItem>
          ))}
        </CommandGroup>
      ))}
    </>
  );
};

// ========== FILE END: ui/menus/ai/ai-menu-items.tsx ==========



// ========== FILE START: ui/menus/ai/ai-menu.tsx ==========
"use client";

import * as React from "react";

import { type NodeEntry, isHotkey } from "@udecode/plate";
import {
  AIChatPlugin,
  useEditorChat,
  useLastAssistantMessage,
} from "@udecode/plate-ai/react";
import {
  BlockSelectionPlugin,
  useIsSelecting,
} from "@udecode/plate-selection/react";
import {
  useEditorPlugin,
  useHotkeys,
  usePluginOption,
} from "@udecode/plate/react";
import { Command as CommandPrimitive } from "cmdk";
import { Loader2Icon } from "lucide-react";

import { Command, CommandList } from "@/components/ui/command";
import {
  Popover,
  PopoverAnchor,
  PopoverContent,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";
import { useChat } from "../../../core/use-chat";

import { AIChatEditor } from "../../elements/ai/ai-chat-editor";
import { AIMenuItems } from "./ai-menu-items";

export function AIMenu() {
  const { api, editor } = useEditorPlugin(AIChatPlugin);
  const open = usePluginOption(AIChatPlugin, "open");
  const mode = usePluginOption(AIChatPlugin, "mode");
  const streaming = usePluginOption(AIChatPlugin, "streaming");
  const isSelecting = useIsSelecting();

  const [value, setValue] = React.useState("");

  const chat = useChat();

  const { input, messages, setInput, status } = chat;
  const [anchorElement, setAnchorElement] = React.useState<HTMLElement | null>(
    null,
  );

  const content = useLastAssistantMessage()?.content;

  React.useEffect(() => {
    if (streaming) {
      const anchor = api.aiChat.node({ anchor: true });
      setTimeout(() => {
        const anchorDom = editor.api.toDOMNode(anchor![0])!;
        setAnchorElement(anchorDom);
      }, 0);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [streaming]);

  const setOpen = (open: boolean) => {
    if (open) {
      api.aiChat.show();
    } else {
      api.aiChat.hide();
    }
  };

  const show = (anchorElement: HTMLElement) => {
    setAnchorElement(anchorElement);
    setOpen(true);
  };

  useEditorChat({
    chat,
    onOpenBlockSelection: (blocks: NodeEntry[]) => {
      show(editor.api.toDOMNode(blocks.at(-1)![0])!);
    },
    onOpenChange: (open) => {
      if (!open) {
        setAnchorElement(null);
        setInput("");
      }
    },
    onOpenCursor: () => {
      const [ancestor] = editor.api.block({ highest: true })!;

      if (!editor.api.isAt({ end: true }) && !editor.api.isEmpty(ancestor)) {
        editor
          .getApi(BlockSelectionPlugin)
          .blockSelection.set(ancestor.id as string);
      }

      show(editor.api.toDOMNode(ancestor)!);
    },
    onOpenSelection: () => {
      show(editor.api.toDOMNode(editor.api.blocks().at(-1)![0])!);
    },
  });

  useHotkeys(
    "meta+j",
    () => {
      api.aiChat.show();
    },
    { enableOnContentEditable: true, enableOnFormTags: true },
  );

  useHotkeys("esc", () => {
    api.aiChat.stop();

    // remove when you implement the route /api/ai/command
    chat._abortFakeStream();
  });

  const isLoading = status === "streaming" || status === "submitted";

  if (isLoading && mode === "insert") {
    return null;
  }

  return (
    <Popover open={open} onOpenChange={setOpen} modal={false}>
      <PopoverAnchor virtualRef={{ current: anchorElement! }} />

      <PopoverContent
        className="border-none bg-transparent p-0 shadow-none"
        style={{
          width: anchorElement?.offsetWidth,
        }}
        onEscapeKeyDown={(e) => {
          e.preventDefault();

          api.aiChat.hide();
        }}
        align="center"
        side="bottom"
      >
        <Command
          className="w-full rounded-lg border shadow-md"
          value={value}
          onValueChange={setValue}
        >
          {mode === "chat" && isSelecting && content && (
            <AIChatEditor content={content} />
          )}

          {isLoading ? (
            <div className="flex grow items-center gap-2 p-2 text-sm text-muted-foreground select-none">
              <Loader2Icon className="size-4 animate-spin" />
              {messages.length > 1 ? "Editing..." : "Thinking..."}
            </div>
          ) : (
            <CommandPrimitive.Input
              className={cn(
                "flex h-9 w-full min-w-0 border-input bg-transparent px-3 py-1 text-base transition-[color,box-shadow] outline-none placeholder:text-muted-foreground md:text-sm dark:bg-input/30",
                "aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40",
                "border-b focus-visible:ring-transparent",
              )}
              value={input}
              onKeyDown={(e) => {
                if (isHotkey("backspace")(e) && input.length === 0) {
                  e.preventDefault();
                  api.aiChat.hide();
                }
                if (isHotkey("enter")(e) && !e.shiftKey && !value) {
                  e.preventDefault();
                  void api.aiChat.submit();
                }
              }}
              onValueChange={setInput}
              placeholder="Ask AI anything..."
              data-plate-focus
              autoFocus
            />
          )}

          {!isLoading && (
            <CommandList>
              <AIMenuItems setValue={setValue} />
            </CommandList>
          )}
        </Command>
      </PopoverContent>
    </Popover>
  );
}

// ========== FILE END: ui/menus/ai/ai-menu.tsx ==========



// ========== FILE START: ui/menus/align-dropdown-menu.tsx ==========
"use client";

import * as React from "react";

import type { DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { type Alignment, setAlign } from "@udecode/plate-alignment";
import { useEditorRef, useSelectionFragmentProp } from "@udecode/plate/react";
import {
  AlignCenterIcon,
  AlignJustifyIcon,
  AlignLeftIcon,
  AlignRightIcon,
} from "lucide-react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { STRUCTURAL_TYPES } from "../../core/transforms";

import { ToolbarButton } from "../menus/toolbars/toolbar";

const items = [
  {
    icon: AlignLeftIcon,
    value: "left",
  },
  {
    icon: AlignCenterIcon,
    value: "center",
  },
  {
    icon: AlignRightIcon,
    value: "right",
  },
  {
    icon: AlignJustifyIcon,
    value: "justify",
  },
];

export function AlignDropdownMenu(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const value = useSelectionFragmentProp({
    defaultValue: "start",
    structuralTypes: STRUCTURAL_TYPES,
    getProp: (node) => node.align,
  });

  const [open, setOpen] = React.useState(false);
  const IconValue =
    items.find((item) => item.value === value)?.icon ?? AlignLeftIcon;

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Align" isDropdown>
          <IconValue />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent className="min-w-0" align="start">
        <DropdownMenuRadioGroup
          value={value}
          onValueChange={(value) => {
            setAlign(editor, { value: value as Alignment });
            editor.tf.focus();
          }}
        >
          {items.map(({ icon: Icon, value: itemValue }) => (
            <DropdownMenuRadioItem
              key={itemValue}
              className="pl-2 *:first:[span]:hidden"
              value={itemValue}
            >
              <Icon />
            </DropdownMenuRadioItem>
          ))}
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

// ========== FILE END: ui/menus/align-dropdown-menu.tsx ==========



// ========== FILE START: ui/menus/block-context-menu.tsx ==========
"use client";

import * as React from "react";

import { AIChatPlugin } from "@udecode/plate-ai/react";
import { BlockquotePlugin } from "@udecode/plate-block-quote/react";
import { HEADING_KEYS } from "@udecode/plate-heading";
import { IndentListPlugin } from "@udecode/plate-indent-list/react";
import {
  BLOCK_CONTEXT_MENU_ID,
  BlockMenuPlugin,
  BlockSelectionPlugin,
} from "@udecode/plate-selection/react";
import {
  ParagraphPlugin,
  useEditorPlugin,
  usePlateState,
} from "@udecode/plate/react";

import {
  ContextMenu,
  ContextMenuContent,
  ContextMenuGroup,
  ContextMenuItem,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuTrigger,
} from "@/components/ui/context-menu";
import { useIsTouchDevice } from "@/hooks/use-is-touch-device";

type Value = "askAI" | null;

export function BlockContextMenu({ children }: { children: React.ReactNode }) {
  const { api, editor } = useEditorPlugin(BlockMenuPlugin);
  const [value, setValue] = React.useState<Value>(null);
  const isTouch = useIsTouchDevice();
  const [readOnly] = usePlateState("readOnly");

  const handleTurnInto = React.useCallback(
    (type: string) => {
      editor
        .getApi(BlockSelectionPlugin)
        .blockSelection.getNodes()
        .forEach(([node, path]) => {
          if (node[IndentListPlugin.key]) {
            editor.tf.unsetNodes([IndentListPlugin.key, "indent"], {
              at: path,
            });
          }

          editor.tf.toggleBlock(type, { at: path });
        });
    },
    [editor],
  );

  const handleAlign = React.useCallback(
    (align: "center" | "left" | "right") => {
      editor
        .getTransforms(BlockSelectionPlugin)
        .blockSelection.setNodes({ align });
    },
    [editor],
  );

  if (isTouch) {
    return children;
  }

  return (
    <ContextMenu
      onOpenChange={(open) => {
        if (!open) {
          // prevent unselect the block selection
          setTimeout(() => {
            api.blockMenu.hide();
          }, 0);
        }
      }}
      modal={false}
    >
      <ContextMenuTrigger
        asChild
        onContextMenu={(event) => {
          const dataset = (event.target as HTMLElement).dataset;

          const disabled = dataset?.slateEditor === "true" || readOnly;

          if (disabled) return event.preventDefault();

          api.blockMenu.show(BLOCK_CONTEXT_MENU_ID, {
            x: event.clientX,
            y: event.clientY,
          });
        }}
      >
        <div className="w-full">{children}</div>
      </ContextMenuTrigger>
      <ContextMenuContent
        className="w-64"
        onCloseAutoFocus={(e) => {
          e.preventDefault();
          editor.getApi(BlockSelectionPlugin).blockSelection.focus();

          if (value === "askAI") {
            editor.getApi(AIChatPlugin).aiChat.show();
          }

          setValue(null);
        }}
      >
        <ContextMenuGroup>
          <ContextMenuItem
            onClick={() => {
              setValue("askAI");
            }}
          >
            Ask AI
          </ContextMenuItem>
          <ContextMenuItem
            onClick={() => {
              editor
                .getTransforms(BlockSelectionPlugin)
                .blockSelection.removeNodes();
              editor.tf.focus();
            }}
          >
            Delete
          </ContextMenuItem>
          <ContextMenuItem
            onClick={() => {
              editor
                .getTransforms(BlockSelectionPlugin)
                .blockSelection.duplicate();
            }}
          >
            Duplicate
            {/* <ContextMenuShortcut> + D</ContextMenuShortcut> */}
          </ContextMenuItem>
          <ContextMenuSub>
            <ContextMenuSubTrigger>Turn into</ContextMenuSubTrigger>
            <ContextMenuSubContent className="w-48">
              <ContextMenuItem
                onClick={() => handleTurnInto(ParagraphPlugin.key)}
              >
                Paragraph
              </ContextMenuItem>

              <ContextMenuItem onClick={() => handleTurnInto(HEADING_KEYS.h1)}>
                Heading 1
              </ContextMenuItem>
              <ContextMenuItem onClick={() => handleTurnInto(HEADING_KEYS.h2)}>
                Heading 2
              </ContextMenuItem>
              <ContextMenuItem onClick={() => handleTurnInto(HEADING_KEYS.h3)}>
                Heading 3
              </ContextMenuItem>
              <ContextMenuItem
                onClick={() => handleTurnInto(BlockquotePlugin.key)}
              >
                Blockquote
              </ContextMenuItem>
            </ContextMenuSubContent>
          </ContextMenuSub>
        </ContextMenuGroup>

        <ContextMenuGroup>
          <ContextMenuItem
            onClick={() =>
              editor
                .getTransforms(BlockSelectionPlugin)
                .blockSelection.setIndent(1)
            }
          >
            Indent
          </ContextMenuItem>
          <ContextMenuItem
            onClick={() =>
              editor
                .getTransforms(BlockSelectionPlugin)
                .blockSelection.setIndent(-1)
            }
          >
            Outdent
          </ContextMenuItem>
          <ContextMenuSub>
            <ContextMenuSubTrigger>Align</ContextMenuSubTrigger>
            <ContextMenuSubContent className="w-48">
              <ContextMenuItem onClick={() => handleAlign("left")}>
                Left
              </ContextMenuItem>
              <ContextMenuItem onClick={() => handleAlign("center")}>
                Center
              </ContextMenuItem>
              <ContextMenuItem onClick={() => handleAlign("right")}>
                Right
              </ContextMenuItem>
            </ContextMenuSubContent>
          </ContextMenuSub>
        </ContextMenuGroup>
      </ContextMenuContent>
    </ContextMenu>
  );
}

// ========== FILE END: ui/menus/block-context-menu.tsx ==========



// ========== FILE START: ui/menus/buttons/ai-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import { AIChatPlugin } from "@udecode/plate-ai/react";
import { useEditorPlugin } from "@udecode/plate/react";

import { ToolbarButton } from "../../menus/toolbars/toolbar";

export function AIToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const { api } = useEditorPlugin(AIChatPlugin);

  return (
    <ToolbarButton
      {...props}
      onClick={() => {
        api.aiChat.show();
      }}
      onMouseDown={(e) => {
        e.preventDefault();
      }}
    />
  );
}

// ========== FILE END: ui/menus/buttons/ai-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/buttons/comment-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import { getDraftCommentKey } from "@udecode/plate-comments";
import { useEditorPlugin } from "@udecode/plate/react";
import { MessageSquareTextIcon } from "lucide-react";

import { commentsPlugin } from "../../../plugins/comments/comments-plugin";

import { ToolbarButton } from "../../menus/toolbars/toolbar";

export function CommentToolbarButton() {
  const { editor, setOption, tf } = useEditorPlugin(commentsPlugin);

  const onCommentToolbarButton = React.useCallback(() => {
    if (!editor.selection) return;

    tf.comment.setDraft();
    editor.tf.collapse();
    setOption("activeId", getDraftCommentKey());
    setOption("commentingBlock", editor.selection.focus.path.slice(0, 1));
  }, [editor.selection, editor.tf, setOption, tf.comment]);

  return (
    <ToolbarButton
      onClick={onCommentToolbarButton}
      data-plate-prevent-overlay
      tooltip="Comment"
    >
      <MessageSquareTextIcon />
    </ToolbarButton>
  );
}

// ========== FILE END: ui/menus/buttons/comment-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/buttons/export-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import type { DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { withProps } from "@udecode/cn";
import {
  BaseParagraphPlugin,
  createSlateEditor,
  serializeHtml,
  SlateLeaf,
} from "@udecode/plate";
import { BaseAlignPlugin } from "@udecode/plate-alignment";
import {
  BaseBoldPlugin,
  BaseCodePlugin,
  BaseItalicPlugin,
  BaseStrikethroughPlugin,
  BaseSubscriptPlugin,
  BaseSuperscriptPlugin,
  BaseUnderlinePlugin,
} from "@udecode/plate-basic-marks";
import { BaseBlockquotePlugin } from "@udecode/plate-block-quote";
import {
  BaseCodeBlockPlugin,
  BaseCodeLinePlugin,
  BaseCodeSyntaxPlugin,
} from "@udecode/plate-code-block";
import { BaseCommentsPlugin } from "@udecode/plate-comments";
import { BaseDatePlugin } from "@udecode/plate-date";
import {
  BaseFontBackgroundColorPlugin,
  BaseFontColorPlugin,
  BaseFontSizePlugin,
} from "@udecode/plate-font";
import {
  BaseHeadingPlugin,
  BaseTocPlugin,
  HEADING_KEYS,
  HEADING_LEVELS,
} from "@udecode/plate-heading";
import { BaseHighlightPlugin } from "@udecode/plate-highlight";
import { BaseHorizontalRulePlugin } from "@udecode/plate-horizontal-rule";
import { BaseIndentPlugin } from "@udecode/plate-indent";
import { BaseIndentListPlugin } from "@udecode/plate-indent-list";
import { BaseKbdPlugin } from "@udecode/plate-kbd";
import { BaseColumnItemPlugin, BaseColumnPlugin } from "@udecode/plate-layout";
import { BaseLineHeightPlugin } from "@udecode/plate-line-height";
import { BaseLinkPlugin } from "@udecode/plate-link";
import { MarkdownPlugin } from "@udecode/plate-markdown";
import {
  BaseEquationPlugin,
  BaseInlineEquationPlugin,
} from "@udecode/plate-math";
import {
  BaseAudioPlugin,
  BaseFilePlugin,
  BaseImagePlugin,
  BaseMediaEmbedPlugin,
  BaseVideoPlugin,
} from "@udecode/plate-media";
import { BaseMentionPlugin } from "@udecode/plate-mention";
import {
  BaseTableCellHeaderPlugin,
  BaseTableCellPlugin,
  BaseTablePlugin,
  BaseTableRowPlugin,
} from "@udecode/plate-table";
import { BaseTogglePlugin } from "@udecode/plate-toggle";
import { useEditorRef } from "@udecode/plate/react";
import { all, createLowlight } from "lowlight";
import { ArrowDownToLineIcon } from "lucide-react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { BlockquoteElementStatic } from "../../elements/blockquote/blockquote-element-static";
import { CodeBlockElementStatic } from "../../elements/code/code-block-element-static";
import { CodeLeafStatic } from "../../elements/code/code-leaf-static";
import { CodeLineElementStatic } from "../../elements/code/code-line-element-static";
import { CodeSyntaxLeafStatic } from "../../elements/code/code-syntax-leaf-static";
import { ColumnElementStatic } from "../../elements/layout/column-element-static";
import { ColumnGroupElementStatic } from "../../elements/layout/column-group-element-static";
import { CommentLeafStatic } from "../../elements/comments-suggestions/comment-leaf-static";
import { DateElementStatic } from "../../elements/date/date-element-static";
import { HeadingElementStatic } from "../../elements/heading/heading-element-static";
import { HighlightLeafStatic } from "../../elements/leafs/highlight-leaf-static";
import { HrElementStatic } from "../../elements/heading/hr-element-static";
import { ImageElementStatic } from "../../elements/image/image-element-static";
import { KbdLeafStatic } from "../../elements/leafs/kbd-leaf-static";
import { LinkElementStatic } from "../../elements/link/link-element-static";
import { MediaAudioElementStatic } from "../../elements/media/media-audio-element-static";
import { MediaFileElementStatic } from "../../elements/media/media-file-element-static";
import { MediaVideoElementStatic } from "../../elements/media/media-video-element-static";
import { MentionElementStatic } from "../../elements/mention/mention-element-static";
import { ParagraphElementStatic } from "../../elements/paragraph/paragraph-element-static";
import { TableCellElementStatic } from "../../elements/table/table-cell-element-static";
import { TableElementStatic } from "../../elements/table/table-element-static";
import { TableRowElementStatic } from "../../elements/table/table-row-element-static";
import { TocElementStatic } from "../../elements/toc/toc-element-static";
import { ToggleElementStatic } from "../../elements/toggle/toggle-element-static";
import { EditorStatic } from "../../primitives/editor-static";
import { EquationElementStatic } from "../../elements/equation/equation-element-static";
import { InlineEquationElementStatic } from "../../elements/equation/inline-equation-element-static";
import { ToolbarButton } from "../../menus/toolbars/toolbar";
import {
  FireLiComponent,
  FireMarker,
} from "../../elements/indentation/indent-fire-marker";
import {
  TodoLiStatic,
  TodoMarkerStatic,
} from "../../elements/indentation/indent-todo-marker-static";
import { TableCellHeaderStaticElement } from "../../elements/table/table-cell-element-static";

const siteUrl = "https://platejs.org";
const lowlight = createLowlight(all);

export function ExportToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  const getCanvas = async () => {
    const { default: html2canvas } = await import("html2canvas-pro");

    const style = document.createElement("style");
    document.head.append(style);

    const canvas = await html2canvas(editor.api.toDOMNode(editor)!, {
      onclone: (document: Document) => {
        const editorElement = document.querySelector(
          '[contenteditable="true"]',
        );
        if (editorElement) {
          Array.from(editorElement.querySelectorAll("*")).forEach((element) => {
            const existingStyle = element.getAttribute("style") || "";
            element.setAttribute(
              "style",
              `${existingStyle}; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif !important`,
            );
          });
        }
      },
    });
    style.remove();

    return canvas;
  };

  const downloadFile = async (url: string, filename: string) => {
    const response = await fetch(url);

    const blob = await response.blob();
    const blobUrl = window.URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.href = blobUrl;
    link.download = filename;
    document.body.append(link);
    link.click();
    link.remove();

    // Clean up the blob URL
    window.URL.revokeObjectURL(blobUrl);
  };

  const exportToPdf = async () => {
    const canvas = await getCanvas();

    const PDFLib = await import("pdf-lib");
    const pdfDoc = await PDFLib.PDFDocument.create();
    const page = pdfDoc.addPage([canvas.width, canvas.height]);
    const imageEmbed = await pdfDoc.embedPng(canvas.toDataURL("PNG"));
    const { height, width } = imageEmbed.scale(1);
    page.drawImage(imageEmbed, {
      height,
      width,
      x: 0,
      y: 0,
    });
    const pdfBase64 = await pdfDoc.saveAsBase64({ dataUri: true });

    await downloadFile(pdfBase64, "plate.pdf");
  };

  const exportToImage = async () => {
    const canvas = await getCanvas();
    await downloadFile(canvas.toDataURL("image/png"), "plate.png");
  };

  const exportToHtml = async () => {
    const components = {
      [BaseAudioPlugin.key]: MediaAudioElementStatic,
      [BaseBlockquotePlugin.key]: BlockquoteElementStatic,
      [BaseBoldPlugin.key]: withProps(SlateLeaf, { as: "strong" }),
      [BaseCodeBlockPlugin.key]: CodeBlockElementStatic,
      [BaseCodeLinePlugin.key]: CodeLineElementStatic,
      [BaseCodePlugin.key]: CodeLeafStatic,
      [BaseCodeSyntaxPlugin.key]: CodeSyntaxLeafStatic,
      [BaseColumnItemPlugin.key]: ColumnElementStatic,
      [BaseColumnPlugin.key]: ColumnGroupElementStatic,
      [BaseCommentsPlugin.key]: CommentLeafStatic,
      [BaseDatePlugin.key]: DateElementStatic,
      [BaseEquationPlugin.key]: EquationElementStatic,
      [BaseFilePlugin.key]: MediaFileElementStatic,
      [BaseHighlightPlugin.key]: HighlightLeafStatic,
      [BaseHorizontalRulePlugin.key]: HrElementStatic,
      [BaseImagePlugin.key]: ImageElementStatic,
      [BaseInlineEquationPlugin.key]: InlineEquationElementStatic,
      [BaseItalicPlugin.key]: withProps(SlateLeaf, { as: "em" }),
      [BaseKbdPlugin.key]: KbdLeafStatic,
      [BaseLinkPlugin.key]: LinkElementStatic,
      // [BaseMediaEmbedPlugin.key]: MediaEmbedElementStatic,
      [BaseMentionPlugin.key]: MentionElementStatic,
      [BaseParagraphPlugin.key]: ParagraphElementStatic,
      [BaseStrikethroughPlugin.key]: withProps(SlateLeaf, { as: "del" }),
      [BaseSubscriptPlugin.key]: withProps(SlateLeaf, { as: "sub" }),
      [BaseSuperscriptPlugin.key]: withProps(SlateLeaf, { as: "sup" }),
      [BaseTableCellHeaderPlugin.key]: TableCellHeaderStaticElement,
      [BaseTableCellPlugin.key]: TableCellElementStatic,
      [BaseTablePlugin.key]: TableElementStatic,
      [BaseTableRowPlugin.key]: TableRowElementStatic,
      [BaseTocPlugin.key]: TocElementStatic,
      [BaseTogglePlugin.key]: ToggleElementStatic,
      [BaseUnderlinePlugin.key]: withProps(SlateLeaf, { as: "u" }),
      [BaseVideoPlugin.key]: MediaVideoElementStatic,
      [HEADING_KEYS.h1]: withProps(HeadingElementStatic, { variant: "h1" }),
      [HEADING_KEYS.h2]: withProps(HeadingElementStatic, { variant: "h2" }),
      [HEADING_KEYS.h3]: withProps(HeadingElementStatic, { variant: "h3" }),
      [HEADING_KEYS.h4]: withProps(HeadingElementStatic, { variant: "h4" }),
      [HEADING_KEYS.h5]: withProps(HeadingElementStatic, { variant: "h5" }),
      [HEADING_KEYS.h6]: withProps(HeadingElementStatic, { variant: "h6" }),
    };

    const editorStatic = createSlateEditor({
      plugins: [
        BaseColumnPlugin,
        BaseColumnItemPlugin,
        BaseTocPlugin,
        BaseVideoPlugin,
        BaseAudioPlugin,
        BaseParagraphPlugin,
        BaseHeadingPlugin,
        BaseMediaEmbedPlugin,
        BaseBoldPlugin,
        BaseCodePlugin,
        BaseItalicPlugin,
        BaseStrikethroughPlugin,
        BaseSubscriptPlugin,
        BaseSuperscriptPlugin,
        BaseUnderlinePlugin,
        BaseBlockquotePlugin,
        BaseDatePlugin,
        BaseEquationPlugin,
        BaseInlineEquationPlugin,
        BaseCodeBlockPlugin.configure({
          options: {
            lowlight,
          },
        }),
        BaseIndentPlugin.extend({
          inject: {
            targetPlugins: [
              BaseParagraphPlugin.key,
              BaseBlockquotePlugin.key,
              BaseCodeBlockPlugin.key,
            ],
          },
        }),
        BaseIndentListPlugin.extend({
          inject: {
            targetPlugins: [
              BaseParagraphPlugin.key,
              ...HEADING_LEVELS,
              BaseBlockquotePlugin.key,
              BaseCodeBlockPlugin.key,
              BaseTogglePlugin.key,
            ],
          },
          options: {
            listStyleTypes: {
              fire: {
                liComponent: FireLiComponent,
                markerComponent: FireMarker,
                type: "fire",
              },
              todo: {
                liComponent: TodoLiStatic,
                markerComponent: TodoMarkerStatic,
                type: "todo",
              },
            },
          },
        }),
        BaseLinkPlugin,
        BaseTableRowPlugin,
        BaseTablePlugin,
        BaseTableCellPlugin,
        BaseHorizontalRulePlugin,
        BaseFontColorPlugin,
        BaseFontBackgroundColorPlugin,
        BaseFontSizePlugin,
        BaseKbdPlugin,
        BaseAlignPlugin.extend({
          inject: {
            targetPlugins: [
              BaseParagraphPlugin.key,
              BaseMediaEmbedPlugin.key,
              ...HEADING_LEVELS,
              BaseImagePlugin.key,
            ],
          },
        }),
        BaseLineHeightPlugin,
        BaseHighlightPlugin,
        BaseFilePlugin,
        BaseImagePlugin,
        BaseMentionPlugin,
        BaseCommentsPlugin,
        BaseTogglePlugin,
      ],
      value: editor.children,
    });

    const editorHtml = await serializeHtml(editorStatic, {
      components,
      editorComponent: EditorStatic,
      props: { style: { padding: "0 calc(50% - 350px)", paddingBottom: "" } },
    });

    const tailwindCss = `<link rel="stylesheet" href="${siteUrl}/tailwind.css">`;
    const katexCss = `<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.css" integrity="sha384-9PvLvaiSKCPkFKB1ZsEoTjgnJn+O3KvEwtsz37/XrkYft3DTk2gHdYvd9oWgW3tV" crossorigin="anonymous">`;

    const html = `<!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="color-scheme" content="light dark" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
          href="https://fonts.googleapis.com/css2?family=Inter:wght@400..700&family=JetBrains+Mono:wght@400..700&display=swap"
          rel="stylesheet"
        />
        ${tailwindCss}
        ${katexCss}
        <style>
          :root {
            --font-sans: 'Inter', 'Inter Fallback';
            --font-mono: 'JetBrains Mono', 'JetBrains Mono Fallback';
          }
        </style>
      </head>
      <body>
        ${editorHtml}
      </body>
    </html>`;

    const url = `data:text/html;charset=utf-8,${encodeURIComponent(html)}`;

    await downloadFile(url, "plate.html");
  };

  const exportToMarkdown = async () => {
    const md = editor.getApi(MarkdownPlugin).markdown.serialize();
    const url = `data:text/markdown;charset=utf-8,${encodeURIComponent(md)}`;
    await downloadFile(url, "plate.md");
  };

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Export" isDropdown>
          <ArrowDownToLineIcon className="size-4" />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="start">
        <DropdownMenuGroup>
          <DropdownMenuItem onSelect={exportToHtml}>
            Export as HTML
          </DropdownMenuItem>
          <DropdownMenuItem onSelect={exportToPdf}>
            Export as PDF
          </DropdownMenuItem>
          <DropdownMenuItem onSelect={exportToImage}>
            Export as Image
          </DropdownMenuItem>
          <DropdownMenuItem onSelect={exportToMarkdown}>
            Export as Markdown
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

// ========== FILE END: ui/menus/buttons/export-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/buttons/fixed-toolbar-buttons.tsx ==========
"use client";

import * as React from "react";

import {
  BoldPlugin,
  ItalicPlugin,
  UnderlinePlugin,
} from "@udecode/plate-basic-marks/react";
import {
  FontBackgroundColorPlugin,
  FontColorPlugin,
} from "@udecode/plate-font/react";
import { ImagePlugin } from "@udecode/plate-media/react";
import { useEditorReadOnly } from "@udecode/plate/react";
import {
  BaselineIcon,
  BoldIcon,
  ItalicIcon,
  PaintBucketIcon,
  UnderlineIcon,
  WandSparklesIcon,
} from "lucide-react";

import { MoreDropdownMenu } from "../../menus/more-dropdown-menu";

import { AIToolbarButton } from "./ai-toolbar-button";
import { AlignDropdownMenu } from "../../menus/align-dropdown-menu";
import { ColorDropdownMenu } from "../../primitives/color-picker/color-dropdown-menu";
import { CommentToolbarButton } from "./comment-toolbar-button";
import { FontSizeToolbarButton } from "./font-size-toolbar-button";
import { RedoToolbarButton, UndoToolbarButton } from "./history-toolbar-button";
import { InsertDropdownMenu } from "../../menus/insert-dropdown-menu";
import { LinkToolbarButton } from "./link-toolbar-button";
import { MarkToolbarButton } from "./mark-toolbar-button";
import { MediaToolbarButton } from "./media-toolbar-button";
import { ModeDropdownMenu } from "../../menus/mode-dropdown-menu";
import { TableDropdownMenu } from "../../menus/table-dropdown-menu";
import { ToolbarGroup } from "../../menus/toolbars/toolbar";
import { EmojiDropdownMenu } from "../../menus/emoji/emoji-dropdown-menu";

export function FixedToolbarButtons() {
  const readOnly = useEditorReadOnly();

  return (
    <div className="flex w-full">
      {!readOnly && (
        <>
          <ToolbarGroup>
            <UndoToolbarButton />
            <RedoToolbarButton />
            <AIToolbarButton tooltip="AI commands">
              <WandSparklesIcon />
            </AIToolbarButton>
          </ToolbarGroup>

          <ToolbarGroup>
            <MarkToolbarButton nodeType={BoldPlugin.key} tooltip="Bold (+B)">
              <BoldIcon />
            </MarkToolbarButton>
            <MarkToolbarButton
              nodeType={ItalicPlugin.key}
              tooltip="Italic (+I)"
            >
              <ItalicIcon />
            </MarkToolbarButton>
            <MarkToolbarButton
              nodeType={UnderlinePlugin.key}
              tooltip="Underline (+U)"
            >
              <UnderlineIcon />
            </MarkToolbarButton>
            <LinkToolbarButton />
          </ToolbarGroup>

          <ToolbarGroup>
            <InsertDropdownMenu />
            <FontSizeToolbarButton />
          </ToolbarGroup>

          <ToolbarGroup>
            <AlignDropdownMenu />
            <ColorDropdownMenu
              nodeType={FontColorPlugin.key}
              tooltip="Text color"
            >
              <BaselineIcon />
            </ColorDropdownMenu>
            <ColorDropdownMenu
              nodeType={FontBackgroundColorPlugin.key}
              tooltip="Background color"
            >
              <PaintBucketIcon />
            </ColorDropdownMenu>
            <TableDropdownMenu />
            <MediaToolbarButton nodeType={ImagePlugin.key} />
            <EmojiDropdownMenu />
          </ToolbarGroup>

          <ToolbarGroup>
            <MoreDropdownMenu />
          </ToolbarGroup>
        </>
      )}

      <div className="grow" />

      <ToolbarGroup>
        <CommentToolbarButton />
        <ModeDropdownMenu />
      </ToolbarGroup>
    </div>
  );
}

// ========== FILE END: ui/menus/buttons/fixed-toolbar-buttons.tsx ==========



// ========== FILE START: ui/menus/buttons/floating-toolbar-buttons.tsx ==========
"use client";

import * as React from "react";

import {
  BoldPlugin,
  CodePlugin,
  ItalicPlugin,
  StrikethroughPlugin,
  UnderlinePlugin,
} from "@udecode/plate-basic-marks/react";
import { useEditorReadOnly } from "@udecode/plate/react";
import {
  BoldIcon,
  Code2Icon,
  ItalicIcon,
  StrikethroughIcon,
  UnderlineIcon,
  WandSparklesIcon,
} from "lucide-react";

import { AIToolbarButton } from "./ai-toolbar-button";
import { CommentToolbarButton } from "./comment-toolbar-button";
import { InlineEquationToolbarButton } from "./inline-equation-toolbar-button";
import { LinkToolbarButton } from "./link-toolbar-button";
import { MarkToolbarButton } from "./mark-toolbar-button";
import { MoreDropdownMenu } from "../../menus/more-dropdown-menu";
import { SuggestionToolbarButton } from "./suggestion-toolbar-button";
import { ToolbarGroup } from "../../menus/toolbars/toolbar";
import { TurnIntoDropdownMenu } from "../../menus/turn-into-dropdown-menu";

export function FloatingToolbarButtons() {
  const readOnly = useEditorReadOnly();

  return (
    <>
      {!readOnly && (
        <>
          <ToolbarGroup>
            <AIToolbarButton tooltip="AI commands">
              <WandSparklesIcon />
              Ask AI
            </AIToolbarButton>
          </ToolbarGroup>

          <ToolbarGroup>
            <TurnIntoDropdownMenu />

            <MarkToolbarButton nodeType={BoldPlugin.key} tooltip="Bold (+B)">
              <BoldIcon />
            </MarkToolbarButton>

            <MarkToolbarButton
              nodeType={ItalicPlugin.key}
              tooltip="Italic (+I)"
            >
              <ItalicIcon />
            </MarkToolbarButton>

            <MarkToolbarButton
              nodeType={UnderlinePlugin.key}
              tooltip="Underline (+U)"
            >
              <UnderlineIcon />
            </MarkToolbarButton>

            <MarkToolbarButton
              nodeType={StrikethroughPlugin.key}
              tooltip="Strikethrough (++M)"
            >
              <StrikethroughIcon />
            </MarkToolbarButton>

            <MarkToolbarButton nodeType={CodePlugin.key} tooltip="Code (+E)">
              <Code2Icon />
            </MarkToolbarButton>

            <InlineEquationToolbarButton />

            <LinkToolbarButton />
          </ToolbarGroup>
        </>
      )}

      <ToolbarGroup>
        <CommentToolbarButton />
        <SuggestionToolbarButton />

        {!readOnly && <MoreDropdownMenu />}
      </ToolbarGroup>
    </>
  );
}

// ========== FILE END: ui/menus/buttons/floating-toolbar-buttons.tsx ==========



// ========== FILE START: ui/menus/buttons/font-size-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import type { TElement } from "@udecode/plate";

import { toUnitLess } from "@udecode/plate-font";
import { FontSizePlugin } from "@udecode/plate-font/react";
import { HEADING_KEYS } from "@udecode/plate-heading";
import { useEditorPlugin, useEditorSelector } from "@udecode/plate/react";
import { Minus, Plus } from "lucide-react";

import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";

import { ToolbarButton } from "../../menus/toolbars/toolbar";

const DEFAULT_FONT_SIZE = "16";

const FONT_SIZE_MAP = {
  [HEADING_KEYS.h1]: "36",
  [HEADING_KEYS.h2]: "24",
  [HEADING_KEYS.h3]: "20",
} as const;

const FONT_SIZES = [
  "8",
  "9",
  "10",
  "12",
  "14",
  "16",
  "18",
  "24",
  "30",
  "36",
  "48",
  "60",
  "72",
  "96",
] as const;

export function FontSizeToolbarButton() {
  const [inputValue, setInputValue] = React.useState(DEFAULT_FONT_SIZE);
  const [isFocused, setIsFocused] = React.useState(false);
  const { api, editor } = useEditorPlugin(FontSizePlugin);

  const cursorFontSize = useEditorSelector((editor) => {
    const fontSize = editor.api.marks()?.[FontSizePlugin.key];

    if (fontSize) {
      return toUnitLess(fontSize as string);
    }

    const [block] = editor.api.block<TElement>() || [];

    if (!block?.type) return DEFAULT_FONT_SIZE;

    return block.type in FONT_SIZE_MAP
      ? FONT_SIZE_MAP[block.type as keyof typeof FONT_SIZE_MAP]
      : DEFAULT_FONT_SIZE;
  }, []);

  const handleInputChange = () => {
    const newSize = toUnitLess(inputValue);

    if (Number.parseInt(newSize) < 1 || Number.parseInt(newSize) > 100) {
      editor.tf.focus();

      return;
    }
    if (newSize !== toUnitLess(cursorFontSize)) {
      api.fontSize.setMark(`${newSize}px`);
    }

    editor.tf.focus();
  };

  const handleFontSizeChange = (delta: number) => {
    const newSize = Number(displayValue) + delta;
    api.fontSize.setMark(`${newSize}px`);
    editor.tf.focus();
  };

  const displayValue = isFocused ? inputValue : cursorFontSize;

  return (
    <div className="flex h-7 items-center gap-1 rounded-md bg-muted/60 p-0">
      <ToolbarButton onClick={() => handleFontSizeChange(-1)}>
        <Minus />
      </ToolbarButton>

      <Popover open={isFocused} modal={false}>
        <PopoverTrigger asChild>
          <input
            className={cn(
              "h-full w-10 shrink-0 bg-transparent px-1 text-center text-sm hover:bg-muted",
            )}
            value={displayValue}
            onBlur={() => {
              setIsFocused(false);
              handleInputChange();
            }}
            onChange={(e) => setInputValue(e.target.value)}
            onFocus={() => {
              setIsFocused(true);
              setInputValue(toUnitLess(cursorFontSize));
            }}
            onKeyDown={(e) => {
              if (e.key === "Enter") {
                e.preventDefault();
                handleInputChange();
              }
            }}
            data-plate-focus="true"
            type="text"
          />
        </PopoverTrigger>
        <PopoverContent
          className="w-10 px-px py-1"
          onOpenAutoFocus={(e) => e.preventDefault()}
        >
          {FONT_SIZES.map((size) => (
            <button
              key={size}
              className={cn(
                "flex h-8 w-full items-center justify-center text-sm hover:bg-accent data-[highlighted=true]:bg-accent",
              )}
              onClick={() => {
                api.fontSize.setMark(`${size}px`);
                setIsFocused(false);
              }}
              data-highlighted={size === displayValue}
              type="button"
            >
              {size}
            </button>
          ))}
        </PopoverContent>
      </Popover>

      <ToolbarButton onClick={() => handleFontSizeChange(1)}>
        <Plus />
      </ToolbarButton>
    </div>
  );
}

// ========== FILE END: ui/menus/buttons/font-size-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/buttons/history-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import { useEditorRef, useEditorSelector } from "@udecode/plate/react";
import { Redo2Icon, Undo2Icon } from "lucide-react";

import { ToolbarButton } from "../../menus/toolbars/toolbar";

export function RedoToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const editor = useEditorRef();
  const disabled = useEditorSelector(
    (editor) => editor.history.redos.length === 0,
    [],
  );

  return (
    <ToolbarButton
      {...props}
      disabled={disabled}
      onClick={() => editor.redo()}
      onMouseDown={(e) => e.preventDefault()}
      tooltip="Redo"
    >
      <Redo2Icon />
    </ToolbarButton>
  );
}

export function UndoToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const editor = useEditorRef();
  const disabled = useEditorSelector(
    (editor) => editor.history.undos.length === 0,
    [],
  );

  return (
    <ToolbarButton
      {...props}
      disabled={disabled}
      onClick={() => editor.undo()}
      onMouseDown={(e) => e.preventDefault()}
      tooltip="Undo"
    >
      <Undo2Icon />
    </ToolbarButton>
  );
}

// ========== FILE END: ui/menus/buttons/history-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/buttons/import-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import type { DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { getEditorDOMFromHtmlString } from "@udecode/plate";
import { MarkdownPlugin } from "@udecode/plate-markdown";
import { useEditorRef } from "@udecode/plate/react";
import { ArrowUpToLineIcon } from "lucide-react";
import { useFilePicker } from "use-file-picker";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

import { ToolbarButton } from "../toolbar";

type ImportType = "html" | "markdown";

export function ImportToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  const getFileNodes = (text: string, type: ImportType) => {
    if (type === "html") {
      const editorNode = getEditorDOMFromHtmlString(text);
      const nodes = editor.api.html.deserialize({
        element: editorNode,
      });

      return nodes;
    }

    if (type === "markdown") {
      return editor.getApi(MarkdownPlugin).markdown.deserialize(text);
    }

    return [];
  };

  const { openFilePicker: openMdFilePicker } = useFilePicker({
    accept: [".md", ".mdx"],
    multiple: false,
    onFilesSelected: async ({ plainFiles }) => {
      const text = await plainFiles[0].text();

      const nodes = getFileNodes(text, "markdown");

      editor.tf.insertNodes(nodes);
    },
  });

  const { openFilePicker: openHtmlFilePicker } = useFilePicker({
    accept: ["text/html"],
    multiple: false,
    onFilesSelected: async ({ plainFiles }) => {
      const text = await plainFiles[0].text();

      const nodes = getFileNodes(text, "html");

      editor.tf.insertNodes(nodes);
    },
  });

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Import" isDropdown>
          <ArrowUpToLineIcon className="size-4" />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="start">
        <DropdownMenuGroup>
          <DropdownMenuItem
            onSelect={() => {
              openHtmlFilePicker();
            }}
          >
            Import from HTML
          </DropdownMenuItem>

          <DropdownMenuItem
            onSelect={() => {
              openMdFilePicker();
            }}
          >
            Import from Markdown
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

// ========== FILE END: ui/menus/buttons/import-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/buttons/indent-list-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import {
  ListStyleType,
  someIndentList,
  toggleIndentList,
} from "@udecode/plate-indent-list";
import { useEditorRef, useEditorSelector } from "@udecode/plate/react";
import { List, ListOrdered } from "lucide-react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

import {
  ToolbarSplitButton,
  ToolbarSplitButtonPrimary,
  ToolbarSplitButtonSecondary,
} from "../toolbar";

export function NumberedIndentListToolbarButton() {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  const pressed = useEditorSelector(
    (editor) =>
      someIndentList(editor, [
        ListStyleType.Decimal,
        ListStyleType.LowerAlpha,
        ListStyleType.UpperAlpha,
        ListStyleType.LowerRoman,
        ListStyleType.UpperRoman,
      ]),
    [],
  );

  return (
    <ToolbarSplitButton pressed={open}>
      <ToolbarSplitButtonPrimary
        className="data-[state=on]:bg-accent data-[state=on]:text-accent-foreground"
        onClick={() =>
          toggleIndentList(editor, {
            listStyleType: ListStyleType.Decimal,
          })
        }
        data-state={pressed ? "on" : "off"}
      >
        <ListOrdered className="size-4" />
      </ToolbarSplitButtonPrimary>

      <DropdownMenu open={open} onOpenChange={setOpen} modal={false}>
        <DropdownMenuTrigger asChild>
          <ToolbarSplitButtonSecondary />
        </DropdownMenuTrigger>

        <DropdownMenuContent align="start" alignOffset={-32}>
          <DropdownMenuGroup>
            <DropdownMenuItem
              onSelect={() =>
                toggleIndentList(editor, {
                  listStyleType: ListStyleType.Decimal,
                })
              }
            >
              Decimal (1, 2, 3)
            </DropdownMenuItem>
            <DropdownMenuItem
              onSelect={() =>
                toggleIndentList(editor, {
                  listStyleType: ListStyleType.LowerAlpha,
                })
              }
            >
              Lower Alpha (a, b, c)
            </DropdownMenuItem>
            <DropdownMenuItem
              onSelect={() =>
                toggleIndentList(editor, {
                  listStyleType: ListStyleType.UpperAlpha,
                })
              }
            >
              Upper Alpha (A, B, C)
            </DropdownMenuItem>
            <DropdownMenuItem
              onSelect={() =>
                toggleIndentList(editor, {
                  listStyleType: ListStyleType.LowerRoman,
                })
              }
            >
              Lower Roman (i, ii, iii)
            </DropdownMenuItem>
            <DropdownMenuItem
              onSelect={() =>
                toggleIndentList(editor, {
                  listStyleType: ListStyleType.UpperRoman,
                })
              }
            >
              Upper Roman (I, II, III)
            </DropdownMenuItem>
          </DropdownMenuGroup>
        </DropdownMenuContent>
      </DropdownMenu>
    </ToolbarSplitButton>
  );
}

export function BulletedIndentListToolbarButton() {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  const pressed = useEditorSelector(
    (editor) =>
      someIndentList(editor, [
        ListStyleType.Disc,
        ListStyleType.Circle,
        ListStyleType.Square,
      ]),
    [],
  );

  return (
    <ToolbarSplitButton pressed={open}>
      <ToolbarSplitButtonPrimary
        className="data-[state=on]:bg-accent data-[state=on]:text-accent-foreground"
        onClick={() => {
          toggleIndentList(editor, {
            listStyleType: ListStyleType.Disc,
          });
        }}
        data-state={pressed ? "on" : "off"}
      >
        <List className="size-4" />
      </ToolbarSplitButtonPrimary>

      <DropdownMenu open={open} onOpenChange={setOpen} modal={false}>
        <DropdownMenuTrigger asChild>
          <ToolbarSplitButtonSecondary />
        </DropdownMenuTrigger>

        <DropdownMenuContent align="start" alignOffset={-32}>
          <DropdownMenuGroup>
            <DropdownMenuItem
              onClick={() =>
                toggleIndentList(editor, {
                  listStyleType: ListStyleType.Disc,
                })
              }
            >
              <div className="flex items-center gap-2">
                <div className="size-2 rounded-full border border-current bg-current" />
                Default
              </div>
            </DropdownMenuItem>
            <DropdownMenuItem
              onClick={() =>
                toggleIndentList(editor, {
                  listStyleType: ListStyleType.Circle,
                })
              }
            >
              <div className="flex items-center gap-2">
                <div className="size-2 rounded-full border border-current" />
                Circle
              </div>
            </DropdownMenuItem>
            <DropdownMenuItem
              onClick={() =>
                toggleIndentList(editor, {
                  listStyleType: ListStyleType.Square,
                })
              }
            >
              <div className="flex items-center gap-2">
                <div className="size-2 border border-current bg-current" />
                Square
              </div>
            </DropdownMenuItem>
          </DropdownMenuGroup>
        </DropdownMenuContent>
      </DropdownMenu>
    </ToolbarSplitButton>
  );
}

// ========== FILE END: ui/menus/buttons/indent-list-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/buttons/indent-todo-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import {
  useIndentTodoToolBarButton,
  useIndentTodoToolBarButtonState,
} from "@udecode/plate-indent-list/react";
import { ListTodoIcon } from "lucide-react";

import { ToolbarButton } from "../../menus/toolbars/toolbar";

export function IndentTodoToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const state = useIndentTodoToolBarButtonState({ nodeType: "todo" });
  const { props: buttonProps } = useIndentTodoToolBarButton(state);

  return (
    <ToolbarButton {...props} {...buttonProps} tooltip="Todo">
      <ListTodoIcon />
    </ToolbarButton>
  );
}

// ========== FILE END: ui/menus/buttons/indent-todo-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/buttons/indent-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import { useIndentButton } from "@udecode/plate-indent/react";
import { Indent } from "lucide-react";

import { ToolbarButton } from "../../menus/toolbars/toolbar";

export function IndentToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const { props: buttonProps } = useIndentButton();

  return (
    <ToolbarButton {...props} {...buttonProps} tooltip="Indent">
      <Indent />
    </ToolbarButton>
  );
}

// ========== FILE END: ui/menus/buttons/indent-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/buttons/inline-equation-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import { insertInlineEquation } from "@udecode/plate-math";
import { useEditorRef } from "@udecode/plate/react";
import { RadicalIcon } from "lucide-react";

import { ToolbarButton } from "../../menus/toolbars/toolbar";

export function InlineEquationToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const editor = useEditorRef();

  return (
    <ToolbarButton
      {...props}
      onClick={() => {
        insertInlineEquation(editor);
      }}
      tooltip="Mark as equation"
    >
      <RadicalIcon />
    </ToolbarButton>
  );
}

// ========== FILE END: ui/menus/buttons/inline-equation-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/buttons/link-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import {
  useLinkToolbarButton,
  useLinkToolbarButtonState,
} from "@udecode/plate-link/react";
import { Link } from "lucide-react";

import { ToolbarButton } from "../../menus/toolbars/toolbar";

export function LinkToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const state = useLinkToolbarButtonState();
  const { props: buttonProps } = useLinkToolbarButton(state);

  return (
    <ToolbarButton {...props} {...buttonProps} data-plate-focus tooltip="Link">
      <Link />
    </ToolbarButton>
  );
}

// ========== FILE END: ui/menus/buttons/link-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/buttons/mark-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import {
  useMarkToolbarButton,
  useMarkToolbarButtonState,
} from "@udecode/plate/react";

import { ToolbarButton } from "../../menus/toolbars/toolbar";

export function MarkToolbarButton({
  clear,
  nodeType,
  ...props
}: React.ComponentProps<typeof ToolbarButton> & {
  nodeType: string;
  clear?: string[] | string;
}) {
  const state = useMarkToolbarButtonState({ clear, nodeType });
  const { props: buttonProps } = useMarkToolbarButton(state);

  return <ToolbarButton {...props} {...buttonProps} />;
}

// ========== FILE END: ui/menus/buttons/mark-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/buttons/media-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import type { DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { isUrl } from "@udecode/plate";
import {
  AudioPlugin,
  FilePlugin,
  ImagePlugin,
  PlaceholderPlugin,
  VideoPlugin,
} from "@udecode/plate-media/react";
import { useEditorRef } from "@udecode/plate/react";
import {
  AudioLinesIcon,
  FileUpIcon,
  FilmIcon,
  ImageIcon,
  LinkIcon,
} from "lucide-react";
import { toast } from "sonner";
import { useFilePicker } from "use-file-picker";

import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Input } from "@/components/ui/input";

import {
  ToolbarSplitButton,
  ToolbarSplitButtonPrimary,
  ToolbarSplitButtonSecondary,
} from "../../menus/toolbars/toolbar";

const MEDIA_CONFIG: Record<
  string,
  {
    accept: string[];
    icon: React.ReactNode;
    title: string;
    tooltip: string;
  }
> = {
  [AudioPlugin.key]: {
    accept: ["audio/*"],
    icon: <AudioLinesIcon className="size-4" />,
    title: "Insert Audio",
    tooltip: "Audio",
  },
  [FilePlugin.key]: {
    accept: ["*"],
    icon: <FileUpIcon className="size-4" />,
    title: "Insert File",
    tooltip: "File",
  },
  [ImagePlugin.key]: {
    accept: ["image/*"],
    icon: <ImageIcon className="size-4" />,
    title: "Insert Image",
    tooltip: "Image",
  },
  [VideoPlugin.key]: {
    accept: ["video/*"],
    icon: <FilmIcon className="size-4" />,
    title: "Insert Video",
    tooltip: "Video",
  },
};

export function MediaToolbarButton({
  nodeType,
  ...props
}: DropdownMenuProps & { nodeType: string }) {
  const currentConfig = MEDIA_CONFIG[nodeType];

  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);
  const [dialogOpen, setDialogOpen] = React.useState(false);

  const { openFilePicker } = useFilePicker({
    accept: currentConfig.accept,
    multiple: true,
    onFilesSelected: ({ plainFiles: updatedFiles }) => {
      editor.getTransforms(PlaceholderPlugin).insert.media(updatedFiles);
    },
  });

  return (
    <>
      <ToolbarSplitButton
        onClick={() => {
          openFilePicker();
        }}
        onKeyDown={(e) => {
          if (e.key === "ArrowDown") {
            e.preventDefault();
            setOpen(true);
          }
        }}
        pressed={open}
      >
        <ToolbarSplitButtonPrimary>
          {currentConfig.icon}
        </ToolbarSplitButtonPrimary>

        <DropdownMenu
          open={open}
          onOpenChange={setOpen}
          modal={false}
          {...props}
        >
          <DropdownMenuTrigger asChild>
            <ToolbarSplitButtonSecondary />
          </DropdownMenuTrigger>

          <DropdownMenuContent
            onClick={(e) => e.stopPropagation()}
            align="start"
            alignOffset={-32}
          >
            <DropdownMenuGroup>
              <DropdownMenuItem onSelect={() => openFilePicker()}>
                {currentConfig.icon}
                Upload from computer
              </DropdownMenuItem>
              <DropdownMenuItem onSelect={() => setDialogOpen(true)}>
                <LinkIcon />
                Insert via URL
              </DropdownMenuItem>
            </DropdownMenuGroup>
          </DropdownMenuContent>
        </DropdownMenu>
      </ToolbarSplitButton>

      <AlertDialog
        open={dialogOpen}
        onOpenChange={(value) => {
          setDialogOpen(value);
        }}
      >
        <AlertDialogContent className="gap-6">
          <MediaUrlDialogContent
            currentConfig={currentConfig}
            nodeType={nodeType}
            setOpen={setDialogOpen}
          />
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

function MediaUrlDialogContent({
  currentConfig,
  nodeType,
  setOpen,
}: {
  currentConfig: (typeof MEDIA_CONFIG)[string];
  nodeType: string;
  setOpen: (value: boolean) => void;
}) {
  const editor = useEditorRef();
  const [url, setUrl] = React.useState("");

  const embedMedia = React.useCallback(() => {
    if (!isUrl(url)) return toast.error("Invalid URL");

    setOpen(false);
    editor.tf.insertNodes({
      children: [{ text: "" }],
      name: nodeType === FilePlugin.key ? url.split("/").pop() : undefined,
      type: nodeType,
      url,
    });
  }, [url, editor, nodeType, setOpen]);

  return (
    <>
      <AlertDialogHeader>
        <AlertDialogTitle>{currentConfig.title}</AlertDialogTitle>
      </AlertDialogHeader>

      <AlertDialogDescription className="group relative w-full">
        <label
          className="absolute top-1/2 block -translate-y-1/2 cursor-text px-1 text-sm text-muted-foreground/70 transition-all group-focus-within:pointer-events-none group-focus-within:top-0 group-focus-within:cursor-default group-focus-within:text-xs group-focus-within:font-medium group-focus-within:text-foreground has-[+input:not(:placeholder-shown)]:pointer-events-none has-[+input:not(:placeholder-shown)]:top-0 has-[+input:not(:placeholder-shown)]:cursor-default has-[+input:not(:placeholder-shown)]:text-xs has-[+input:not(:placeholder-shown)]:font-medium has-[+input:not(:placeholder-shown)]:text-foreground"
          htmlFor="url"
        >
          <span className="inline-flex bg-background px-2">URL</span>
        </label>
        <Input
          id="url"
          className="w-full"
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter") embedMedia();
          }}
          placeholder=""
          type="url"
          autoFocus
        />
      </AlertDialogDescription>

      <AlertDialogFooter>
        <AlertDialogCancel>Cancel</AlertDialogCancel>
        <AlertDialogAction
          onClick={(e) => {
            e.preventDefault();
            embedMedia();
          }}
        >
          Accept
        </AlertDialogAction>
      </AlertDialogFooter>
    </>
  );
}

// ========== FILE END: ui/menus/buttons/media-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/buttons/outdent-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import { useOutdentButton } from "@udecode/plate-indent/react";
import { Outdent } from "lucide-react";

import { ToolbarButton } from "../../menus/toolbars/toolbar";

export function OutdentToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const { props: buttonProps } = useOutdentButton();

  return (
    <ToolbarButton {...props} {...buttonProps} tooltip="Outdent">
      <Outdent />
    </ToolbarButton>
  );
}

// ========== FILE END: ui/menus/buttons/outdent-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/buttons/suggestion-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import { SuggestionPlugin } from "@udecode/plate-suggestion/react";
import { useEditorPlugin, usePluginOption } from "@udecode/plate/react";
import { PencilLineIcon } from "lucide-react";

import { cn } from "@/lib/utils";

import { ToolbarButton } from "../../menus/toolbars/toolbar";

export function SuggestionToolbarButton() {
  const { setOption } = useEditorPlugin(SuggestionPlugin);
  const isSuggesting = usePluginOption(SuggestionPlugin, "isSuggesting");

  return (
    <ToolbarButton
      className={cn(isSuggesting && "text-brand/80 hover:text-brand/80")}
      onClick={() => setOption("isSuggesting", !isSuggesting)}
      onMouseDown={(e) => e.preventDefault()}
      tooltip={isSuggesting ? "Turn off suggesting" : "Suggestion edits"}
    >
      <PencilLineIcon />
    </ToolbarButton>
  );
}

// ========== FILE END: ui/menus/buttons/suggestion-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/buttons/toggle-toolbar-button.tsx ==========
"use client";

import * as React from "react";

import {
  useToggleToolbarButton,
  useToggleToolbarButtonState,
} from "@udecode/plate-toggle/react";
import { ListCollapseIcon } from "lucide-react";

import { ToolbarButton } from "../../menus/toolbars/toolbar";

export function ToggleToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const state = useToggleToolbarButtonState();
  const { props: buttonProps } = useToggleToolbarButton(state);

  return (
    <ToolbarButton {...props} {...buttonProps} tooltip="Toggle">
      <ListCollapseIcon />
    </ToolbarButton>
  );
}

// ========== FILE END: ui/menus/buttons/toggle-toolbar-button.tsx ==========



// ========== FILE START: ui/menus/comments/floating-discussion.tsx ==========
"use client";

import React, { useEffect, useReducer, useRef, useState } from "react";

import {
  type Node,
  type NodeEntry,
  type SlateEditor,
  type TElement,
  ElementApi,
  NodeApi,
  PathApi,
  TextApi,
} from "@udecode/plate";
import { type TCommentText, getDraftCommentKey } from "@udecode/plate-comments";
import { BlockSelectionPlugin } from "@udecode/plate-selection/react";
import {
  type TSuggestionText,
  acceptSuggestion,
  getSuggestionKey,
  keyId2SuggestionId,
  rejectSuggestion,
} from "@udecode/plate-suggestion";
import {
  useEditorContainerRef,
  useEditorMounted,
  useEditorPlugin,
  useEditorSelector,
  useEditorVersion,
  usePluginOption,
} from "@udecode/plate/react";
import {
  type PlateEditor,
  useEditorRef,
  usePluginOptions,
} from "@udecode/plate/react";
import { CheckIcon, PencilLineIcon, XIcon } from "lucide-react";

import { cn } from "@/lib/utils";
import { ExtendedCommentsPlugin } from "../../../plugins/comments/ExtendedCommentsPlugin";
import { suggestionPlugin as ExtendedSuggestionPlugin } from "../../../plugins/suggestion-plugin";
import { useDebouncedCallback } from "@/hooks/use-debounce-callback";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";

import {
  type TDiscussion,
  discussionPlugin,
} from "../../../plugins/discussion-plugin";
import {
  type ResolvedSuggestion,
  BLOCK_SUGGESTION,
  TYPE_TEXT_MAP,
} from "../../../ui/elements/comments-suggestions/block-suggestion";
import {
  Comment,
  useRelativeDate,
} from "../../../ui/elements/comments-suggestions/comment";
import { CommentCreateForm } from "../../../ui/elements/comments-suggestions/comment-create-form";

export const AfterEditableComments = () => {
  const mounted = useEditorMounted();
  const isOverlapWithEditor = usePluginOption(
    ExtendedCommentsPlugin,
    "isOverlapWithEditor",
  );

  if (!mounted || isOverlapWithEditor) return;

  return <FloatingDiscussion />;
};

const getCommentTop = (
  editor: SlateEditor,
  {
    node,
    relativeElement,
    topOffset = 30,
  }: {
    node: TCommentText | TElement | TSuggestionText;
    relativeElement: HTMLDivElement;
    topOffset?: number;
  },
) => {
  const commentLeafDomNode = editor.api.toDOMNode(node);

  if (!commentLeafDomNode) return 0;

  const relativeElementRect = relativeElement.getBoundingClientRect();
  const scrollTop = relativeElement.scrollTop;
  const commentLeafRect = commentLeafDomNode.getBoundingClientRect();

  const top = commentLeafRect.top - relativeElementRect.top + scrollTop;

  return top > topOffset ? top - topOffset : 0;
};

const updateActiveBelow = (
  topMap: Record<string, number>,
  domMap: Record<string, HTMLDivElement | null>,
  activeId: string,
) => {
  const discussionArray = Object.entries(topMap)
    .map(([id, top]) => ({ id, top }))
    .sort((a, b) => a.top - b.top);

  const activeIndex = discussionArray.findIndex(({ id }) => id === activeId);

  if (activeIndex === -1 || activeIndex === discussionArray.length - 1)
    return topMap;

  const activeElement = discussionArray[activeIndex];
  const start = activeElement.top;
  const end = start + (domMap[activeId]?.clientHeight ?? 100);

  const nextElement = discussionArray[activeIndex + 1];
  const nextStart = nextElement.top;

  // Check if next element overlaps with active element
  if (nextStart <= end) {
    // Move all following elements down
    const offset = end - nextStart + 10; // Add 10px gap

    for (let i = activeIndex + 1; i < discussionArray.length; i++) {
      discussionArray[i].top += offset;
    }

    return Object.fromEntries(discussionArray.map((d) => [d.id, d.top]));
  }

  return topMap;
};

const updateActiveTop = (
  topMap: Record<string, number>,
  domMap: Record<string, HTMLDivElement | null>,
  activeId: string,
  targetTop: number,
) => {
  const discussionArray = Object.entries(topMap)
    .map(([id, top]) => ({ id, top }))
    .sort((a, b) => a.top - b.top);

  const index = discussionArray.findIndex(({ id }) => id === activeId);

  if (index === -1) return topMap;

  const currentTop = discussionArray[index].top;
  const diff = targetTop - currentTop;

  // Set position of active element
  discussionArray[index].top = targetTop;

  if (diff < 0) {
    // Moving up - check for overlaps with previous elements
    for (let i = index - 1; i >= 0; i--) {
      const currentElement = discussionArray[i];
      const nextElement = discussionArray[i + 1];
      const elementHeight = domMap[currentElement.id]?.clientHeight ?? 100;

      // Check if current element overlaps with next element
      if (currentElement.top + elementHeight + 10 > nextElement.top) {
        // Move current element up to avoid overlap
        currentElement.top = nextElement.top - elementHeight - 10;
      } else {
        break; // No more overlaps
      }
    }
  } else {
    // Moving down - check for overlaps with next elements
    const activeHeight = domMap[activeId]?.clientHeight ?? 100;
    let activeBottom = targetTop + activeHeight + 10;

    // Only move elements that would overlap with active element
    for (let i = index + 1; i < discussionArray.length; i++) {
      if (discussionArray[i].top < activeBottom) {
        discussionArray[i].top = activeBottom;
        activeBottom =
          discussionArray[i].top +
          (domMap[discussionArray[i].id]?.clientHeight ?? 100) +
          10;
      } else {
        break; // No more overlaps
      }
    }
  }

  return Object.fromEntries(discussionArray.map((d) => [d.id, d.top]));
};

const updateTopCommenting = (
  topMap: Record<string, number>,
  domMap: Record<string, HTMLDivElement | null>,
) => {
  const discussionArray = Object.entries(topMap)
    .map(([id, topDistance]) => ({ id, topDistance }))
    .sort((a, b) => a.topDistance - b.topDistance);

  const index = discussionArray.findIndex(
    ({ id }) => id === getDraftCommentKey(),
  );

  if (index === -1) return topMap;

  const targetTopDistance = discussionArray[index].topDistance;

  // Find if any elements need to move up or down
  let moveDistance = 0;

  for (let i = 0; i < discussionArray.length; i++) {
    const current = discussionArray[i];
    const currentHeight = domMap[current.id]?.clientHeight ?? 100;

    if (i < index) {
      // Check if element needs to move up
      const minRequiredSpace = targetTopDistance - (currentHeight + 10);

      if (current.topDistance > minRequiredSpace) {
        const distance = current.topDistance - minRequiredSpace;
        moveDistance = Math.max(moveDistance, distance);
      }
    }
  }

  // Move elements up if needed
  if (moveDistance > 0) {
    for (let i = 0; i < index; i++) {
      discussionArray[i].topDistance -= moveDistance;
    }
  }

  // Check if next element overlaps with current element
  const currentHeight = domMap[discussionArray[index].id]?.clientHeight ?? 100;
  const currentBottom = targetTopDistance + currentHeight + 10;

  if (index + 1 < discussionArray.length) {
    const nextElement = discussionArray[index + 1];

    if (nextElement.topDistance < currentBottom) {
      // Only move elements that overlap
      let currentTop = currentBottom;

      for (let i = index + 1; i < discussionArray.length; i++) {
        const element = discussionArray[i];

        if (element.topDistance < currentTop) {
          element.topDistance = currentTop;
          const elementHeight = domMap[element.id]?.clientHeight ?? 100;
          currentTop += elementHeight + 10;
        } else {
          break; // No more overlaps
        }
      }
    }
  }

  return Object.fromEntries(discussionArray.map((d) => [d.id, d.topDistance]));
};

const resolveOverlappingTop = (
  topMap: Record<string, number>,
  domMap: Record<string, HTMLDivElement | null>,
) => {
  const discussionArray = Object.entries(topMap)
    .map(([id, topDistance]) => ({ id, topDistance }))
    .sort((a, b) => a.topDistance - b.topDistance);

  // Iterate through each discussion from top to bottom, checking for overlap with previous discussions
  for (let i = 1; i < discussionArray.length; i++) {
    const currentDiscussion = discussionArray[i];
    const currentElement = domMap[currentDiscussion.id];

    if (!currentElement) continue;

    // Calculate the range of current discussion
    const currentStart = currentDiscussion.topDistance;
    const currentEnd = currentStart + currentElement.clientHeight;

    // Check for overlap with all previous discussions
    for (let j = 0; j < i; j++) {
      const previousDiscussion = discussionArray[j];
      const previousElement = domMap[previousDiscussion.id];

      if (!previousElement) continue;

      const previousStart = previousDiscussion.topDistance;
      const previousEnd = previousStart + previousElement.clientHeight;

      // Check for overlap: condition for two intervals overlapping
      if (
        (currentStart <= previousEnd && currentEnd >= previousStart) ||
        (previousStart <= currentEnd && previousEnd >= currentStart)
      ) {
        // If overlapping, move current discussion below the previous one
        currentDiscussion.topDistance = previousEnd + 10;
        // Update current discussion range and check for overlaps again
        i--;

        break;
      }
    }
  }

  return Object.fromEntries(discussionArray.map((d) => [d.id, d.topDistance]));
};

const useCommentingNode = () => {
  return useEditorSelector((editor) => {
    if (!editor.selection || editor.api.isExpanded()) return;

    return editor.api.node<TCommentText>({
      match: (n) =>
        TextApi.isText(n) &&
        n[ExtendedCommentsPlugin.key] &&
        n[getDraftCommentKey()],
    })?.[0];
  }, []);
};

export const FloatingDiscussion = () => {
  const editorContainerRef = useEditorContainerRef();
  const editor = useEditorRef();
  const commentApi = editor.getApi(ExtendedCommentsPlugin);
  const suggestionApi = editor.getApi(ExtendedSuggestionPlugin);

  const activeCommentId = usePluginOption(ExtendedCommentsPlugin, "activeId");
  const activeSuggestionId = usePluginOption(
    ExtendedSuggestionPlugin,
    "activeId",
  );
  const activeId = activeCommentId ?? activeSuggestionId;
  const isOverlapWithEditor = usePluginOption(
    ExtendedCommentsPlugin,
    "isOverlapWithEditor",
  );
  const updateTimestamp = usePluginOption(
    ExtendedCommentsPlugin,
    "updateTimestamp",
  );

  const discussions = usePluginOption(discussionPlugin, "discussions");
  const domRef = React.useRef<Record<string, HTMLDivElement | null>>({});
  const topRef = React.useRef<Record<string, number>>({});

  const [, forceUpdate] = useReducer((x) => x + 1, 0);

  const commentingNode = useCommentingNode();
  const version = useEditorVersion();

  const suggestionEntriesMap = useRef<
    Record<string, NodeEntry<TElement | TSuggestionText>[]>
  >({});

  useEffect(() => {
    suggestionEntriesMap.current = {};

    const allSuggestionNodes = suggestionApi.suggestion.nodes({ at: [] });

    const suggestionIds = new Set(
      allSuggestionNodes
        .flatMap(([node]) => {
          if (TextApi.isText(node)) {
            const dataList = suggestionApi.suggestion.dataList(node);
            const includeUpdate = dataList.some(
              (data) => data.type === "update",
            );

            if (!includeUpdate) return suggestionApi.suggestion.nodeId(node);

            return dataList
              .filter((data) => data.type === "update")
              .map((d) => d.id);
          }
          if (ElementApi.isElement(node)) {
            return suggestionApi.suggestion.nodeId(node);
          }
        })
        .filter(Boolean),
    );

    suggestionIds.forEach((id) => {
      if (!id) return;

      const entries = [
        ...editor.api.nodes<TElement | TSuggestionText>({
          at: [],
          mode: "all",
          match: (n) =>
            (n[ExtendedSuggestionPlugin.key] && n[getSuggestionKey(id)]) ||
            suggestionApi.suggestion.nodeId(n as TElement) === id,
        }),
      ];

      suggestionEntriesMap.current[id] = entries;
    });
  }, [editor, suggestionApi.suggestion, version]);

  const suggestionList = Object.entries(suggestionEntriesMap.current).map(
    ([id, entries]) => ({
      id,
      entries,
    }),
  );

  const renderFloatingDiscussion = React.useCallback(() => {
    if (isOverlapWithEditor) return;

    topRef.current = {};

    discussions.forEach((discussion) => {
      if (
        discussion.isResolved ||
        !commentApi.comment.has({ id: discussion.id })
      )
        return;

      const commentLeafEntry = commentApi.comment.node({
        id: discussion.id,
        at: [],
      });

      if (!commentLeafEntry) return;

      const commentLeaf = commentLeafEntry[0];

      const topDistance = getCommentTop(editor, {
        node: commentLeaf,
        relativeElement: editorContainerRef.current!,
      });

      topRef.current[discussion.id] = topDistance;
    });

    suggestionList.forEach(({ id, entries }) => {
      if (!id) return;

      const topDistance = getCommentTop(editor, {
        node: entries[0][0],
        relativeElement: editorContainerRef.current!,
      });
      topRef.current[id] = topDistance;
    });

    topRef.current = resolveOverlappingTop(topRef.current, domRef.current);
    forceUpdate();

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    discussions.length,
    suggestionList.length,
    editorContainerRef,
    isOverlapWithEditor,
  ]);

  const renderFloatingCreateForm = React.useCallback(() => {
    if (!commentingNode || activeId !== getDraftCommentKey()) return;

    const topDistance = getCommentTop(editor, {
      node: commentingNode,
      relativeElement: editorContainerRef.current!,
    });

    topRef.current[getDraftCommentKey()] = topDistance;

    topRef.current = updateTopCommenting(topRef.current, domRef.current);

    forceUpdate();
  }, [activeId, commentingNode, editor, editorContainerRef]);

  const debouncedUpdateFloat = useDebouncedCallback(
    renderFloatingDiscussion,
    500,
  );

  useEffect(() => {
    if (updateTimestamp) {
      debouncedUpdateFloat();
    }
  }, [debouncedUpdateFloat, updateTimestamp]);

  useEffect(() => {
    if (!discussions) return;

    setTimeout(() => {
      renderFloatingDiscussion();
    }, 0);
  }, [discussions, renderFloatingDiscussion]);

  useEffect(() => {
    if (!activeId || !domRef.current[activeId]) return;

    const resizeObserver = new ResizeObserver(() => {
      topRef.current = updateActiveBelow(
        topRef.current,
        domRef.current,
        activeId,
      );

      forceUpdate();
    });
    resizeObserver.observe(domRef.current[activeId]);

    return () => {
      resizeObserver.disconnect();
    };
  }, [activeId]);

  useEffect(() => {
    if (!activeId) {
      return renderFloatingDiscussion();
    }

    const activeNode = commentApi.comment.node({ id: activeId, at: [] });
    const activeSuggestionNode = suggestionApi.suggestion.node({
      id: activeId,
      at: [],
      isText: true,
    });

    if (!activeNode && !activeSuggestionNode) return;

    topRef.current = updateActiveTop(
      topRef.current,
      domRef.current,
      activeId,
      getCommentTop(editor, {
        node: activeNode?.[0] || activeSuggestionNode![0],
        relativeElement: editorContainerRef.current!,
      }),
    );

    forceUpdate();
  }, [
    activeId,
    editor,
    commentingNode,
    editorContainerRef,
    renderFloatingDiscussion,
    commentApi.comment,
    suggestionApi.suggestion,
  ]);

  useEffect(() => {
    if (!commentingNode || !domRef.current[getDraftCommentKey()]) {
      return;
    }

    const resizeObserver = new ResizeObserver(() => {
      renderFloatingCreateForm();
    });
    resizeObserver.observe(domRef.current[getDraftCommentKey()]!);

    return () => {
      resizeObserver.disconnect();
    };
  }, [
    commentingNode,
    editor,
    editorContainerRef,
    renderFloatingCreateForm,
    renderFloatingDiscussion,
  ]);

  useEffect(() => {
    if (!isOverlapWithEditor) {
      renderFloatingDiscussion();
    }
  }, [isOverlapWithEditor, renderFloatingDiscussion]);

  return (
    <>
      {/* Unsubmit comment */}
      {commentingNode && (
        <div
          ref={(el) => {
            domRef.current[getDraftCommentKey()] = el;
          }}
          className="absolute right-[80px] w-[288px] cursor-pointer rounded-lg border bg-white p-3 transition-transform duration-200"
          style={{
            top: topRef.current[getDraftCommentKey()] ?? -9999,
          }}
        >
          <CommentCreateForm focusOnMount />
        </div>
      )}

      {discussions.map(
        (discussion) =>
          !discussion.isResolved &&
          commentApi.comment.has({ id: discussion.id }) && (
            <FloatingCommentsContent
              key={discussion.id}
              ref={(el) => {
                domRef.current[discussion.id] = el;
              }}
              discussion={discussion}
              domRef={domRef}
              top={topRef.current[discussion.id] ?? 0}
            />
          ),
      )}

      {suggestionList.map(
        ({ id, entries }) =>
          id && (
            <FloatingSuggestionContent
              id={id}
              key={id}
              ref={(el) => {
                domRef.current[id] = el;
              }}
              entries={entries}
              top={topRef.current[id] ?? 0}
            />
          ),
      )}
    </>
  );
};

type FloatingCommentsContentProps = {
  discussion: TDiscussion;
  domRef: React.RefObject<Record<string, HTMLDivElement | null>>;
  top: number;
};

const FloatingCommentsContent = ({
  discussion,
  ref,
  top,
}: React.ComponentProps<"div"> & FloatingCommentsContentProps) => {
  const editor = useEditorRef();

  const { activeId, hoverId } = usePluginOptions(
    ExtendedCommentsPlugin,
    ({ activeId, hoverId }) => ({
      activeId,
      hoverId,
    }),
  );

  const [editingId, setEditingId] = React.useState<string | null>(null);

  const setHoverId = (id: string | null) => {
    // If dropdown menu open, do not unset the active state since it will make dropdown menu open in the wrong position
    // Notion has the same issue
    if (document.activeElement?.closest("[data-radix-menu-content]")) return;

    editor.setOption(ExtendedCommentsPlugin, "hoverId", id);
  };

  const highlightDiscussion = (editor: PlateEditor, id: string) => {
    editor.setOption(ExtendedCommentsPlugin, "activeId", id);
    editor.setOption(ExtendedSuggestionPlugin, "activeId", null);
    const leaf = editor.api.node({
      at: [],
      match: (n) =>
        TextApi.isText(n) &&
        n[ExtendedCommentsPlugin.key] &&
        editor.getApi(ExtendedCommentsPlugin).comment.nodeId(n) === id,
    });

    if (!leaf) return;

    const parent = NodeApi.get<Node>(editor, leaf[1].slice(0, 1));

    editor
      .getApi(BlockSelectionPlugin)
      .blockSelection.addSelectedRow(parent!.id as string, {
        clear: false,
        delay: 1000,
      });
  };

  return (
    <div
      ref={ref}
      className={cn(
        "absolute right-20 z-10 w-72 animate-fade-in cursor-pointer rounded-lg border bg-white p-3 transition-transform duration-200",
        "[&[data-hover=true][data-active=false]]:-translate-x-2 [&[data-hover=true][data-active=false]]:bg-zinc-50",
        "[&[data-active=true]]:-translate-x-2",
      )}
      style={{
        top,
      }}
      onClick={() => highlightDiscussion(editor, discussion.id)}
      onMouseEnter={() => setHoverId(discussion.id)}
      onMouseLeave={() => setHoverId(null)}
      data-active={activeId === discussion.id}
      data-discussion-id={discussion.id}
      data-hover={hoverId === discussion.id}
    >
      {discussion.comments.length >= 3 && activeId !== discussion.id ? (
        <>
          <Comment
            key={discussion.comments[0].id}
            onEditorClick={() => highlightDiscussion(editor, discussion.id)}
            comment={discussion.comments[0]}
            discussionLength={discussion.comments.length}
            documentContent={discussion?.documentContent}
            editingId={editingId}
            index={0}
            setEditingId={setEditingId}
          />
          <div className="relative mb-1 ml-[26px] flex h-7 items-center rounded-md pl-1.5 text-sm text-muted-foreground hover:bg-muted">
            <div className="absolute top-[-5px] left-[-14px] h-full w-0.5 shrink-0 bg-muted" />
            <div className="ml-2">
              Show {discussion.comments.length - 2} replies
            </div>
          </div>
          <Comment
            key={discussion.comments.at(-1)!.id}
            onEditorClick={() => highlightDiscussion(editor, discussion.id)}
            comment={discussion.comments.at(-1)!}
            discussionLength={discussion.comments.length}
            documentContent={discussion?.documentContent}
            editingId={editingId}
            index={discussion.comments.length - 1}
            setEditingId={setEditingId}
          />
        </>
      ) : (
        discussion.comments.map((comment, index) => (
          <Comment
            key={comment.id ?? index}
            onEditorClick={() => highlightDiscussion(editor, discussion.id)}
            comment={comment}
            discussionLength={discussion.comments.length}
            documentContent={discussion?.documentContent}
            editingId={editingId}
            index={index}
            setEditingId={setEditingId}
          />
        ))
      )}

      {activeId === discussion.id && (
        <CommentCreateForm discussionId={discussion.id} />
      )}
    </div>
  );
};

FloatingCommentsContent.displayName = "FloatingCommentContent";

type FloatingSuggestionContentProps = {
  id: string;
  entries: NodeEntry<TElement | TSuggestionText>[];
  top: number;
};

const FloatingSuggestionContent = ({
  id,
  entries,
  ref,
  top,
}: React.ComponentProps<"div"> & FloatingSuggestionContentProps) => {
  const { api, editor, setOption } = useEditorPlugin(ExtendedSuggestionPlugin);
  const nodeData = api.suggestion.suggestionData(entries[0][0]);
  const relativeDate = useRelativeDate(
    nodeData ? new Date(nodeData.createdAt) : new Date(),
  );

  const { activeId, hoverId } = usePluginOptions(
    ExtendedSuggestionPlugin,
    ({ activeId, hoverId }) => ({
      activeId,
      hoverId,
    }),
  );

  const userId = usePluginOption(discussionPlugin, "currentUserId");
  const userData = usePluginOption(discussionPlugin, "user", userId);
  const discussions = usePluginOption(discussionPlugin, "discussions");

  const [editingId, setEditingId] = useState<string | null>(null);

  if (entries.length === 0) return null;

  // move line break to the end
  entries.sort(([, path1], [, path2]) => {
    return PathApi.isChild(path1, path2) ? -1 : 1;
  });

  let newText = "";
  let text = "";
  let properties: any = {};
  let newProperties: any = {};

  // overlapping suggestion
  entries.forEach(([node]) => {
    if (TextApi.isText(node)) {
      const dataList = api.suggestion.dataList(node);

      dataList.forEach((data) => {
        if (data.id !== id) return;

        switch (data.type) {
          case "insert": {
            newText += node.text;

            break;
          }
          case "remove": {
            text += node.text;

            break;
          }
          case "update": {
            properties = {
              ...properties,
              ...data.properties,
            };
            newProperties = {
              ...newProperties,
              ...data.newProperties,
            };
            newText += node.text;

            break;
          }
        }
      });
    } else {
      const lineBreakData = api.suggestion.isBlockSuggestion(node)
        ? node.suggestion
        : undefined;

      if (lineBreakData?.id !== keyId2SuggestionId(id)) return;
      if (lineBreakData.type === "insert") {
        newText += lineBreakData.isLineBreak
          ? BLOCK_SUGGESTION
          : BLOCK_SUGGESTION + TYPE_TEXT_MAP[node.type](node);
      } else if (lineBreakData.type === "remove") {
        text += lineBreakData.isLineBreak
          ? BLOCK_SUGGESTION
          : BLOCK_SUGGESTION + TYPE_TEXT_MAP[node.type](node);
      }
    }
  });

  if (!nodeData) return null;

  const comments = discussions.find((d) => d.id === id)?.comments || [];
  const createdAt = new Date(nodeData.createdAt);
  const keyId = getSuggestionKey(id);

  const suggestionText2Array = (text: string) => {
    if (text === BLOCK_SUGGESTION) return ["line breaks"];

    return text.split(BLOCK_SUGGESTION).filter(Boolean);
  };

  const accept = (suggestion: ResolvedSuggestion) => {
    api.suggestion.withoutSuggestions(() => {
      acceptSuggestion(editor, suggestion);
    });
  };

  const reject = (suggestion: ResolvedSuggestion) => {
    api.suggestion.withoutSuggestions(() => {
      rejectSuggestion(editor, suggestion);
    });
  };

  let suggestion: ResolvedSuggestion;

  if (nodeData.type === "update") {
    suggestion = {
      comments,
      createdAt,
      keyId,
      newProperties,
      newText,
      properties,
      suggestionId: keyId2SuggestionId(id),
      type: "update",
      userId: nodeData.userId,
    };
  } else if (newText.length > 0 && text.length > 0) {
    suggestion = {
      comments,
      createdAt,
      keyId,
      newText,
      suggestionId: keyId2SuggestionId(id),
      text,
      type: "replace",
      userId: nodeData.userId,
    };
  } else if (newText.length > 0) {
    suggestion = {
      comments,
      createdAt,
      keyId,
      newText,
      suggestionId: keyId2SuggestionId(id),
      type: "insert",
      userId: nodeData.userId,
    };
  } else if (text.length > 0) {
    suggestion = {
      comments,
      createdAt,
      keyId,
      suggestionId: keyId2SuggestionId(id),
      text,
      type: "remove",
      userId: nodeData.userId,
    };
  } else {
    return null;
  }

  const highlightSuggestion = (editor: PlateEditor, id: string) => {
    editor.setOption(ExtendedSuggestionPlugin, "activeId", id);
    editor.setOption(ExtendedCommentsPlugin, "activeId", null);

    const leaf = editor.api.node({
      at: [],
      match: (n) =>
        n[ExtendedSuggestionPlugin.key] &&
        editor.getApi(ExtendedSuggestionPlugin).suggestion.nodeId(n as any) ===
          id,
    });

    if (!leaf) return;

    const parent = NodeApi.get<Node>(editor, leaf[1].slice(0, 1));

    editor
      .getApi(BlockSelectionPlugin)
      .blockSelection.addSelectedRow(parent!.id as string, {
        clear: false,
        delay: 1000,
      });
  };

  return (
    <div
      ref={ref}
      className={cn(
        "absolute right-20 z-10 w-72 animate-fade-in cursor-pointer rounded-lg border bg-white p-3 transition-transform duration-200",
        "[&[data-hover=true][data-active=false]]:-translate-x-2 [&[data-hover=true][data-active=false]]:bg-zinc-50",
        "[&[data-active=true]]:-translate-x-2",
      )}
      style={{ top }}
      onClick={() => highlightSuggestion(editor, id)}
      onMouseEnter={() => setOption("hoverId", id)}
      onMouseLeave={() => setOption("hoverId", null)}
      data-active={activeId === id}
      data-discussion-id={id}
      data-hover={hoverId === id}
    >
      <div className="flex flex-col">
        <div className="relative flex items-center">
          {userData && (
            <>
              <Avatar className="relative mr-2 size-6">
                <AvatarImage alt={userData.name} src={userData.avatarUrl} />
                <AvatarFallback>{userData.name?.[0]}</AvatarFallback>
              </Avatar>
              <PencilLineIcon className="absolute -bottom-2 left-4 size-4 rounded-[50%] bg-brand-foreground p-0.5 text-brand/80" />
            </>
          )}
          <h4 className="text-sm leading-none font-semibold">
            {userData?.name}
          </h4>
          <div className="ml-1.5 text-xs leading-none text-muted-foreground/80">
            <span className="mr-1">{relativeDate}</span>
          </div>
        </div>

        <div className="relative mt-1 mb-4 pl-[32px]">
          <div className="flex flex-col gap-2">
            {suggestion.type === "remove" && (
              <React.Fragment>
                {suggestionText2Array(suggestion.text!).map((text, index) => (
                  <div key={index} className="flex items-center gap-2">
                    <span className="text-sm text-muted-foreground">
                      Delete:
                    </span>
                    <span className="text-sm">{text}</span>
                  </div>
                ))}
              </React.Fragment>
            )}

            {suggestion.type === "insert" && (
              <React.Fragment>
                {suggestionText2Array(suggestion.newText!).map(
                  (text, index) => (
                    <div key={index} className="flex items-center gap-2">
                      <span className="text-sm text-muted-foreground">
                        Add:
                      </span>
                      <span className="text-sm">"{text || "line breaks"}"</span>
                    </div>
                  ),
                )}
              </React.Fragment>
            )}

            {suggestion.type === "replace" && (
              <div className="flex flex-col gap-2">
                {suggestionText2Array(suggestion.newText!).map(
                  (text, index) => (
                    <React.Fragment key={index}>
                      <div className="flex items-center text-brand/80">
                        <span className="text-sm">With:</span>
                        <span className="text-sm">
                          "{text || "line breaks"}"
                        </span>
                      </div>
                    </React.Fragment>
                  ),
                )}

                {suggestionText2Array(suggestion.text!).map((text, index) => (
                  <React.Fragment key={index}>
                    <div className="flex items-center">
                      <span className="text-sm text-muted-foreground">
                        {index === 0 ? "Replace:" : "Delete:"}
                      </span>
                      <span className="text-sm">"{text || "line breaks"}"</span>
                    </div>
                  </React.Fragment>
                ))}
              </div>
            )}

            {suggestion.type === "update" && (
              <div className="flex items-center gap-2">
                <span className="text-sm text-muted-foreground">
                  {Object.keys(suggestion.properties).map((key) => (
                    <span key={key}>Un{key}</span>
                  ))}
                  {Object.keys(suggestion.newProperties).map((key) => (
                    <span key={key}>
                      {key.charAt(0).toUpperCase() + key.slice(1)}
                    </span>
                  ))}
                </span>
                <span className="text-sm">"{suggestion.newText}"</span>
              </div>
            )}
          </div>
        </div>

        {suggestion.comments.length >= 3 && activeId !== id ? (
          <>
            <Comment
              key={suggestion.comments[0].id}
              comment={suggestion.comments[0]}
              discussionLength={suggestion.comments.length}
              documentContent="__suggestion__"
              editingId={editingId}
              index={0}
              setEditingId={setEditingId}
            />
            <div className="relative mb-1 ml-[26px] flex h-7 items-center rounded-md pl-1.5 text-sm text-muted-foreground hover:bg-muted">
              <div className="absolute top-[-5px] left-[-14px] h-full w-0.5 shrink-0 bg-muted" />
              <div className="ml-2">
                Show {suggestion.comments.length - 2} replies
              </div>
            </div>
            <Comment
              key={suggestion.comments.at(-1)!.id}
              comment={suggestion.comments.at(-1)!}
              discussionLength={suggestion.comments.length}
              documentContent="__suggestion__"
              editingId={editingId}
              index={suggestion.comments.length - 1}
              setEditingId={setEditingId}
            />
          </>
        ) : (
          suggestion.comments.map((comment, index) => (
            <Comment
              key={comment.id ?? index}
              comment={comment}
              discussionLength={suggestion.comments.length}
              documentContent="__suggestion__"
              editingId={editingId}
              index={index}
              setEditingId={setEditingId}
            />
          ))
        )}

        {hoverId === id && (
          <div className="absolute top-4 right-4 flex gap-2">
            <Button
              variant="ghost"
              className="h-6 p-1 text-muted-foreground"
              onClick={() => accept(suggestion)}
            >
              <CheckIcon className="size-4" />
            </Button>
            <Button
              variant="ghost"
              className="h-6 p-1 text-muted-foreground"
              onClick={() => reject(suggestion)}
            >
              <XIcon className="size-4" />
            </Button>
          </div>
        )}

        {activeId === id && (
          <CommentCreateForm discussionId={suggestion.suggestionId} />
        )}
      </div>
    </div>
  );
};

// ========== FILE END: ui/menus/comments/floating-discussion.tsx ==========



// ========== FILE START: ui/menus/emoji/emoji-dropdown-menu.tsx ==========
"use client";

import * as React from "react";

import {
  type EmojiDropdownMenuOptions,
  useEmojiDropdownMenuState,
} from "@udecode/plate-emoji/react";
import { Smile } from "lucide-react";

import {
  emojiCategoryIcons,
  emojiSearchIcons,
} from "../../../constants/emoji-icons";
import { EmojiPicker } from "./emoji-picker";
import { EmojiToolbarDropdown } from "./emoji-toolbar-dropdown";
import { ToolbarButton } from "../../menus/toolbars/toolbar";

type EmojiDropdownMenuProps = {
  options?: EmojiDropdownMenuOptions;
} & React.ComponentPropsWithoutRef<typeof ToolbarButton>;

export function EmojiDropdownMenu({
  options,
  ...props
}: EmojiDropdownMenuProps) {
  const { emojiPickerState, isOpen, setIsOpen } =
    useEmojiDropdownMenuState(options);

  return (
    <EmojiToolbarDropdown
      control={
        <ToolbarButton pressed={isOpen} tooltip="Emoji" isDropdown {...props}>
          <Smile />
        </ToolbarButton>
      }
      isOpen={isOpen}
      setIsOpen={setIsOpen}
    >
      <EmojiPicker
        {...emojiPickerState}
        icons={{
          categories: emojiCategoryIcons,
          search: emojiSearchIcons,
        }}
        isOpen={isOpen}
        setIsOpen={setIsOpen}
        settings={options?.settings}
      />
    </EmojiToolbarDropdown>
  );
}

// ========== FILE END: ui/menus/emoji/emoji-dropdown-menu.tsx ==========



// ========== FILE START: ui/menus/emoji/emoji-input-element.tsx ==========
"use client";

import * as React from "react";

import type { PlateElementProps } from "@udecode/plate/react";

import { EmojiInlineIndexSearch, insertEmoji } from "@udecode/plate-emoji";
import { EmojiPlugin } from "@udecode/plate-emoji/react";
import { PlateElement, usePluginOption } from "@udecode/plate/react";

import { useDebounce } from "../../../../../hooks/use-debounce";

import {
  InlineCombobox,
  InlineComboboxContent,
  InlineComboboxEmpty,
  InlineComboboxGroup,
  InlineComboboxInput,
  InlineComboboxItem,
} from "../inline-combobox";

export function EmojiInputElement(props: PlateElementProps) {
  const { children, editor, element } = props;
  const data = usePluginOption(EmojiPlugin, "data")!;
  const [value, setValue] = React.useState("");
  const debouncedValue = useDebounce(value, 100);
  const isPending = value !== debouncedValue;

  const filteredEmojis = React.useMemo(() => {
    if (debouncedValue.trim().length === 0) return [];

    return EmojiInlineIndexSearch.getInstance(data)
      .search(debouncedValue.replace(/:$/, ""))
      .get();
  }, [data, debouncedValue]);

  return (
    <PlateElement as="span" data-slate-value={element.value} {...props}>
      <InlineCombobox
        value={value}
        element={element}
        filter={false}
        setValue={setValue}
        trigger=":"
        hideWhenNoValue
      >
        <InlineComboboxInput />

        <InlineComboboxContent>
          {!isPending && <InlineComboboxEmpty>No results</InlineComboboxEmpty>}

          <InlineComboboxGroup>
            {filteredEmojis.map((emoji) => (
              <InlineComboboxItem
                key={emoji.id}
                value={emoji.name}
                onClick={() => insertEmoji(editor, emoji)}
              >
                {emoji.skins[0].native} {emoji.name}
              </InlineComboboxItem>
            ))}
          </InlineComboboxGroup>
        </InlineComboboxContent>
      </InlineCombobox>

      {children}
    </PlateElement>
  );
}

// ========== FILE END: ui/menus/emoji/emoji-input-element.tsx ==========



// ========== FILE START: ui/menus/emoji/emoji-picker-content.tsx ==========
"use client";

import * as React from "react";

import type { UseEmojiPickerType } from "@udecode/plate-emoji/react";

import { type Emoji, type GridRow, EmojiSettings } from "@udecode/plate-emoji";

import { cn } from "@/lib/utils";

export type EmojiButtonProps = {
  emoji: Emoji;
  index: number;
  onMouseOver: (emoji?: Emoji) => void;
  onSelect: (emoji: Emoji) => void;
};

export type EmojiPickerContentProps = Pick<
  UseEmojiPickerType,
  | "emojiLibrary"
  | "i18n"
  | "isSearching"
  | "onMouseOver"
  | "onSelectEmoji"
  | "refs"
  | "searchResult"
  | "settings"
  | "visibleCategories"
>;

export type RowOfButtonsProps = {
  row: GridRow;
} & Pick<UseEmojiPickerType, "emojiLibrary" | "onMouseOver" | "onSelectEmoji">;

const Button = React.memo(
  ({ emoji, index, onMouseOver, onSelect }: EmojiButtonProps) => {
    return (
      <button
        className="group relative flex size-9 cursor-pointer items-center justify-center border-none bg-transparent text-2xl leading-none"
        onClick={() => onSelect(emoji)}
        onMouseEnter={() => onMouseOver(emoji)}
        onMouseLeave={() => onMouseOver()}
        aria-label={emoji.skins[0].native}
        data-index={index}
        tabIndex={-1}
        type="button"
      >
        <div
          className="absolute inset-0 rounded-full opacity-0 group-hover:opacity-100"
          aria-hidden="true"
        />
        <span
          className="relative"
          style={{
            fontFamily:
              '"Apple Color Emoji", "Segoe UI Emoji", NotoColorEmoji, "Noto Color Emoji", "Segoe UI Symbol", "Android Emoji", EmojiSymbols',
          }}
          data-emoji-set="native"
        >
          {emoji.skins[0].native}
        </span>
      </button>
    );
  },
);
Button.displayName = "Button";

const RowOfButtons = React.memo(
  ({ emojiLibrary, row, onMouseOver, onSelectEmoji }: RowOfButtonsProps) => (
    <div key={row.id} className="flex" data-index={row.id}>
      {row.elements.map((emojiId, index) => (
        <Button
          key={emojiId}
          onMouseOver={onMouseOver}
          onSelect={onSelectEmoji}
          emoji={emojiLibrary.getEmoji(emojiId)}
          index={index}
        />
      ))}
    </div>
  ),
);
RowOfButtons.displayName = "RowOfButtons";

export function EmojiPickerContent({
  emojiLibrary,
  i18n,
  isSearching = false,
  refs,
  searchResult,
  settings = EmojiSettings,
  visibleCategories,
  onMouseOver,
  onSelectEmoji,
}: EmojiPickerContentProps) {
  const getRowWidth = settings.perLine.value * settings.buttonSize.value;

  const isCategoryVisible = React.useCallback(
    (categoryId: any) => {
      return visibleCategories.has(categoryId)
        ? visibleCategories.get(categoryId)
        : false;
    },
    [visibleCategories],
  );

  const EmojiList = React.useCallback(() => {
    return emojiLibrary
      .getGrid()
      .sections()
      .map(({ id: categoryId }) => {
        const section = emojiLibrary.getGrid().section(categoryId);
        const { buttonSize } = settings;

        return (
          <div
            key={categoryId}
            ref={section.root}
            style={{ width: getRowWidth }}
            data-id={categoryId}
          >
            <div className="sticky -top-px z-1 bg-popover/90 p-1 py-2 text-sm font-semibold backdrop-blur-xs">
              {i18n.categories[categoryId]}
            </div>
            <div
              className="relative flex flex-wrap"
              style={{ height: section.getRows().length * buttonSize.value }}
            >
              {isCategoryVisible(categoryId) &&
                section
                  .getRows()
                  .map((row: GridRow) => (
                    <RowOfButtons
                      key={row.id}
                      onMouseOver={onMouseOver}
                      onSelectEmoji={onSelectEmoji}
                      emojiLibrary={emojiLibrary}
                      row={row}
                    />
                  ))}
            </div>
          </div>
        );
      });
  }, [
    emojiLibrary,
    getRowWidth,
    i18n.categories,
    isCategoryVisible,
    onSelectEmoji,
    onMouseOver,
    settings,
  ]);

  const SearchList = React.useCallback(() => {
    return (
      <div style={{ width: getRowWidth }} data-id="search">
        <div className="sticky -top-px z-1 bg-popover/90 p-1 py-2 text-sm font-semibold text-card-foreground backdrop-blur-xs">
          {i18n.searchResult}
        </div>
        <div className="relative flex flex-wrap">
          {searchResult.map((emoji: Emoji, index: number) => (
            <Button
              key={emoji.id}
              onMouseOver={onMouseOver}
              onSelect={onSelectEmoji}
              emoji={emojiLibrary.getEmoji(emoji.id)}
              index={index}
            />
          ))}
        </div>
      </div>
    );
  }, [
    emojiLibrary,
    getRowWidth,
    i18n.searchResult,
    searchResult,
    onSelectEmoji,
    onMouseOver,
  ]);

  return (
    <div
      ref={refs.current.contentRoot}
      className={cn(
        "h-full min-h-[50%] overflow-x-hidden overflow-y-auto px-2",
        "[&::-webkit-scrollbar]:w-4",
        "[&::-webkit-scrollbar-button]:hidden [&::-webkit-scrollbar-button]:size-0",
        "[&::-webkit-scrollbar-thumb]:min-h-11 [&::-webkit-scrollbar-thumb]:rounded-full [&::-webkit-scrollbar-thumb]:bg-muted [&::-webkit-scrollbar-thumb]:hover:bg-muted-foreground/25",
        "[&::-webkit-scrollbar-thumb]:border-4 [&::-webkit-scrollbar-thumb]:border-solid [&::-webkit-scrollbar-thumb]:border-popover [&::-webkit-scrollbar-thumb]:bg-clip-padding",
      )}
      data-id="scroll"
    >
      <div ref={refs.current.content} className="h-full">
        {isSearching ? SearchList() : EmojiList()}
      </div>
    </div>
  );
}

// ========== FILE END: ui/menus/emoji/emoji-picker-content.tsx ==========



// ========== FILE START: ui/menus/emoji/emoji-picker-navigation.tsx ==========
import type { EmojiCategoryList } from "@udecode/plate-emoji";
import type { UseEmojiPickerType } from "@udecode/plate-emoji/react";

import { Button } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";

export type EmojiPickerNavigationProps = {
  onClick: (id: EmojiCategoryList) => void;
} & Pick<
  UseEmojiPickerType,
  "emojiLibrary" | "focusedCategory" | "i18n" | "icons"
>;

// KEEP: This is for the animated idicator bar under the icon - Opt in if needed
// const getBarProperty = (
//   emojiLibrary: IEmojiFloatingLibrary,
//   focusedCategory?: EmojiCategoryList
// ) => {
//   let width = 0;
//   let position = 0;

//   if (focusedCategory) {
//     width = 100 / emojiLibrary.getGrid().size;
//     position = focusedCategory
//       ? emojiLibrary.indexOf(focusedCategory) * 100
//       : 0;
//   }

//   return { position, width };
// };

export function EmojiPickerNavigation({
  emojiLibrary,
  focusedCategory,
  i18n,
  icons,
  onClick,
}: EmojiPickerNavigationProps) {
  // KEEP: This is for the animated idicator bar under the icon - Opt in if needed
  // const { position, width } = useMemo(
  //   () => getBarProperty(emojiLibrary, focusedCategory),
  //   [emojiLibrary, focusedCategory]
  // );

  return (
    <TooltipProvider delayDuration={500}>
      <nav
        id="emoji-nav"
        className="mb-2.5 border-0 border-b border-solid border-b-border p-1.5"
      >
        <div className="relative flex items-center justify-evenly">
          {emojiLibrary
            .getGrid()
            .sections()
            .map(({ id }) => (
              <Tooltip key={id}>
                <TooltipTrigger asChild>
                  <Button
                    size="sm"
                    variant="ghost"
                    className={cn(
                      "h-fit rounded-full fill-current p-1.5 text-muted-foreground hover:bg-muted hover:text-muted-foreground",
                      id === focusedCategory &&
                        "pointer-events-none bg-accent fill-current text-accent-foreground",
                    )}
                    onClick={() => {
                      onClick(id);
                    }}
                    aria-label={i18n.categories[id]}
                    type="button"
                  >
                    <span className="inline-flex size-5 items-center justify-center">
                      {icons.categories[id].outline}
                    </span>
                  </Button>
                </TooltipTrigger>
                <TooltipContent side="bottom">
                  {i18n.categories[id]}
                </TooltipContent>
              </Tooltip>
            ))}

          {/* This is the animated indicator - Opt In if needed */}
          {/* <div
            className={cn(
              'absolute -bottom-1.5 left-0 h-0.5 w-full rounded-t-lg bg-accent opacity-100 transition-transform duration-200'
            )}
            style={{
              transform: `translateX(${position}%)`,
              visibility: `${focusedCategory ? 'visible' : 'hidden'}`,
              width: `${width}%`,
            }}
          /> */}
        </div>
      </nav>
    </TooltipProvider>
  );
}

// ========== FILE END: ui/menus/emoji/emoji-picker-navigation.tsx ==========



// ========== FILE START: ui/menus/emoji/emoji-picker-preview.tsx ==========
"use client";

import type { UseEmojiPickerType } from "@udecode/plate-emoji/react";

export type EmojiPickerPreviewProps = Pick<
  UseEmojiPickerType,
  "emoji" | "hasFound" | "i18n" | "isSearching"
>;

export type EmojiPreviewProps = Pick<UseEmojiPickerType, "emoji">;

export type NoEmojiPreviewProps = Pick<UseEmojiPickerType, "i18n">;

export type PickAnEmojiPreviewProps = NoEmojiPreviewProps;

function EmojiPreview({ emoji }: EmojiPreviewProps) {
  return (
    <div className="flex h-14 max-h-14 min-h-14 items-center border-t border-muted p-2">
      <div className="flex items-center justify-center text-2xl">
        {emoji?.skins[0].native}
      </div>
      <div className="overflow-hidden pl-2">
        <div className="truncate text-sm font-semibold">{emoji?.name}</div>
        <div className="truncate text-sm">{`:${emoji?.id}:`}</div>
      </div>
    </div>
  );
}

function NoEmoji({ i18n }: NoEmojiPreviewProps) {
  return (
    <div className="flex h-14 max-h-14 min-h-14 items-center border-t border-muted p-2">
      <div className="flex items-center justify-center text-2xl"></div>
      <div className="overflow-hidden pl-2">
        <div className="truncate text-sm font-bold">
          {i18n.searchNoResultsTitle}
        </div>
        <div className="truncate text-sm">{i18n.searchNoResultsSubtitle}</div>
      </div>
    </div>
  );
}

function PickAnEmoji({ i18n }: PickAnEmojiPreviewProps) {
  return (
    <div className="flex h-14 max-h-14 min-h-14 items-center border-t border-muted p-2">
      <div className="flex items-center justify-center text-2xl"></div>
      <div className="overflow-hidden pl-2">
        <div className="truncate text-sm font-semibold">{i18n.pick}</div>
      </div>
    </div>
  );
}

export function EmojiPickerPreview({
  emoji,
  hasFound = true,
  i18n,
  isSearching = false,
  ...props
}: EmojiPickerPreviewProps) {
  const showPickEmoji = !emoji && (!isSearching || hasFound);
  const showNoEmoji = isSearching && !hasFound;
  const showPreview = emoji && !showNoEmoji && !showNoEmoji;

  return (
    <>
      {showPreview && <EmojiPreview emoji={emoji} {...props} />}
      {showPickEmoji && <PickAnEmoji i18n={i18n} {...props} />}
      {showNoEmoji && <NoEmoji i18n={i18n} {...props} />}
    </>
  );
}

// ========== FILE END: ui/menus/emoji/emoji-picker-preview.tsx ==========



// ========== FILE START: ui/menus/emoji/emoji-picker-search-and-clear.tsx ==========
"use client";

import type { UseEmojiPickerType } from "@udecode/plate-emoji/react";

import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

import { emojiSearchIcons } from "../../../constants/emoji-icons";

export type EmojiPickerSearchAndClearProps = Pick<
  UseEmojiPickerType,
  "clearSearch" | "i18n" | "searchValue"
>;

export function EmojiPickerSearchAndClear({
  clearSearch,
  i18n,
  searchValue,
}: EmojiPickerSearchAndClearProps) {
  return (
    <div className="flex items-center text-foreground">
      <div
        className={cn(
          "absolute top-1/2 left-2.5 z-10 flex size-5 -translate-y-1/2 items-center justify-center text-foreground",
        )}
      >
        {emojiSearchIcons.loupe}
      </div>
      {searchValue && (
        <Button
          size="icon"
          variant="ghost"
          className={cn(
            "absolute top-1/2 right-0.5 flex size-8 -translate-y-1/2 cursor-pointer items-center justify-center rounded-full border-none bg-transparent text-popover-foreground hover:bg-transparent",
          )}
          onClick={clearSearch}
          title={i18n.clear}
          aria-label="Clear"
          type="button"
        >
          {emojiSearchIcons.delete}
        </Button>
      )}
    </div>
  );
}

// ========== FILE END: ui/menus/emoji/emoji-picker-search-and-clear.tsx ==========



// ========== FILE START: ui/menus/emoji/emoji-picker-search-bar.tsx ==========
"use client";

import * as React from "react";

import type { UseEmojiPickerType } from "@udecode/plate-emoji/react";

export type EmojiPickerSearchBarProps = {
  children: React.ReactNode;
} & Pick<UseEmojiPickerType, "i18n" | "searchValue" | "setSearch">;

export function EmojiPickerSearchBar({
  children,
  i18n,
  searchValue,
  setSearch,
}: EmojiPickerSearchBarProps) {
  return (
    <div className="flex items-center px-2">
      <div className="relative flex grow items-center">
        <input
          className="block w-full appearance-none rounded-full border-0 bg-muted px-10 py-2 text-sm outline-none placeholder:text-muted-foreground focus-visible:outline-none"
          value={searchValue}
          onChange={(event) => setSearch(event.target.value)}
          placeholder={i18n.search}
          aria-label="Search"
          autoComplete="off"
          type="text"
          autoFocus
        />
        {children}
      </div>
    </div>
  );
}

// ========== FILE END: ui/menus/emoji/emoji-picker-search-bar.tsx ==========



// ========== FILE START: ui/menus/emoji/emoji-picker.tsx ==========
"use client";

import * as React from "react";

import type { UseEmojiPickerType } from "@udecode/plate-emoji/react";

import { EmojiSettings } from "@udecode/plate-emoji";

import { cn } from "@/lib/utils";

import { EmojiPickerContent } from "./emoji-picker-content";
import { EmojiPickerNavigation } from "./emoji-picker-navigation";
import { EmojiPickerPreview } from "./emoji-picker-preview";
import { EmojiPickerSearchAndClear } from "./emoji-picker-search-and-clear";
import { EmojiPickerSearchBar } from "./emoji-picker-search-bar";

export function EmojiPicker({
  clearSearch,
  emoji,
  emojiLibrary,
  focusedCategory,
  hasFound,
  i18n,
  icons,
  isSearching,
  refs,
  searchResult,
  searchValue,
  setSearch,
  settings = EmojiSettings,
  visibleCategories,
  handleCategoryClick,
  onMouseOver,
  onSelectEmoji,
}: UseEmojiPickerType) {
  return (
    <div
      className={cn(
        "flex flex-col rounded-xl bg-popover text-popover-foreground",
        "h-[23rem] w-80 border shadow-md",
      )}
    >
      <EmojiPickerNavigation
        onClick={handleCategoryClick}
        emojiLibrary={emojiLibrary}
        focusedCategory={focusedCategory}
        i18n={i18n}
        icons={icons}
      />
      <EmojiPickerSearchBar
        i18n={i18n}
        searchValue={searchValue}
        setSearch={setSearch}
      >
        <EmojiPickerSearchAndClear
          clearSearch={clearSearch}
          i18n={i18n}
          searchValue={searchValue}
        />
      </EmojiPickerSearchBar>
      <EmojiPickerContent
        onMouseOver={onMouseOver}
        onSelectEmoji={onSelectEmoji}
        emojiLibrary={emojiLibrary}
        i18n={i18n}
        isSearching={isSearching}
        refs={refs}
        searchResult={searchResult}
        settings={settings}
        visibleCategories={visibleCategories}
      />
      <EmojiPickerPreview
        emoji={emoji}
        hasFound={hasFound}
        i18n={i18n}
        isSearching={isSearching}
      />
    </div>
  );
}

// ========== FILE END: ui/menus/emoji/emoji-picker.tsx ==========



// ========== FILE START: ui/menus/emoji/emoji-toolbar-dropdown.tsx ==========
"use client";

import * as React from "react";

import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";

type EmojiToolbarDropdownProps = {
  children: React.ReactNode;
  control: React.ReactNode;
  isOpen: boolean;
  setIsOpen: (open: boolean) => void;
};

export function EmojiToolbarDropdown({
  children,
  control,
  isOpen,
  setIsOpen,
}: EmojiToolbarDropdownProps) {
  return (
    <Popover open={isOpen} onOpenChange={setIsOpen}>
      <PopoverTrigger asChild>{control}</PopoverTrigger>
      <PopoverContent className="z-[100]">{children}</PopoverContent>
    </Popover>
  );
}

// ========== FILE END: ui/menus/emoji/emoji-toolbar-dropdown.tsx ==========



// ========== FILE START: ui/menus/equation/equation-popover.tsx ==========
"use client";

import * as React from "react";
import TextareaAutosize, {
  type TextareaAutosizeProps,
} from "react-textarea-autosize";

import type { TEquationElement } from "@udecode/plate-math";

import { useEquationInput } from "@udecode/plate-math/react";
import { BlockSelectionPlugin } from "@udecode/plate-selection/react";
import {
  createPrimitiveComponent,
  useEditorRef,
  useElement,
  useReadOnly,
} from "@udecode/plate/react";
import { CornerDownLeftIcon } from "lucide-react";

import { Button } from "@/components/ui/button";
import { PopoverContent } from "@/components/ui/popover";
import { cn } from "@/lib/utils";

const EquationInput = createPrimitiveComponent(TextareaAutosize)({
  propsHook: useEquationInput,
});

const EquationPopoverContent = ({
  className,
  isInline,
  open,
  setOpen,
  ...props
}: {
  isInline: boolean;
  open: boolean;
  setOpen: (open: boolean) => void;
} & TextareaAutosizeProps) => {
  const editor = useEditorRef();
  const readOnly = useReadOnly();
  const element = useElement<TEquationElement>();

  React.useEffect(() => {
    if (isInline && open) {
      setOpen(true);
    }
  }, [isInline, open, setOpen]);

  if (readOnly) return null;

  const onClose = () => {
    setOpen(false);

    if (isInline) {
      editor.tf.select(element, { next: true });
    } else {
      editor
        .getApi(BlockSelectionPlugin)
        .blockSelection.set(element.id as string);
    }
  };

  return (
    <PopoverContent
      className="flex gap-2"
      onEscapeKeyDown={(e) => {
        e.preventDefault();
      }}
      contentEditable={false}
    >
      <EquationInput
        className={cn("max-h-[50vh] grow resize-none p-2 text-sm", className)}
        state={{ isInline, open, onClose }}
        autoFocus
        {...props}
      />

      <Button variant="secondary" className="px-3" onClick={onClose}>
        Done <CornerDownLeftIcon className="size-3.5" />
      </Button>
    </PopoverContent>
  );
};

export { EquationPopoverContent };

// ========== FILE END: ui/menus/equation/equation-popover.tsx ==========



// ========== FILE START: ui/menus/inline-combobox.tsx ==========
"use client";

import * as React from "react";

import type { PointRef, TElement } from "@udecode/plate";

import {
  type ComboboxItemProps,
  Combobox,
  ComboboxGroup,
  ComboboxGroupLabel,
  ComboboxItem,
  ComboboxPopover,
  ComboboxProvider,
  ComboboxRow,
  Portal,
  useComboboxContext,
  useComboboxStore,
} from "@ariakit/react";
import { filterWords } from "@udecode/plate-combobox";
import {
  type UseComboboxInputResult,
  useComboboxInput,
  useHTMLInputCursorState,
} from "@udecode/plate-combobox/react";
import { useComposedRef, useEditorRef } from "@udecode/plate/react";
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils";

type FilterFn = (
  item: { value: string; group?: string; keywords?: string[]; label?: string },
  search: string,
) => boolean;

interface InlineComboboxContextValue {
  filter: FilterFn | false;
  inputProps: UseComboboxInputResult["props"];
  inputRef: React.RefObject<HTMLInputElement | null>;
  removeInput: UseComboboxInputResult["removeInput"];
  showTrigger: boolean;
  trigger: string;
  setHasEmpty: (hasEmpty: boolean) => void;
}

const InlineComboboxContext = React.createContext<InlineComboboxContextValue>(
  null as unknown as InlineComboboxContextValue,
);

export const defaultFilter: FilterFn = (
  { group, keywords = [], label, value },
  search,
) => {
  const uniqueTerms = new Set(
    [value, ...keywords, group, label].filter(Boolean),
  );

  return Array.from(uniqueTerms).some((keyword) =>
    filterWords(keyword!, search),
  );
};

interface InlineComboboxProps {
  children: React.ReactNode;
  element: TElement;
  trigger: string;
  filter?: FilterFn | false;
  hideWhenNoValue?: boolean;
  showTrigger?: boolean;
  value?: string;
  setValue?: (value: string) => void;
}

const InlineCombobox = ({
  children,
  element,
  filter = defaultFilter,
  hideWhenNoValue = false,
  setValue: setValueProp,
  showTrigger = true,
  trigger,
  value: valueProp,
}: InlineComboboxProps) => {
  const editor = useEditorRef();
  const inputRef = React.useRef<HTMLInputElement>(null);
  const cursorState = useHTMLInputCursorState(inputRef);

  const [valueState, setValueState] = React.useState("");
  const hasValueProp = valueProp !== undefined;
  const value = hasValueProp ? valueProp : valueState;

  const setValue = React.useCallback(
    (newValue: string) => {
      setValueProp?.(newValue);

      if (!hasValueProp) {
        setValueState(newValue);
      }
    },
    [setValueProp, hasValueProp],
  );

  /**
   * Track the point just before the input element so we know where to
   * insertText if the combobox closes due to a selection change.
   */
  const [insertPoint, setInsertPoint] = React.useState<PointRef | null>(null);

  React.useEffect(() => {
    const path = editor.api.findPath(element);

    if (!path) return;

    const point = editor.api.before(path);

    if (!point) return;

    const pointRef = editor.api.pointRef(point);
    setInsertPoint(pointRef);

    return () => {
      pointRef.unref();
    };
  }, [editor, element]);

  const { props: inputProps, removeInput } = useComboboxInput({
    cancelInputOnBlur: false,
    cursorState,
    ref: inputRef,
    onCancelInput: (cause) => {
      if (cause !== "backspace") {
        editor.tf.insertText(trigger + value, {
          at: insertPoint?.current ?? undefined,
        });
      }
      if (cause === "arrowLeft" || cause === "arrowRight") {
        editor.tf.move({
          distance: 1,
          reverse: cause === "arrowLeft",
        });
      }
    },
  });

  const [hasEmpty, setHasEmpty] = React.useState(false);

  const contextValue: InlineComboboxContextValue = React.useMemo(
    () => ({
      filter,
      inputProps,
      inputRef,
      removeInput,
      setHasEmpty,
      showTrigger,
      trigger,
    }),
    [
      trigger,
      showTrigger,
      filter,
      inputRef,
      inputProps,
      removeInput,
      setHasEmpty,
    ],
  );

  const store = useComboboxStore({
    // open: ,
    setValue: (newValue) => React.startTransition(() => setValue(newValue)),
  });

  const items = store.useState("items");

  /**
   * If there is no active ID and the list of items changes, select the first
   * item.
   */
  React.useEffect(() => {
    if (!store.getState().activeId) {
      store.setActiveId(store.first());
    }
  }, [items, store]);

  return (
    <span contentEditable={false}>
      <ComboboxProvider
        open={
          (items.length > 0 || hasEmpty) &&
          (!hideWhenNoValue || value.length > 0)
        }
        store={store}
      >
        <InlineComboboxContext.Provider value={contextValue}>
          {children}
        </InlineComboboxContext.Provider>
      </ComboboxProvider>
    </span>
  );
};

const InlineComboboxInput = React.forwardRef<
  HTMLInputElement,
  React.HTMLAttributes<HTMLInputElement>
>(({ className, ...props }, propRef) => {
  const {
    inputProps,
    inputRef: contextRef,
    showTrigger,
    trigger,
  } = React.useContext(InlineComboboxContext);

  const store = useComboboxContext()!;
  const value = store.useState("value");

  const ref = useComposedRef(propRef, contextRef);

  /**
   * To create an auto-resizing input, we render a visually hidden span
   * containing the input value and position the input element on top of it.
   * This works well for all cases except when input exceeds the width of the
   * container.
   */

  return (
    <>
      {showTrigger && trigger}

      <span className="relative min-h-[1lh]">
        <span
          className="invisible overflow-hidden text-nowrap"
          aria-hidden="true"
        >
          {value || "\u200B"}
        </span>

        <Combobox
          ref={ref}
          className={cn(
            "absolute top-0 left-0 size-full bg-transparent outline-none",
            className,
          )}
          value={value}
          autoSelect
          {...inputProps}
          {...props}
        />
      </span>
    </>
  );
});

InlineComboboxInput.displayName = "InlineComboboxInput";

const InlineComboboxContent: typeof ComboboxPopover = ({
  className,
  ...props
}) => {
  // Portal prevents CSS from leaking into popover
  return (
    <Portal>
      <ComboboxPopover
        className={cn(
          "z-500 max-h-[288px] w-[300px] overflow-y-auto rounded-md bg-popover shadow-md",
          className,
        )}
        {...props}
      />
    </Portal>
  );
};

const comboboxItemVariants = cva(
  "relative mx-1 flex h-[28px] items-center rounded-sm px-2 text-sm text-foreground outline-none select-none [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    defaultVariants: {
      interactive: true,
    },
    variants: {
      interactive: {
        false: "",
        true: "cursor-pointer transition-colors hover:bg-accent hover:text-accent-foreground data-[active-item=true]:bg-accent data-[active-item=true]:text-accent-foreground",
      },
    },
  },
);

export type InlineComboboxItemProps = {
  focusEditor?: boolean;
  group?: string;
  keywords?: string[];
  label?: string;
} & ComboboxItemProps &
  Required<Pick<ComboboxItemProps, "value">>;

const InlineComboboxItem = ({
  className,
  focusEditor = true,
  group,
  keywords,
  label,
  onClick,
  ...props
}: InlineComboboxItemProps) => {
  const { value } = props;

  const { filter, removeInput } = React.useContext(InlineComboboxContext);

  const store = useComboboxContext()!;

  // Optimization: Do not subscribe to value if filter is false
  const search = filter && store.useState("value");

  const visible = React.useMemo(
    () =>
      !filter || filter({ group, keywords, label, value }, search as string),
    [filter, group, keywords, label, value, search],
  );

  if (!visible) return null;

  return (
    <ComboboxItem
      className={cn(comboboxItemVariants(), className)}
      onClick={(event) => {
        removeInput(focusEditor);
        onClick?.(event);
      }}
      {...props}
    />
  );
};

const InlineComboboxEmpty = ({
  children,
  className,
}: React.HTMLAttributes<HTMLDivElement>) => {
  const { setHasEmpty } = React.useContext(InlineComboboxContext);
  const store = useComboboxContext()!;
  const items = store.useState("items");

  React.useEffect(() => {
    setHasEmpty(true);

    return () => {
      setHasEmpty(false);
    };
  }, [setHasEmpty]);

  if (items.length > 0) return null;

  return (
    <div
      className={cn(comboboxItemVariants({ interactive: false }), className)}
    >
      {children}
    </div>
  );
};

const InlineComboboxRow = ComboboxRow;

function InlineComboboxGroup({
  className,
  ...props
}: React.ComponentProps<typeof ComboboxGroup>) {
  return (
    <ComboboxGroup
      {...props}
      className={cn(
        "hidden py-1.5 not-last:border-b [&:has([role=option])]:block",
        className,
      )}
    />
  );
}

function InlineComboboxGroupLabel({
  className,
  ...props
}: React.ComponentProps<typeof ComboboxGroupLabel>) {
  return (
    <ComboboxGroupLabel
      {...props}
      className={cn(
        "mt-1.5 mb-2 px-3 text-xs font-medium text-muted-foreground",
        className,
      )}
    />
  );
}

export {
  InlineCombobox,
  InlineComboboxContent,
  InlineComboboxEmpty,
  InlineComboboxGroup,
  InlineComboboxGroupLabel,
  InlineComboboxInput,
  InlineComboboxItem,
  InlineComboboxRow,
};

// ========== FILE END: ui/menus/inline-combobox.tsx ==========



// ========== FILE START: ui/menus/insert-dropdown-menu.tsx ==========
"use client";

import * as React from "react";

import type { DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { BlockquotePlugin } from "@udecode/plate-block-quote/react";
import { CodeBlockPlugin } from "@udecode/plate-code-block/react";
import { DatePlugin } from "@udecode/plate-date/react";
import { ExcalidrawPlugin } from "@udecode/plate-excalidraw/react";
import { HEADING_KEYS } from "@udecode/plate-heading";
import { TocPlugin } from "@udecode/plate-heading/react";
import { HorizontalRulePlugin } from "@udecode/plate-horizontal-rule/react";
import { INDENT_LIST_KEYS, ListStyleType } from "@udecode/plate-indent-list";
import { LinkPlugin } from "@udecode/plate-link/react";
import {
  EquationPlugin,
  InlineEquationPlugin,
} from "@udecode/plate-math/react";
import { ImagePlugin, MediaEmbedPlugin } from "@udecode/plate-media/react";
import { TablePlugin } from "@udecode/plate-table/react";
import { TogglePlugin } from "@udecode/plate-toggle/react";
import {
  type PlateEditor,
  ParagraphPlugin,
  useEditorRef,
} from "@udecode/plate/react";
import {
  CalendarIcon,
  ChevronRightIcon,
  Columns3Icon,
  FileCodeIcon,
  FilmIcon,
  Heading1Icon,
  Heading2Icon,
  Heading3Icon,
  ImageIcon,
  Link2Icon,
  ListIcon,
  ListOrderedIcon,
  MinusIcon,
  PenToolIcon,
  PilcrowIcon,
  PlusIcon,
  QuoteIcon,
  RadicalIcon,
  SquareIcon,
  TableIcon,
  TableOfContentsIcon,
} from "lucide-react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { insertBlock, insertInlineElement } from "../../core/transforms";

import { ToolbarButton, ToolbarMenuGroup } from "./toolbars/toolbar";

type Group = {
  group: string;
  items: Item[];
};

interface Item {
  icon: React.ReactNode;
  value: string;
  onSelect: (editor: PlateEditor, value: string) => void;
  focusEditor?: boolean;
  label?: string;
}

const groups: Group[] = [
  {
    group: "Basic blocks",
    items: [
      {
        icon: <PilcrowIcon />,
        label: "Paragraph",
        value: ParagraphPlugin.key,
      },
      {
        icon: <Heading1Icon />,
        label: "Heading 1",
        value: HEADING_KEYS.h1,
      },
      {
        icon: <Heading2Icon />,
        label: "Heading 2",
        value: HEADING_KEYS.h2,
      },
      {
        icon: <Heading3Icon />,
        label: "Heading 3",
        value: HEADING_KEYS.h3,
      },
      {
        icon: <TableIcon />,
        label: "Table",
        value: TablePlugin.key,
      },
      {
        icon: <FileCodeIcon />,
        label: "Code",
        value: CodeBlockPlugin.key,
      },
      {
        icon: <QuoteIcon />,
        label: "Quote",
        value: BlockquotePlugin.key,
      },
      {
        icon: <MinusIcon />,
        label: "Divider",
        value: HorizontalRulePlugin.key,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Lists",
    items: [
      {
        icon: <ListIcon />,
        label: "Bulleted list",
        value: ListStyleType.Disc,
      },
      {
        icon: <ListOrderedIcon />,
        label: "Numbered list",
        value: ListStyleType.Decimal,
      },
      {
        icon: <SquareIcon />,
        label: "To-do list",
        value: INDENT_LIST_KEYS.todo,
      },
      {
        icon: <ChevronRightIcon />,
        label: "Toggle list",
        value: TogglePlugin.key,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Media",
    items: [
      {
        icon: <ImageIcon />,
        label: "Image",
        value: ImagePlugin.key,
      },
      {
        icon: <FilmIcon />,
        label: "Embed",
        value: MediaEmbedPlugin.key,
      },
      {
        icon: <PenToolIcon />,
        label: "Excalidraw",
        value: ExcalidrawPlugin.key,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Advanced blocks",
    items: [
      {
        icon: <TableOfContentsIcon />,
        label: "Table of contents",
        value: TocPlugin.key,
      },
      {
        icon: <Columns3Icon />,
        label: "3 columns",
        value: "action_three_columns",
      },
      {
        focusEditor: false,
        icon: <RadicalIcon />,
        label: "Equation",
        value: EquationPlugin.key,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Inline",
    items: [
      {
        icon: <Link2Icon />,
        label: "Link",
        value: LinkPlugin.key,
      },
      {
        focusEditor: true,
        icon: <CalendarIcon />,
        label: "Date",
        value: DatePlugin.key,
      },
      {
        focusEditor: false,
        icon: <RadicalIcon />,
        label: "Inline Equation",
        value: InlineEquationPlugin.key,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertInlineElement(editor, value);
      },
    })),
  },
];

export function InsertDropdownMenu(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Insert" isDropdown>
          <PlusIcon />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent
        className="flex max-h-[500px] min-w-0 flex-col overflow-y-auto"
        align="start"
      >
        {groups.map(({ group, items: nestedItems }) => (
          <ToolbarMenuGroup key={group} label={group}>
            {nestedItems.map(({ icon, label, value, onSelect }) => (
              <DropdownMenuItem
                key={value}
                className="min-w-[180px]"
                onSelect={() => {
                  onSelect(editor, value);
                  editor.tf.focus();
                }}
              >
                {icon}
                {label}
              </DropdownMenuItem>
            ))}
          </ToolbarMenuGroup>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

// ========== FILE END: ui/menus/insert-dropdown-menu.tsx ==========



// ========== FILE START: ui/menus/line-height-dropdown-menu.tsx ==========
"use client";

import * as React from "react";

import type { DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { DropdownMenuItemIndicator } from "@radix-ui/react-dropdown-menu";
import {
  useLineHeightDropdownMenu,
  useLineHeightDropdownMenuState,
} from "@udecode/plate-line-height/react";
import { CheckIcon, WrapText } from "lucide-react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

import { ToolbarButton } from "../menus/toolbars/toolbar";

export function LineHeightDropdownMenu({ ...props }: DropdownMenuProps) {
  const [open, setOpen] = React.useState(false);
  const state = useLineHeightDropdownMenuState();
  const { radioGroupProps } = useLineHeightDropdownMenu(state);

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Line height" isDropdown>
          <WrapText />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent className="min-w-0" align="start">
        <DropdownMenuRadioGroup {...radioGroupProps}>
          {state.values.map((_value) => (
            <DropdownMenuRadioItem
              key={_value}
              className="min-w-[180px] pl-2 *:first:[span]:hidden"
              value={_value}
            >
              <span className="pointer-events-none absolute right-2 flex size-3.5 items-center justify-center">
                <DropdownMenuItemIndicator>
                  <CheckIcon />
                </DropdownMenuItemIndicator>
              </span>
              {_value}
            </DropdownMenuRadioItem>
          ))}
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

// ========== FILE END: ui/menus/line-height-dropdown-menu.tsx ==========



// ========== FILE START: ui/menus/link-floating-toolbar.tsx ==========
"use client";

import * as React from "react";

import {
  type UseVirtualFloatingOptions,
  flip,
  offset,
} from "@udecode/plate-floating";
import { type TLinkElement, getLinkAttributes } from "@udecode/plate-link";
import {
  type LinkFloatingToolbarState,
  FloatingLinkUrlInput,
  LinkPlugin,
  useFloatingLinkEdit,
  useFloatingLinkEditState,
  useFloatingLinkInsert,
  useFloatingLinkInsertState,
} from "@udecode/plate-link/react";
import {
  useEditorRef,
  useEditorSelection,
  useFormInputProps,
  usePluginOption,
} from "@udecode/plate/react";
import { cva } from "class-variance-authority";
import { ExternalLink, Link, Text, Unlink } from "lucide-react";

import { buttonVariants } from "@/components/ui/button";
import { Separator } from "@/components/ui/separator";

const popoverVariants = cva(
  "z-50 w-auto rounded-md border bg-popover p-1 text-popover-foreground shadow-md outline-hidden",
);

const inputVariants = cva(
  "flex h-[28px] w-full rounded-md border-none bg-transparent px-1.5 py-1 text-base placeholder:text-muted-foreground focus-visible:ring-transparent focus-visible:outline-none md:text-sm",
);

export function LinkFloatingToolbar({
  state,
}: {
  state?: LinkFloatingToolbarState;
}) {
  const activeCommentId = usePluginOption({ key: "comment" }, "activeId");
  const activeSuggestionId = usePluginOption({ key: "suggestion" }, "activeId");

  const floatingOptions: UseVirtualFloatingOptions = React.useMemo(() => {
    return {
      middleware: [
        offset(8),
        flip({
          fallbackPlacements: ["bottom-end", "top-start", "top-end"],
          padding: 12,
        }),
      ],
      placement:
        activeSuggestionId || activeCommentId ? "top-start" : "bottom-start",
    };
  }, [activeCommentId, activeSuggestionId]);

  const insertState = useFloatingLinkInsertState({
    ...state,
    floatingOptions: {
      ...floatingOptions,
      ...state?.floatingOptions,
    },
  });
  const {
    hidden,
    props: insertProps,
    ref: insertRef,
    textInputProps,
  } = useFloatingLinkInsert(insertState);

  const editState = useFloatingLinkEditState({
    ...state,
    floatingOptions: {
      ...floatingOptions,
      ...state?.floatingOptions,
    },
  });
  const {
    editButtonProps,
    props: editProps,
    ref: editRef,
    unlinkButtonProps,
  } = useFloatingLinkEdit(editState);
  const inputProps = useFormInputProps({
    preventDefaultOnEnterKeydown: true,
  });

  if (hidden) return null;

  const input = (
    <div className="flex w-[330px] flex-col" {...inputProps}>
      <div className="flex items-center">
        <div className="flex items-center pr-1 pl-2 text-muted-foreground">
          <Link className="size-4" />
        </div>

        <FloatingLinkUrlInput
          className={inputVariants()}
          placeholder="Paste link"
          data-plate-focus
        />
      </div>
      <Separator className="my-1" />
      <div className="flex items-center">
        <div className="flex items-center pr-1 pl-2 text-muted-foreground">
          <Text className="size-4" />
        </div>
        <input
          className={inputVariants()}
          placeholder="Text to display"
          data-plate-focus
          {...textInputProps}
        />
      </div>
    </div>
  );

  const editContent = editState.isEditing ? (
    input
  ) : (
    <div className="box-content flex items-center">
      <button
        className={buttonVariants({ size: "sm", variant: "ghost" })}
        type="button"
        {...editButtonProps}
      >
        Edit link
      </button>

      <Separator orientation="vertical" />

      <LinkOpenButton />

      <Separator orientation="vertical" />

      <button
        className={buttonVariants({
          size: "icon",
          variant: "ghost",
        })}
        type="button"
        {...unlinkButtonProps}
      >
        <Unlink width={18} />
      </button>
    </div>
  );

  return (
    <>
      <div ref={insertRef} className={popoverVariants()} {...insertProps}>
        {input}
      </div>

      <div ref={editRef} className={popoverVariants()} {...editProps}>
        {editContent}
      </div>
    </>
  );
}

function LinkOpenButton() {
  const editor = useEditorRef();
  const selection = useEditorSelection();

  const attributes = React.useMemo(
    () => {
      const entry = editor.api.node<TLinkElement>({
        match: { type: editor.getType(LinkPlugin) },
      });
      if (!entry) {
        return {};
      }
      const [element] = entry;
      return getLinkAttributes(editor, element);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [editor, selection],
  );

  return (
    <a
      {...attributes}
      className={buttonVariants({
        size: "icon",
        variant: "ghost",
      })}
      onMouseOver={(e) => {
        e.stopPropagation();
      }}
      aria-label="Open link in a new tab"
      target="_blank"
    >
      <ExternalLink width={18} />
    </a>
  );
}

// ========== FILE END: ui/menus/link-floating-toolbar.tsx ==========



// ========== FILE START: ui/menus/media/image-preview.tsx ==========
"use client";

import {
  PreviewImage,
  useImagePreview,
  useImagePreviewValue,
  useScaleInput,
} from "@udecode/plate-media/react";
import { useEditorRef } from "@udecode/plate/react";
import { cva } from "class-variance-authority";
import { ArrowLeft, ArrowRight, Download, Minus, Plus, X } from "lucide-react";

import { cn } from "@/lib/utils";

const toolButtonVariants = cva("rounded bg-[rgba(0,0,0,0.5)] px-1", {
  defaultVariants: {
    variant: "default",
  },
  variants: {
    variant: {
      default: "text-white",
      disabled: "cursor-not-allowed text-gray-400",
    },
  },
});

const SCROLL_SPEED = 4;

export const ImagePreview = () => {
  const editor = useEditorRef();
  const isOpen = useImagePreviewValue("isOpen", editor.id);
  const scale = useImagePreviewValue("scale");
  const isEditingScale = useImagePreviewValue("isEditingScale");
  const {
    closeProps,
    currentUrlIndex,
    maskLayerProps,
    nextDisabled,
    nextProps,
    prevDisabled,
    prevProps,
    scaleTextProps,
    zommOutProps,
    zoomInDisabled,
    zoomInProps,
    zoomOutDisabled,
  } = useImagePreview({ scrollSpeed: SCROLL_SPEED });

  return (
    <div
      className={cn(
        "fixed top-0 left-0 z-50 h-screen w-screen select-none",
        !isOpen && "hidden",
      )}
      onContextMenu={(e) => e.stopPropagation()}
      {...maskLayerProps}
    >
      <div className="absolute inset-0 size-full bg-black opacity-30"></div>
      <div className="absolute inset-0 size-full bg-black opacity-30"></div>
      <div className="absolute inset-0 flex items-center justify-center">
        <div className="relative flex max-h-screen w-full items-center">
          <PreviewImage
            className={cn(
              "mx-auto block max-h-[calc(100vh-4rem)] w-auto object-contain transition-transform",
            )}
          />
          <div
            className="absolute bottom-0 left-1/2 z-40 flex w-fit -translate-x-1/2 justify-center gap-4 p-2 text-center text-white"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="flex gap-1">
              <button
                {...prevProps}
                className={cn(
                  toolButtonVariants({
                    variant: prevDisabled ? "disabled" : "default",
                  }),
                )}
                type="button"
              >
                <ArrowLeft />
              </button>
              {(currentUrlIndex ?? 0) + 1}
              <button
                {...nextProps}
                className={cn(
                  toolButtonVariants({
                    variant: nextDisabled ? "disabled" : "default",
                  }),
                )}
                type="button"
              >
                <ArrowRight />
              </button>
            </div>
            <div className="flex">
              <button
                className={cn(
                  toolButtonVariants({
                    variant: zoomOutDisabled ? "disabled" : "default",
                  }),
                )}
                {...zommOutProps}
                type="button"
              >
                <Minus className="size-4" />
              </button>
              <div className="mx-px">
                {isEditingScale ? (
                  <>
                    <ScaleInput className="w-10 rounded px-1 text-slate-500 outline" />{" "}
                    <span>%</span>
                  </>
                ) : (
                  <span {...scaleTextProps}>{scale * 100 + "%"}</span>
                )}
              </div>
              <button
                className={cn(
                  toolButtonVariants({
                    variant: zoomInDisabled ? "disabled" : "default",
                  }),
                )}
                {...zoomInProps}
                type="button"
              >
                <Plus className="size-4" />
              </button>
            </div>
            {/* TODO: downLoad the image */}
            <button className={cn(toolButtonVariants())} type="button">
              <Download className="size-4" />
            </button>
            <button
              {...closeProps}
              className={cn(toolButtonVariants())}
              type="button"
            >
              <X className="size-4" />
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export function ScaleInput(props: React.ComponentProps<"input">) {
  const { props: scaleInputProps, ref } = useScaleInput();

  return <input {...scaleInputProps} {...props} ref={ref} />;
}

// ========== FILE END: ui/menus/media/image-preview.tsx ==========



// ========== FILE START: ui/menus/media/media-popover.tsx ==========
"use client";

import * as React from "react";

import type { WithRequiredKey } from "@udecode/plate";

import {
  FloatingMedia as FloatingMediaPrimitive,
  FloatingMediaStore,
  useFloatingMediaValue,
  useImagePreviewValue,
} from "@udecode/plate-media/react";
import {
  useEditorRef,
  useEditorSelector,
  useElement,
  useReadOnly,
  useRemoveNodeButton,
  useSelected,
} from "@udecode/plate/react";
import { cva } from "class-variance-authority";
import { Link, Trash2Icon } from "lucide-react";

import { Button, buttonVariants } from "@/components/ui/button";
import {
  Popover,
  PopoverAnchor,
  PopoverContent,
} from "@/components/ui/popover";
import { Separator } from "@/components/ui/separator";

import { CaptionButton } from "../../primitives/caption";

const inputVariants = cva(
  "flex h-[28px] w-full rounded-md border-none bg-transparent px-1.5 py-1 text-base placeholder:text-muted-foreground focus-visible:ring-transparent focus-visible:outline-none md:text-sm",
);

export interface MediaPopoverProps {
  children: React.ReactNode;
  plugin: WithRequiredKey;
}

export function MediaPopover({ children, plugin }: MediaPopoverProps) {
  const editor = useEditorRef();
  const readOnly = useReadOnly();
  const selected = useSelected();

  const selectionCollapsed = useEditorSelector(
    (editor) => !editor.api.isExpanded(),
    [],
  );
  const isImagePreviewOpen = useImagePreviewValue("isOpen", editor.id);
  const isOpen =
    !readOnly && selected && selectionCollapsed && !isImagePreviewOpen;
  const isEditing = useFloatingMediaValue("isEditing");

  React.useEffect(() => {
    if (!isOpen && isEditing) {
      FloatingMediaStore.set("isEditing", false);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isOpen]);

  const element = useElement();
  const { props: buttonProps } = useRemoveNodeButton({ element });

  if (readOnly) return <>{children}</>;

  return (
    <Popover open={isOpen} modal={false}>
      <PopoverAnchor>{children}</PopoverAnchor>

      <PopoverContent
        className="w-auto p-1"
        onOpenAutoFocus={(e) => e.preventDefault()}
      >
        {isEditing ? (
          <div className="flex w-[330px] flex-col">
            <div className="flex items-center">
              <div className="flex items-center pr-1 pl-2 text-muted-foreground">
                <Link className="size-4" />
              </div>

              <FloatingMediaPrimitive.UrlInput
                className={inputVariants()}
                placeholder="Paste the embed link..."
                options={{ plugin }}
              />
            </div>
          </div>
        ) : (
          <div className="box-content flex items-center">
            <FloatingMediaPrimitive.EditButton
              className={buttonVariants({ size: "sm", variant: "ghost" })}
            >
              Edit link
            </FloatingMediaPrimitive.EditButton>

            <CaptionButton variant="ghost">Caption</CaptionButton>

            <Separator orientation="vertical" className="mx-1 h-6" />

            <Button size="icon" variant="ghost" {...buttonProps}>
              <Trash2Icon />
            </Button>
          </div>
        )}
      </PopoverContent>
    </Popover>
  );
}

// ========== FILE END: ui/menus/media/media-popover.tsx ==========



// ========== FILE START: ui/menus/media/media-upload-toast.tsx ==========
"use client";

import * as React from "react";

import { PlaceholderPlugin, UploadErrorCode } from "@udecode/plate-media/react";
import { usePluginOption } from "@udecode/plate/react";
import { toast } from "sonner";

export const useUploadErrorToast = () => {
  const uploadError = usePluginOption(PlaceholderPlugin, "error");

  React.useEffect(() => {
    if (!uploadError) return;

    const { code, data } = uploadError;

    switch (code) {
      case UploadErrorCode.INVALID_FILE_SIZE: {
        toast.error(
          `The size of files ${data.files
            .map((f) => f.name)
            .join(", ")} is invalid`,
        );

        break;
      }
      case UploadErrorCode.INVALID_FILE_TYPE: {
        toast.error(
          `The type of files ${data.files
            .map((f) => f.name)
            .join(", ")} is invalid`,
        );

        break;
      }
      case UploadErrorCode.TOO_LARGE: {
        toast.error(
          `The size of files ${data.files
            .map((f) => f.name)
            .join(", ")} is too large than ${data.maxFileSize}`,
        );

        break;
      }
      case UploadErrorCode.TOO_LESS_FILES: {
        toast.error(
          `The mini um number of files is ${data.minFileCount} for ${data.fileType}`,
        );

        break;
      }
      case UploadErrorCode.TOO_MANY_FILES: {
        toast.error(
          `The maximum number of files is ${data.maxFileCount} ${
            data.fileType ? `for ${data.fileType}` : ""
          }`,
        );

        break;
      }
    }
  }, [uploadError]);
};

export const MediaUploadToast = () => {
  useUploadErrorToast();

  return null;
};

// ========== FILE END: ui/menus/media/media-upload-toast.tsx ==========



// ========== FILE START: ui/menus/mode-dropdown-menu.tsx ==========
"use client";

import * as React from "react";

import {
  type DropdownMenuProps,
  DropdownMenuItemIndicator,
} from "@radix-ui/react-dropdown-menu";
import { SuggestionPlugin } from "@udecode/plate-suggestion/react";
import {
  useEditorRef,
  usePlateState,
  usePluginOption,
} from "@udecode/plate/react";
import { CheckIcon, EyeIcon, PencilLineIcon, PenIcon } from "lucide-react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

import { ToolbarButton } from "../menus/toolbars/toolbar";

export function ModeDropdownMenu(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [readOnly, setReadOnly] = usePlateState("readOnly");
  const [open, setOpen] = React.useState(false);

  const isSuggestingFromPlugin = usePluginOption(
    SuggestionPlugin,
    "isSuggesting",
  );
  const [isSuggesting, setIsSuggesting] = React.useState(
    isSuggestingFromPlugin,
  );

  React.useEffect(() => {
    setIsSuggesting(isSuggestingFromPlugin);
  }, [isSuggestingFromPlugin]);

  let value = "editing";

  if (readOnly) value = "viewing";

  if (isSuggesting) value = "suggestion";

  const item: Record<string, { icon: React.ReactNode; label: string }> = {
    editing: {
      icon: <PenIcon />,
      label: "Editing",
    },
    suggestion: {
      icon: <PencilLineIcon />,
      label: "Suggestion",
    },
    viewing: {
      icon: <EyeIcon />,
      label: "Viewing",
    },
  };

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Editing mode" isDropdown>
          {item[value].icon}
          <span className="hidden lg:inline">{item[value].label}</span>
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent className="min-w-[180px]" align="start">
        <DropdownMenuRadioGroup
          value={value}
          onValueChange={(newValue) => {
            if (newValue === "viewing") {
              setReadOnly(true);

              return;
            } else {
              setReadOnly(false);
            }

            if (newValue === "suggestion") {
              editor.setOption(SuggestionPlugin, "isSuggesting", true);

              return;
            } else {
              editor.setOption(SuggestionPlugin, "isSuggesting", false);
            }

            if (newValue === "editing") {
              editor.tf.focus();

              return;
            }
          }}
        >
          <DropdownMenuRadioItem
            className="pl-2 *:first:[span]:hidden *:[svg]:text-muted-foreground"
            value="editing"
          >
            <Indicator />
            {item.editing.icon}
            {item.editing.label}
          </DropdownMenuRadioItem>

          <DropdownMenuRadioItem
            className="pl-2 *:first:[span]:hidden *:[svg]:text-muted-foreground"
            value="viewing"
          >
            <Indicator />
            {item.viewing.icon}
            {item.viewing.label}
          </DropdownMenuRadioItem>

          <DropdownMenuRadioItem
            className="pl-2 *:first:[span]:hidden *:[svg]:text-muted-foreground"
            value="suggestion"
          >
            <Indicator />
            {item.suggestion.icon}
            {item.suggestion.label}
          </DropdownMenuRadioItem>
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

function Indicator() {
  return (
    <span className="pointer-events-none absolute right-2 flex size-3.5 items-center justify-center">
      <DropdownMenuItemIndicator>
        <CheckIcon />
      </DropdownMenuItemIndicator>
    </span>
  );
}

// ========== FILE END: ui/menus/mode-dropdown-menu.tsx ==========



// ========== FILE START: ui/menus/more-dropdown-menu.tsx ==========
"use client";

import * as React from "react";

import type { DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import {
  SubscriptPlugin,
  SuperscriptPlugin,
} from "@udecode/plate-basic-marks/react";
import { KbdPlugin } from "@udecode/plate-kbd/react";
import { useEditorRef } from "@udecode/plate/react";
import {
  KeyboardIcon,
  MoreHorizontalIcon,
  SubscriptIcon,
  SuperscriptIcon,
} from "lucide-react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

import { ToolbarButton } from "../menus/toolbars/toolbar";

export function MoreDropdownMenu(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Insert">
          <MoreHorizontalIcon />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent
        className="ignore-click-outside/toolbar flex max-h-[500px] min-w-[180px] flex-col overflow-y-auto"
        align="start"
      >
        <DropdownMenuGroup>
          <DropdownMenuItem
            onSelect={() => {
              editor.tf.toggleMark(KbdPlugin.key);
              editor.tf.collapse({ edge: "end" });
              editor.tf.focus();
            }}
          >
            <KeyboardIcon />
            Keyboard input
          </DropdownMenuItem>

          <DropdownMenuItem
            onSelect={() => {
              editor.tf.toggleMark(SuperscriptPlugin.key, {
                remove: SubscriptPlugin.key,
              });
              editor.tf.focus();
            }}
          >
            <SuperscriptIcon />
            Superscript
            {/* (+,) */}
          </DropdownMenuItem>
          <DropdownMenuItem
            onSelect={() => {
              editor.tf.toggleMark(SubscriptPlugin.key, {
                remove: SuperscriptPlugin.key,
              });
              editor.tf.focus();
            }}
          >
            <SubscriptIcon />
            Subscript
            {/* (+.) */}
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

// ========== FILE END: ui/menus/more-dropdown-menu.tsx ==========



// ========== FILE START: ui/menus/table-dropdown-menu.tsx ==========
"use client";

import * as React from "react";

import type { DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { TablePlugin, useTableMergeState } from "@udecode/plate-table/react";
import { useEditorPlugin, useEditorSelector } from "@udecode/plate/react";
import {
  ArrowDown,
  ArrowLeft,
  ArrowRight,
  ArrowUp,
  Combine,
  Grid3x3Icon,
  Table,
  Trash2Icon,
  Ungroup,
  XIcon,
} from "lucide-react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { cn } from "@/lib/utils";

import { ToolbarButton } from "../menus/toolbars/toolbar";

export function TableDropdownMenu(props: DropdownMenuProps) {
  const tableSelected = useEditorSelector(
    (editor) => editor.api.some({ match: { type: TablePlugin.key } }),
    [],
  );

  const { editor, tf } = useEditorPlugin(TablePlugin);
  const [open, setOpen] = React.useState(false);
  const mergeState = useTableMergeState();

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Table" isDropdown>
          <Table />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent
        className="flex w-[180px] min-w-0 flex-col"
        align="start"
      >
        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger className="gap-2 data-[disabled]:pointer-events-none data-[disabled]:opacity-50">
              <Grid3x3Icon className="size-4" />
              <span>Table</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuSubContent className="m-0 p-0">
              <TablePicker />
            </DropdownMenuSubContent>
          </DropdownMenuSub>

          <DropdownMenuSub>
            <DropdownMenuSubTrigger
              className="gap-2 data-[disabled]:pointer-events-none data-[disabled]:opacity-50"
              disabled={!tableSelected}
            >
              <div className="size-4" />
              <span>Cell</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuSubContent>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!mergeState.canMerge}
                onSelect={() => {
                  tf.table.merge();
                  editor.tf.focus();
                }}
              >
                <Combine />
                Merge cells
              </DropdownMenuItem>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!mergeState.canSplit}
                onSelect={() => {
                  tf.table.split();
                  editor.tf.focus();
                }}
              >
                <Ungroup />
                Split cell
              </DropdownMenuItem>
            </DropdownMenuSubContent>
          </DropdownMenuSub>

          <DropdownMenuSub>
            <DropdownMenuSubTrigger
              className="gap-2 data-[disabled]:pointer-events-none data-[disabled]:opacity-50"
              disabled={!tableSelected}
            >
              <div className="size-4" />
              <span>Row</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuSubContent>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.insert.tableRow({ before: true });
                  editor.tf.focus();
                }}
              >
                <ArrowUp />
                Insert row before
              </DropdownMenuItem>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.insert.tableRow();
                  editor.tf.focus();
                }}
              >
                <ArrowDown />
                Insert row after
              </DropdownMenuItem>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.remove.tableRow();
                  editor.tf.focus();
                }}
              >
                <XIcon />
                Delete row
              </DropdownMenuItem>
            </DropdownMenuSubContent>
          </DropdownMenuSub>

          <DropdownMenuSub>
            <DropdownMenuSubTrigger
              className="gap-2 data-[disabled]:pointer-events-none data-[disabled]:opacity-50"
              disabled={!tableSelected}
            >
              <div className="size-4" />
              <span>Column</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuSubContent>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.insert.tableColumn({ before: true });
                  editor.tf.focus();
                }}
              >
                <ArrowLeft />
                Insert column before
              </DropdownMenuItem>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.insert.tableColumn();
                  editor.tf.focus();
                }}
              >
                <ArrowRight />
                Insert column after
              </DropdownMenuItem>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.remove.tableColumn();
                  editor.tf.focus();
                }}
              >
                <XIcon />
                Delete column
              </DropdownMenuItem>
            </DropdownMenuSubContent>
          </DropdownMenuSub>

          <DropdownMenuItem
            className="min-w-[180px]"
            disabled={!tableSelected}
            onSelect={() => {
              tf.remove.table();
              editor.tf.focus();
            }}
          >
            <Trash2Icon />
            Delete table
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

export function TablePicker() {
  const { editor, tf } = useEditorPlugin(TablePlugin);

  const [tablePicker, setTablePicker] = React.useState({
    grid: Array.from({ length: 8 }, () => Array.from({ length: 8 }).fill(0)),
    size: { colCount: 0, rowCount: 0 },
  });

  const onCellMove = (rowIndex: number, colIndex: number) => {
    const newGrid = [...tablePicker.grid];

    for (let i = 0; i < newGrid.length; i++) {
      for (let j = 0; j < newGrid[i].length; j++) {
        newGrid[i][j] =
          i >= 0 && i <= rowIndex && j >= 0 && j <= colIndex ? 1 : 0;
      }
    }

    setTablePicker({
      grid: newGrid,
      size: { colCount: colIndex + 1, rowCount: rowIndex + 1 },
    });
  };

  return (
    <div
      className="m-0 flex! flex-col p-0"
      onClick={() => {
        tf.insert.table(tablePicker.size, { select: true });
        editor.tf.focus();
      }}
    >
      <div className="grid size-[130px] grid-cols-8 gap-0.5 p-1">
        {tablePicker.grid.map((rows, rowIndex) =>
          rows.map((value, columIndex) => {
            return (
              <div
                key={`(${rowIndex},${columIndex})`}
                className={cn(
                  "col-span-1 size-3 border border-solid bg-secondary",
                  !!value && "border-current",
                )}
                onMouseMove={() => {
                  onCellMove(rowIndex, columIndex);
                }}
              />
            );
          }),
        )}
      </div>

      <div className="text-center text-xs text-current">
        {tablePicker.size.rowCount} x {tablePicker.size.colCount}
      </div>
    </div>
  );
}

// ========== FILE END: ui/menus/table-dropdown-menu.tsx ==========



// ========== FILE START: ui/menus/toolbars/fixed/fixed-toolbar.tsx ==========
"use client";

import { cn } from "@/lib/utils";

import { Toolbar } from "../toolbar";

export function FixedToolbar(props: React.ComponentProps<typeof Toolbar>) {
  return (
    <Toolbar
      {...props}
      className={cn(
        "sticky top-0 left-0 z-50 scrollbar-hide w-full justify-between overflow-x-auto rounded-t-lg border-b border-b-border bg-background/95 p-1 backdrop-blur-sm supports-backdrop-blur:bg-background/60",
        props.className,
      )}
    />
  );
}

// ========== FILE END: ui/menus/toolbars/fixed/fixed-toolbar.tsx ==========



// ========== FILE START: ui/menus/toolbars/floating/floating-toolbar.tsx ==========
"use client";

import * as React from "react";

import { useComposedRef } from "@udecode/cn";
import {
  type FloatingToolbarState,
  flip,
  offset,
  useFloatingToolbar,
  useFloatingToolbarState,
} from "@udecode/plate-floating";
import {
  useEditorId,
  useEventEditorValue,
  usePluginOption,
} from "@udecode/plate/react";

import { cn } from "@/lib/utils";

import { Toolbar } from "../toolbar";

type FloatingToolbarProps = React.ComponentProps<typeof Toolbar> & {
  state?: FloatingToolbarState;
};

export function FloatingToolbar({
  children,
  className,
  state,
  ...props
}: FloatingToolbarProps) {
  const editorId = useEditorId();
  const focusedEditorId = useEventEditorValue("focus");
  const isFloatingLinkOpen = !!usePluginOption({ key: "a" }, "mode");
  const isAIChatOpen = usePluginOption({ key: "aiChat" }, "open");

  const floatingToolbarState = useFloatingToolbarState({
    editorId,
    focusedEditorId,
    hideToolbar: isFloatingLinkOpen || isAIChatOpen,
    ...state,
    floatingOptions: {
      middleware: [
        offset(12),
        flip({
          fallbackPlacements: [
            "top-start",
            "top-end",
            "bottom-start",
            "bottom-end",
          ],
          padding: 12,
        }),
      ],
      placement: "top",
      ...state?.floatingOptions,
    },
  });

  const {
    clickOutsideRef,
    hidden,
    props: rootProps,
    ref: floatingRef,
  } = useFloatingToolbar(floatingToolbarState);

  const ref = useComposedRef<HTMLDivElement>(props.ref, floatingRef);

  if (hidden) return null;

  return (
    <div ref={clickOutsideRef}>
      <Toolbar
        {...props}
        {...rootProps}
        ref={ref}
        className={cn(
          "absolute z-50 scrollbar-hide overflow-x-auto rounded-md border bg-popover p-1 whitespace-nowrap opacity-100 shadow-md print:hidden",
          "max-w-[80vw]",
          className,
        )}
      >
        {children}
      </Toolbar>
    </div>
  );
}

// ========== FILE END: ui/menus/toolbars/floating/floating-toolbar.tsx ==========



// ========== FILE START: ui/menus/toolbars/toolbar.tsx ==========
"use client";

import * as React from "react";

import * as ToolbarPrimitive from "@radix-ui/react-toolbar";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import { type VariantProps, cva } from "class-variance-authority";
import { ChevronDown } from "lucide-react";

import {
  DropdownMenuLabel,
  DropdownMenuRadioGroup,
  DropdownMenuSeparator,
} from "@/components/ui/dropdown-menu";
import { Separator } from "@/components/ui/separator";
import { Tooltip, TooltipTrigger } from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";

export function Toolbar({
  className,
  ...props
}: React.ComponentProps<typeof ToolbarPrimitive.Root>) {
  return (
    <ToolbarPrimitive.Root
      className={cn("relative flex items-center select-none", className)}
      {...props}
    />
  );
}

export function ToolbarToggleGroup({
  className,
  ...props
}: React.ComponentProps<typeof ToolbarPrimitive.ToolbarToggleGroup>) {
  return (
    <ToolbarPrimitive.ToolbarToggleGroup
      className={cn("flex items-center", className)}
      {...props}
    />
  );
}

export function ToolbarLink({
  className,
  ...props
}: React.ComponentProps<typeof ToolbarPrimitive.Link>) {
  return (
    <ToolbarPrimitive.Link
      className={cn("font-medium underline underline-offset-4", className)}
      {...props}
    />
  );
}

export function ToolbarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ToolbarPrimitive.Separator>) {
  return (
    <ToolbarPrimitive.Separator
      className={cn("mx-2 my-1 w-px shrink-0 bg-border", className)}
      {...props}
    />
  );
}

// From toggleVariants
const toolbarButtonVariants = cva(
  "inline-flex cursor-pointer items-center justify-center gap-2 rounded-md text-sm font-medium whitespace-nowrap transition-[color,box-shadow] outline-none hover:bg-muted hover:text-muted-foreground focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 disabled:pointer-events-none disabled:opacity-50 aria-checked:bg-accent aria-checked:text-accent-foreground aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
  {
    defaultVariants: {
      size: "default",
      variant: "default",
    },
    variants: {
      size: {
        default: "h-9 min-w-9 px-2",
        lg: "h-10 min-w-10 px-2.5",
        sm: "h-8 min-w-8 px-1.5",
      },
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent shadow-xs hover:bg-accent hover:text-accent-foreground",
      },
    },
  },
);

const dropdownArrowVariants = cva(
  cn(
    "inline-flex items-center justify-center rounded-r-md text-sm font-medium text-foreground transition-colors disabled:pointer-events-none disabled:opacity-50",
  ),
  {
    defaultVariants: {
      size: "sm",
      variant: "default",
    },
    variants: {
      size: {
        default: "h-9 w-6",
        lg: "h-10 w-8",
        sm: "h-8 w-4",
      },
      variant: {
        default:
          "bg-transparent hover:bg-muted hover:text-muted-foreground aria-checked:bg-accent aria-checked:text-accent-foreground",
        outline:
          "border border-l-0 border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
    },
  },
);

type ToolbarButtonProps = {
  isDropdown?: boolean;
  pressed?: boolean;
} & Omit<
  React.ComponentPropsWithoutRef<typeof ToolbarToggleItem>,
  "asChild" | "value"
> &
  VariantProps<typeof toolbarButtonVariants>;

export const ToolbarButton = withTooltip(function ToolbarButton({
  children,
  className,
  isDropdown,
  pressed,
  size = "sm",
  variant,
  ...props
}: ToolbarButtonProps) {
  return typeof pressed === "boolean" ? (
    <ToolbarToggleGroup disabled={props.disabled} value="single" type="single">
      <ToolbarToggleItem
        className={cn(
          toolbarButtonVariants({
            size,
            variant,
          }),
          isDropdown && "justify-between gap-1 pr-1",
          className,
        )}
        value={pressed ? "single" : ""}
        {...props}
      >
        {isDropdown ? (
          <>
            <div className="flex flex-1 items-center gap-2 whitespace-nowrap">
              {children}
            </div>
            <div>
              <ChevronDown
                className="size-3.5 text-muted-foreground"
                data-icon
              />
            </div>
          </>
        ) : (
          children
        )}
      </ToolbarToggleItem>
    </ToolbarToggleGroup>
  ) : (
    <ToolbarPrimitive.Button
      className={cn(
        toolbarButtonVariants({
          size,
          variant,
        }),
        isDropdown && "pr-1",
        className,
      )}
      {...props}
    >
      {children}
    </ToolbarPrimitive.Button>
  );
});

export function ToolbarSplitButton({
  className,
  ...props
}: React.ComponentPropsWithoutRef<typeof ToolbarButton>) {
  return (
    <ToolbarButton
      className={cn("group flex gap-0 px-0 hover:bg-transparent", className)}
      {...props}
    />
  );
}

type ToolbarSplitButtonPrimaryProps = Omit<
  React.ComponentPropsWithoutRef<typeof ToolbarToggleItem>,
  "value"
> &
  VariantProps<typeof toolbarButtonVariants>;

export function ToolbarSplitButtonPrimary({
  children,
  className,
  size = "sm",
  variant,
  ...props
}: ToolbarSplitButtonPrimaryProps) {
  return (
    <span
      className={cn(
        toolbarButtonVariants({
          size,
          variant,
        }),
        "rounded-r-none",
        "group-data-[pressed=true]:bg-accent group-data-[pressed=true]:text-accent-foreground",
        className,
      )}
      {...props}
    >
      {children}
    </span>
  );
}

export function ToolbarSplitButtonSecondary({
  className,
  size,
  variant,
  ...props
}: React.ComponentPropsWithoutRef<"span"> &
  VariantProps<typeof dropdownArrowVariants>) {
  return (
    <span
      className={cn(
        dropdownArrowVariants({
          size,
          variant,
        }),
        "group-data-[pressed=true]:bg-accent group-data-[pressed=true]:text-accent-foreground",
        className,
      )}
      onClick={(e) => e.stopPropagation()}
      role="button"
      {...props}
    >
      <ChevronDown className="size-3.5 text-muted-foreground" data-icon />
    </span>
  );
}

export function ToolbarToggleItem({
  className,
  size = "sm",
  variant,
  ...props
}: React.ComponentProps<typeof ToolbarPrimitive.ToggleItem> &
  VariantProps<typeof toolbarButtonVariants>) {
  return (
    <ToolbarPrimitive.ToggleItem
      className={cn(toolbarButtonVariants({ size, variant }), className)}
      {...props}
    />
  );
}

export function ToolbarGroup({
  children,
  className,
}: React.ComponentProps<"div">) {
  return (
    <div
      className={cn(
        "group/toolbar-group",
        "relative hidden has-[button]:flex",
        className,
      )}
    >
      <div className="flex items-center">{children}</div>

      <div className="mx-1.5 py-0.5 group-last/toolbar-group:hidden!">
        <Separator orientation="vertical" />
      </div>
    </div>
  );
}

type TooltipProps<T extends React.ElementType> = {
  tooltip?: React.ReactNode;
  tooltipContentProps?: Omit<
    React.ComponentPropsWithoutRef<typeof TooltipContent>,
    "children"
  >;
  tooltipProps?: Omit<
    React.ComponentPropsWithoutRef<typeof Tooltip>,
    "children"
  >;
  tooltipTriggerProps?: React.ComponentPropsWithoutRef<typeof TooltipTrigger>;
} & React.ComponentProps<T>;

function withTooltip<T extends React.ElementType>(Component: T) {
  return function ExtendComponent({
    tooltip,
    tooltipContentProps,
    tooltipProps,
    tooltipTriggerProps,
    ...props
  }: TooltipProps<T>) {
    const [mounted, setMounted] = React.useState(false);

    React.useEffect(() => {
      setMounted(true);
    }, []);

    const component = <Component {...(props as React.ComponentProps<T>)} />;

    if (tooltip && mounted) {
      return (
        <Tooltip {...tooltipProps}>
          <TooltipTrigger asChild {...tooltipTriggerProps}>
            {component}
          </TooltipTrigger>

          <TooltipContent {...tooltipContentProps}>{tooltip}</TooltipContent>
        </Tooltip>
      );
    }

    return component;
  };
}

function TooltipContent({
  children,
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        className={cn(
          "z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md bg-primary px-3 py-1.5 text-xs text-balance text-primary-foreground",
          className,
        )}
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        {...props}
      >
        {children}
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  );
}

export function ToolbarMenuGroup({
  children,
  className,
  label,
  ...props
}: React.ComponentProps<typeof DropdownMenuRadioGroup> & { label?: string }) {
  return (
    <>
      <DropdownMenuSeparator
        className={cn(
          "hidden",
          "mb-0 shrink-0 peer-has-[[role=menuitem]]/menu-group:block peer-has-[[role=menuitemradio]]/menu-group:block peer-has-[[role=option]]/menu-group:block",
        )}
      />

      <DropdownMenuRadioGroup
        {...props}
        className={cn(
          "hidden",
          "peer/menu-group group/menu-group my-1.5 has-[[role=menuitem]]:block has-[[role=menuitemradio]]:block has-[[role=option]]:block",
          className,
        )}
      >
        {label && (
          <DropdownMenuLabel className="text-xs font-semibold text-muted-foreground select-none">
            {label}
          </DropdownMenuLabel>
        )}
        {children}
      </DropdownMenuRadioGroup>
    </>
  );
}

// ========== FILE END: ui/menus/toolbars/toolbar.tsx ==========



// ========== FILE START: ui/menus/turn-into-dropdown-menu.tsx ==========
"use client";

import * as React from "react";

import type { DropdownMenuProps } from "@radix-ui/react-dropdown-menu";
import type { TElement } from "@udecode/plate";

import { DropdownMenuItemIndicator } from "@radix-ui/react-dropdown-menu";
import { BlockquotePlugin } from "@udecode/plate-block-quote/react";
import { CodeBlockPlugin } from "@udecode/plate-code-block/react";
import { HEADING_KEYS } from "@udecode/plate-heading";
import { INDENT_LIST_KEYS, ListStyleType } from "@udecode/plate-indent-list";
import { TogglePlugin } from "@udecode/plate-toggle/react";
import {
  ParagraphPlugin,
  useEditorRef,
  useSelectionFragmentProp,
} from "@udecode/plate/react";
import {
  CheckIcon,
  ChevronRightIcon,
  Columns3Icon,
  FileCodeIcon,
  Heading1Icon,
  Heading2Icon,
  Heading3Icon,
  ListIcon,
  ListOrderedIcon,
  PilcrowIcon,
  QuoteIcon,
  SquareIcon,
} from "lucide-react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  getBlockType,
  setBlockType,
  STRUCTURAL_TYPES,
} from "../../core/transforms";

import { ToolbarButton, ToolbarMenuGroup } from "./toolbars/toolbar";

const turnIntoItems = [
  {
    icon: <PilcrowIcon />,
    keywords: ["paragraph"],
    label: "Text",
    value: ParagraphPlugin.key,
  },
  {
    icon: <Heading1Icon />,
    keywords: ["title", "h1"],
    label: "Heading 1",
    value: HEADING_KEYS.h1,
  },
  {
    icon: <Heading2Icon />,
    keywords: ["subtitle", "h2"],
    label: "Heading 2",
    value: HEADING_KEYS.h2,
  },
  {
    icon: <Heading3Icon />,
    keywords: ["subtitle", "h3"],
    label: "Heading 3",
    value: HEADING_KEYS.h3,
  },
  {
    icon: <ListIcon />,
    keywords: ["unordered", "ul", "-"],
    label: "Bulleted list",
    value: ListStyleType.Disc,
  },
  {
    icon: <ListOrderedIcon />,
    keywords: ["ordered", "ol", "1"],
    label: "Numbered list",
    value: ListStyleType.Decimal,
  },
  {
    icon: <SquareIcon />,
    keywords: ["checklist", "task", "checkbox", "[]"],
    label: "To-do list",
    value: INDENT_LIST_KEYS.todo,
  },
  {
    icon: <ChevronRightIcon />,
    keywords: ["collapsible", "expandable"],
    label: "Toggle list",
    value: TogglePlugin.key,
  },
  {
    icon: <FileCodeIcon />,
    keywords: ["```"],
    label: "Code",
    value: CodeBlockPlugin.key,
  },
  {
    icon: <QuoteIcon />,
    keywords: ["citation", "blockquote", ">"],
    label: "Quote",
    value: BlockquotePlugin.key,
  },
  {
    icon: <Columns3Icon />,
    label: "3 columns",
    value: "action_three_columns",
  },
];

export function TurnIntoDropdownMenu(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  const value = useSelectionFragmentProp({
    defaultValue: ParagraphPlugin.key,
    structuralTypes: STRUCTURAL_TYPES,
    getProp: (node) => getBlockType(node as TElement),
  });
  const selectedItem = React.useMemo(
    () =>
      turnIntoItems.find(
        (item) => item.value === (value ?? ParagraphPlugin.key),
      ) ?? turnIntoItems[0],
    [value],
  );

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton
          className="min-w-[125px]"
          pressed={open}
          tooltip="Turn into"
          isDropdown
        >
          {selectedItem.label}
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent
        className="ignore-click-outside/toolbar min-w-0"
        onCloseAutoFocus={(e) => {
          e.preventDefault();
          editor.tf.focus();
        }}
        align="start"
      >
        <ToolbarMenuGroup
          value={value}
          onValueChange={(type) => {
            setBlockType(editor, type);
          }}
          label="Turn into"
        >
          {turnIntoItems.map(({ icon, label, value: itemValue }) => (
            <DropdownMenuRadioItem
              key={itemValue}
              className="min-w-[180px] pl-2 *:first:[span]:hidden"
              value={itemValue}
            >
              <span className="pointer-events-none absolute right-2 flex size-3.5 items-center justify-center">
                <DropdownMenuItemIndicator>
                  <CheckIcon />
                </DropdownMenuItemIndicator>
              </span>
              {icon}
              {label}
            </DropdownMenuRadioItem>
          ))}
        </ToolbarMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

// ========== FILE END: ui/menus/turn-into-dropdown-menu.tsx ==========



// ========== FILE START: ui/primitives/block-selection.tsx ==========
"use client";

import * as React from "react";

import { DndPlugin } from "@udecode/plate-dnd";
import { useBlockSelected } from "@udecode/plate-selection/react";
import { usePluginOption } from "@udecode/plate/react";
import { type VariantProps, cva } from "class-variance-authority";

import { cn } from "@/lib/utils";

export const blockSelectionVariants = cva(
  "pointer-events-none absolute inset-0 z-1 bg-brand/[.13] transition-opacity",
  {
    defaultVariants: {
      active: true,
    },
    variants: {
      active: {
        false: "opacity-0",
        true: "opacity-100",
      },
    },
  },
);

export function BlockSelection({
  className,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof blockSelectionVariants>) {
  const isBlockSelected = useBlockSelected();
  const isDragging = usePluginOption(DndPlugin, "isDragging");

  if (!isBlockSelected) return null;

  return (
    <div
      className={cn(
        blockSelectionVariants({
          active: isBlockSelected && !isDragging,
        }),
        className,
      )}
      data-slot="block-selection"
      {...props}
    />
  );
}

// ========== FILE END: ui/primitives/block-selection.tsx ==========



// ========== FILE START: ui/primitives/caption.tsx ==========
"use client";

import * as React from "react";

import type { VariantProps } from "class-variance-authority";

import { createPrimitiveComponent } from "@udecode/cn";
import {
  Caption as CaptionPrimitive,
  CaptionTextarea as CaptionTextareaPrimitive,
  useCaptionButton,
  useCaptionButtonState,
} from "@udecode/plate-caption/react";
import { cva } from "class-variance-authority";

import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

const captionVariants = cva("max-w-full", {
  defaultVariants: {
    align: "center",
  },
  variants: {
    align: {
      center: "mx-auto",
      left: "mr-auto",
      right: "ml-auto",
    },
  },
});

export function Caption({
  align,
  className,
  ...props
}: React.ComponentProps<typeof CaptionPrimitive> &
  VariantProps<typeof captionVariants>) {
  return (
    <CaptionPrimitive
      {...props}
      className={cn(captionVariants({ align }), className)}
    />
  );
}

export function CaptionTextarea(
  props: React.ComponentProps<typeof CaptionTextareaPrimitive>,
) {
  return (
    <CaptionTextareaPrimitive
      {...props}
      className={cn(
        "mt-2 w-full resize-none border-none bg-inherit p-0 font-[inherit] text-inherit",
        "focus:outline-none focus:[&::placeholder]:opacity-0",
        "text-center print:placeholder:text-transparent",
        props.className,
      )}
    />
  );
}

export const CaptionButton = createPrimitiveComponent(Button)({
  propsHook: useCaptionButton,
  stateHook: useCaptionButtonState,
});

// ========== FILE END: ui/primitives/caption.tsx ==========



// ========== FILE START: ui/primitives/color-picker/color-constants.ts ==========
export const DEFAULT_COLORS = [
  {
    isBrightColor: false,
    name: "black",
    value: "#000000",
  },
  {
    isBrightColor: false,
    name: "dark grey 4",
    value: "#434343",
  },
  {
    isBrightColor: false,
    name: "dark grey 3",
    value: "#666666",
  },
  {
    isBrightColor: false,
    name: "dark grey 2",
    value: "#999999",
  },
  {
    isBrightColor: false,
    name: "dark grey 1",
    value: "#B7B7B7",
  },
  {
    isBrightColor: false,
    name: "grey",
    value: "#CCCCCC",
  },
  {
    isBrightColor: false,
    name: "light grey 1",
    value: "#D9D9D9",
  },
  {
    isBrightColor: true,
    name: "light grey 2",
    value: "#EFEFEF",
  },
  {
    isBrightColor: true,
    name: "light grey 3",
    value: "#F3F3F3",
  },
  {
    isBrightColor: true,
    name: "white",
    value: "#FFFFFF",
  },
  {
    isBrightColor: false,
    name: "red berry",
    value: "#980100",
  },
  {
    isBrightColor: false,
    name: "red",
    value: "#FE0000",
  },
  {
    isBrightColor: false,
    name: "orange",
    value: "#FE9900",
  },
  {
    isBrightColor: true,
    name: "yellow",
    value: "#FEFF00",
  },
  {
    isBrightColor: false,
    name: "green",
    value: "#00FF00",
  },
  {
    isBrightColor: false,
    name: "cyan",
    value: "#00FFFF",
  },
  {
    isBrightColor: false,
    name: "cornflower blue",
    value: "#4B85E8",
  },
  {
    isBrightColor: false,
    name: "blue",
    value: "#1300FF",
  },
  {
    isBrightColor: false,
    name: "purple",
    value: "#9900FF",
  },
  {
    isBrightColor: false,
    name: "magenta",
    value: "#FF00FF",
  },

  {
    isBrightColor: false,
    name: "light red berry 3",
    value: "#E6B8AF",
  },
  {
    isBrightColor: false,
    name: "light red 3",
    value: "#F4CCCC",
  },
  {
    isBrightColor: true,
    name: "light orange 3",
    value: "#FCE4CD",
  },
  {
    isBrightColor: true,
    name: "light yellow 3",
    value: "#FFF2CC",
  },
  {
    isBrightColor: true,
    name: "light green 3",
    value: "#D9EAD3",
  },
  {
    isBrightColor: false,
    name: "light cyan 3",
    value: "#D0DFE3",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 3",
    value: "#C9DAF8",
  },
  {
    isBrightColor: true,
    name: "light blue 3",
    value: "#CFE1F3",
  },
  {
    isBrightColor: true,
    name: "light purple 3",
    value: "#D9D2E9",
  },
  {
    isBrightColor: true,
    name: "light magenta 3",
    value: "#EAD1DB",
  },

  {
    isBrightColor: false,
    name: "light red berry 2",
    value: "#DC7E6B",
  },
  {
    isBrightColor: false,
    name: "light red 2",
    value: "#EA9999",
  },
  {
    isBrightColor: false,
    name: "light orange 2",
    value: "#F9CB9C",
  },
  {
    isBrightColor: true,
    name: "light yellow 2",
    value: "#FFE598",
  },
  {
    isBrightColor: false,
    name: "light green 2",
    value: "#B7D6A8",
  },
  {
    isBrightColor: false,
    name: "light cyan 2",
    value: "#A1C4C9",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 2",
    value: "#A4C2F4",
  },
  {
    isBrightColor: false,
    name: "light blue 2",
    value: "#9FC5E8",
  },
  {
    isBrightColor: false,
    name: "light purple 2",
    value: "#B5A7D5",
  },
  {
    isBrightColor: false,
    name: "light magenta 2",
    value: "#D5A6BD",
  },

  {
    isBrightColor: false,
    name: "light red berry 1",
    value: "#CC4125",
  },
  {
    isBrightColor: false,
    name: "light red 1",
    value: "#E06666",
  },
  {
    isBrightColor: false,
    name: "light orange 1",
    value: "#F6B26B",
  },
  {
    isBrightColor: false,
    name: "light yellow 1",
    value: "#FFD966",
  },
  {
    isBrightColor: false,
    name: "light green 1",
    value: "#93C47D",
  },
  {
    isBrightColor: false,
    name: "light cyan 1",
    value: "#76A5AE",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 1",
    value: "#6C9EEB",
  },
  {
    isBrightColor: false,
    name: "light blue 1",
    value: "#6FA8DC",
  },
  {
    isBrightColor: false,
    name: "light purple 1",
    value: "#8D7CC3",
  },
  {
    isBrightColor: false,
    name: "light magenta 1",
    value: "#C27BA0",
  },

  {
    isBrightColor: false,
    name: "dark red berry 1",
    value: "#A61B00",
  },
  {
    isBrightColor: false,
    name: "dark red 1",
    value: "#CC0000",
  },
  {
    isBrightColor: false,
    name: "dark orange 1",
    value: "#E59138",
  },
  {
    isBrightColor: false,
    name: "dark yellow 1",
    value: "#F1C231",
  },
  {
    isBrightColor: false,
    name: "dark green 1",
    value: "#6AA74F",
  },
  {
    isBrightColor: false,
    name: "dark cyan 1",
    value: "#45818E",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 1",
    value: "#3B78D8",
  },
  {
    isBrightColor: false,
    name: "dark blue 1",
    value: "#3E84C6",
  },
  {
    isBrightColor: false,
    name: "dark purple 1",
    value: "#664EA6",
  },
  {
    isBrightColor: false,
    name: "dark magenta 1",
    value: "#A64D78",
  },

  {
    isBrightColor: false,
    name: "dark red berry 2",
    value: "#84200D",
  },
  {
    isBrightColor: false,
    name: "dark red 2",
    value: "#990001",
  },
  {
    isBrightColor: false,
    name: "dark orange 2",
    value: "#B45F05",
  },
  {
    isBrightColor: false,
    name: "dark yellow 2",
    value: "#BF9002",
  },
  {
    isBrightColor: false,
    name: "dark green 2",
    value: "#38761D",
  },
  {
    isBrightColor: false,
    name: "dark cyan 2",
    value: "#124F5C",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 2",
    value: "#1155CB",
  },
  {
    isBrightColor: false,
    name: "dark blue 2",
    value: "#0C5394",
  },
  {
    isBrightColor: false,
    name: "dark purple 2",
    value: "#351C75",
  },
  {
    isBrightColor: false,
    name: "dark magenta 2",
    value: "#741B47",
  },

  {
    isBrightColor: false,
    name: "dark red berry 3",
    value: "#5B0F00",
  },
  {
    isBrightColor: false,
    name: "dark red 3",
    value: "#660000",
  },
  {
    isBrightColor: false,
    name: "dark orange 3",
    value: "#783F04",
  },
  {
    isBrightColor: false,
    name: "dark yellow 3",
    value: "#7E6000",
  },
  {
    isBrightColor: false,
    name: "dark green 3",
    value: "#274E12",
  },
  {
    isBrightColor: false,
    name: "dark cyan 3",
    value: "#0D343D",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 3",
    value: "#1B4487",
  },
  {
    isBrightColor: false,
    name: "dark blue 3",
    value: "#083763",
  },
  {
    isBrightColor: false,
    name: "dark purple 3",
    value: "#1F124D",
  },
  {
    isBrightColor: false,
    name: "dark magenta 3",
    value: "#4C1130",
  },
];

export const DEFAULT_CUSTOM_COLORS = [
  {
    isBrightColor: false,
    name: "dark orange 3",
    value: "#783F04",
  },
  {
    isBrightColor: false,
    name: "dark grey 3",
    value: "#666666",
  },
  {
    isBrightColor: false,
    name: "dark grey 2",
    value: "#999999",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 1",
    value: "#6C9EEB",
  },
  {
    isBrightColor: false,
    name: "dark magenta 3",
    value: "#4C1130",
  },
];

// ========== FILE END: ui/primitives/color-picker/color-constants.ts ==========



// ========== FILE START: ui/primitives/color-picker/color-dropdown-menu-items.tsx ==========
"use client";

import * as React from "react";

import type { DropdownMenuItemProps } from "@radix-ui/react-dropdown-menu";

import { buttonVariants } from "@/components/ui/button";
import { DropdownMenuItem } from "@/components/ui/dropdown-menu";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";

export type TColor = {
  isBrightColor: boolean;
  name: string;
  value: string;
};

type ColorDropdownMenuItemProps = {
  isBrightColor: boolean;
  isSelected: boolean;
  value: string;
  updateColor: (color: string) => void;
  name?: string;
} & DropdownMenuItemProps;

export function ColorDropdownMenuItem({
  className,
  isBrightColor,
  isSelected,
  name,
  updateColor,
  value,
  ...props
}: ColorDropdownMenuItemProps) {
  const content = (
    <DropdownMenuItem
      className={cn(
        buttonVariants({
          size: "icon",
          variant: "outline",
        }),
        "my-1 flex size-6 items-center justify-center rounded-full border border-solid border-muted p-0 transition-all hover:scale-125",
        !isBrightColor && "border-transparent",
        isSelected && "border-2 border-primary",
        className,
      )}
      style={{ backgroundColor: value }}
      onSelect={(e) => {
        e.preventDefault();
        updateColor(value);
      }}
      {...props}
    />
  );

  return name ? (
    <Tooltip>
      <TooltipTrigger>{content}</TooltipTrigger>
      <TooltipContent className="mb-1 capitalize">{name}</TooltipContent>
    </Tooltip>
  ) : (
    content
  );
}

type ColorDropdownMenuItemsProps = {
  colors: TColor[];
  updateColor: (color: string) => void;
  color?: string;
} & React.ComponentProps<"div">;

export function ColorDropdownMenuItems({
  className,
  color,
  colors,
  updateColor,
  ...props
}: ColorDropdownMenuItemsProps) {
  return (
    <div
      className={cn(
        "grid grid-cols-[repeat(10,1fr)] place-items-center gap-x-1",
        className,
      )}
      {...props}
    >
      <TooltipProvider>
        {colors.map(({ isBrightColor, name, value }) => (
          <ColorDropdownMenuItem
            name={name}
            key={name ?? value}
            value={value}
            isBrightColor={isBrightColor}
            isSelected={color === value}
            updateColor={updateColor}
          />
        ))}
        {props.children}
      </TooltipProvider>
    </div>
  );
}

// ========== FILE END: ui/primitives/color-picker/color-dropdown-menu-items.tsx ==========



// ========== FILE START: ui/primitives/color-picker/color-dropdown-menu.tsx ==========
"use client";

import type { DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import {
  useColorDropdownMenu,
  useColorDropdownMenuState,
} from "@udecode/plate-font/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

import { DEFAULT_COLORS, DEFAULT_CUSTOM_COLORS } from "./color-constants";
import { ColorPicker } from "./color-picker";
import { ToolbarButton } from "../../menus/toolbars/toolbar";

type ColorDropdownMenuProps = {
  nodeType: string;
  tooltip?: string;
} & DropdownMenuProps;

export function ColorDropdownMenu({
  children,
  nodeType,
  tooltip,
}: ColorDropdownMenuProps) {
  const state = useColorDropdownMenuState({
    closeOnSelect: true,
    colors: DEFAULT_COLORS,
    customColors: DEFAULT_CUSTOM_COLORS,
    nodeType,
  });

  const { buttonProps, menuProps } = useColorDropdownMenu(state);

  return (
    <DropdownMenu modal={false} {...menuProps}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton tooltip={tooltip} {...buttonProps}>
          {children}
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="start">
        <ColorPicker
          color={state.selectedColor || state.color}
          clearColor={state.clearColor}
          colors={state.colors}
          customColors={state.customColors}
          updateColor={state.updateColorAndClose}
          updateCustomColor={state.updateColor}
        />
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

// ========== FILE END: ui/primitives/color-picker/color-dropdown-menu.tsx ==========



// ========== FILE START: ui/primitives/color-picker/color-input.tsx ==========
"use client";

import * as React from "react";

import { useColorInput } from "@udecode/plate-font/react";
import { useComposedRef } from "@udecode/plate/react";

import { cn } from "@/lib/utils";

export function ColorInput({
  children,
  className,
  value = "#000000",
  ...props
}: React.ComponentProps<"input">) {
  const { childProps, inputRef } = useColorInput();

  return (
    <div className="flex flex-col items-center">
      {React.Children.map(children, (child) => {
        if (!child) return child;

        return React.cloneElement(child as React.ReactElement, childProps);
      })}
      <input
        {...props}
        ref={useComposedRef(props.ref, inputRef)}
        className={cn("size-0 overflow-hidden border-0 p-0", className)}
        value={value}
        type="color"
      />
    </div>
  );
}

// ========== FILE END: ui/primitives/color-picker/color-input.tsx ==========



// ========== FILE START: ui/primitives/color-picker/color-picker.tsx ==========
"use client";

import * as React from "react";

import { EraserIcon } from "lucide-react";

import { DropdownMenuItem } from "@/components/ui/dropdown-menu";
import { cn } from "@/lib/utils";
import { ToolbarMenuGroup } from "../../menus/toolbars/toolbar";

import {
  type TColor,
  ColorDropdownMenuItems,
} from "./color-dropdown-menu-items";
import { ColorCustom } from "./colors-custom";

type ColorPickerContentProps = React.ComponentProps<"div"> & {
  colors: TColor[];
  customColors: TColor[];
  clearColor: () => void;
  updateColor: (color: string) => void;
  updateCustomColor: (color: string) => void;
  color?: string;
};

export function ColorPickerContent({
  className,
  clearColor,
  color,
  colors,
  customColors,
  updateColor,
  updateCustomColor,
  ...props
}: ColorPickerContentProps) {
  return (
    <div className={cn("flex flex-col", className)} {...props}>
      <ToolbarMenuGroup label="Custom Colors">
        <ColorCustom
          color={color}
          className="px-2"
          colors={colors}
          customColors={customColors}
          updateColor={updateColor}
          updateCustomColor={updateCustomColor}
        />
      </ToolbarMenuGroup>
      <ToolbarMenuGroup label="Default Colors">
        <ColorDropdownMenuItems
          color={color}
          className="px-2"
          colors={colors}
          updateColor={updateColor}
        />
      </ToolbarMenuGroup>
      {color && (
        <ToolbarMenuGroup>
          <DropdownMenuItem className="p-2" onClick={clearColor}>
            <EraserIcon />
            <span>Clear</span>
          </DropdownMenuItem>
        </ToolbarMenuGroup>
      )}
    </div>
  );
}

export const ColorPicker = React.memo(
  ColorPickerContent,
  (prev, next) =>
    prev.color === next.color &&
    prev.colors === next.colors &&
    prev.customColors === next.customColors,
);

// ========== FILE END: ui/primitives/color-picker/color-picker.tsx ==========



// ========== FILE START: ui/primitives/color-picker/colors-custom.tsx ==========
"use client";

import * as React from "react";

import {
  useColorsCustom,
  useColorsCustomState,
} from "@udecode/plate-font/react";
import { PlusIcon } from "lucide-react";

import { buttonVariants } from "@/components/ui/button";
// import { ColorInput } from './color-input';
import { DropdownMenuItem } from "@/components/ui/dropdown-menu";
import { cn } from "@/lib/utils";

import {
  type TColor,
  ColorDropdownMenuItems,
} from "./color-dropdown-menu-items";
import { ColorInput } from "./color-input";

type ColorCustomProps = {
  colors: TColor[];
  customColors: TColor[];
  updateColor: (color: string) => void;
  updateCustomColor: (color: string) => void;
  color?: string;
} & React.ComponentPropsWithoutRef<"div">;

export function ColorCustom({
  className,
  color,
  colors,
  customColors,
  updateColor,
  updateCustomColor,
  ...props
}: ColorCustomProps) {
  const state = useColorsCustomState({
    color,
    colors,
    customColors,
    updateCustomColor,
  });
  const { inputProps, menuItemProps } = useColorsCustom(state);

  return (
    <div className={cn("relative flex flex-col gap-4", className)} {...props}>
      <ColorDropdownMenuItems
        color={color}
        colors={state.computedColors}
        updateColor={updateColor}
      >
        <ColorInput {...inputProps}>
          <DropdownMenuItem
            className={cn(
              buttonVariants({
                size: "icon",
                variant: "outline",
              }),
              "absolute top-1 right-2 bottom-2 flex size-8 items-center justify-center rounded-full",
            )}
            {...menuItemProps}
          >
            <span className="sr-only">Custom</span>
            <PlusIcon />
          </DropdownMenuItem>
        </ColorInput>
      </ColorDropdownMenuItems>
    </div>
  );
}

// ========== FILE END: ui/primitives/color-picker/colors-custom.tsx ==========



// ========== FILE START: ui/primitives/cursor-overlay.tsx ==========
"use client";

import * as React from "react";

import { RangeApi } from "@udecode/plate";
import { AIChatPlugin } from "@udecode/plate-ai/react";
import {
  type CursorData,
  type CursorOverlayState,
  useCursorOverlay,
} from "@udecode/plate-selection/react";
import { usePluginOption } from "@udecode/plate/react";

import { cn } from "@/lib/utils";

export function Cursor({
  id,
  caretPosition,
  data,
  selection,
  selectionRects,
}: CursorOverlayState<CursorData>) {
  const streaming = usePluginOption(AIChatPlugin, "streaming");
  const { style, selectionStyle = style } = data ?? ({} as CursorData);
  const isCursor = RangeApi.isCollapsed(selection);

  if (streaming) return null;

  return (
    <>
      {selectionRects.map((position, i) => {
        return (
          <div
            key={i}
            className={cn(
              "pointer-events-none absolute z-10",
              id === "selection" && "bg-brand/25",
              id === "selection" && isCursor && "bg-primary",
            )}
            style={{
              ...selectionStyle,
              ...position,
            }}
          />
        );
      })}
      {caretPosition && (
        <div
          className={cn(
            "pointer-events-none absolute z-10 w-0.5",
            id === "drag" && "w-px bg-brand",
          )}
          style={{ ...caretPosition, ...style }}
        />
      )}
    </>
  );
}

export function CursorOverlay() {
  const { cursors } = useCursorOverlay();

  return (
    <>
      {cursors.map((cursor) => (
        <Cursor key={cursor.id} {...cursor} />
      ))}
    </>
  );
}

// ========== FILE END: ui/primitives/cursor-overlay.tsx ==========



// ========== FILE START: ui/primitives/draggable.tsx ==========
"use client";

import * as React from "react";

import { isType } from "@udecode/plate";
import { BlockquotePlugin } from "@udecode/plate-block-quote/react";
import { CodeBlockPlugin } from "@udecode/plate-code-block/react";
import { useDraggable, useDropLine } from "@udecode/plate-dnd";
import { ExcalidrawPlugin } from "@udecode/plate-excalidraw/react";
import { HEADING_KEYS } from "@udecode/plate-heading";
import { ColumnItemPlugin, ColumnPlugin } from "@udecode/plate-layout/react";
import {
  ImagePlugin,
  MediaEmbedPlugin,
  PlaceholderPlugin,
} from "@udecode/plate-media/react";
import { BlockSelectionPlugin } from "@udecode/plate-selection/react";
import {
  TableCellPlugin,
  TablePlugin,
  TableRowPlugin,
} from "@udecode/plate-table/react";
import { TogglePlugin } from "@udecode/plate-toggle/react";
import {
  type PlateElementProps,
  type RenderNodeWrapper,
  MemoizedChildren,
  ParagraphPlugin,
  useEditorRef,
  useElement,
  usePath,
  usePluginOption,
} from "@udecode/plate/react";
import { useReadOnly, useSelected } from "@udecode/plate/react";
import { GripVertical } from "lucide-react";

import { Button } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";
import { STRUCTURAL_TYPES } from "../../core/transforms";

const UNDRAGGABLE_KEYS = [
  ColumnItemPlugin.key,
  TableRowPlugin.key,
  TableCellPlugin.key,
];

export const DraggableAboveNodes: RenderNodeWrapper = (props) => {
  const { editor, element, path } = props;
  const readOnly = useReadOnly();

  const enabled = React.useMemo(() => {
    if (readOnly) return false;
    if (path.length === 1 && !isType(editor, element, UNDRAGGABLE_KEYS)) {
      return true;
    }
    if (path.length === 3 && !isType(editor, element, UNDRAGGABLE_KEYS)) {
      const block = editor.api.some({
        at: path,
        match: {
          type: editor.getType(ColumnPlugin),
        },
      });

      if (block) {
        return true;
      }
    }
    if (path.length === 4 && !isType(editor, element, UNDRAGGABLE_KEYS)) {
      const block = editor.api.some({
        at: path,
        match: {
          type: editor.getType(TablePlugin),
        },
      });

      if (block) {
        return true;
      }
    }

    return false;
  }, [editor, element, path, readOnly]);

  if (!enabled) return;

  const WrappedDraggable = (innerProps: PlateElementProps) => (
    <Draggable {...innerProps} />
  );
  WrappedDraggable.displayName = "WrappedDraggable";
  return WrappedDraggable;
};

export function Draggable(props: PlateElementProps) {
  const { children, editor, element, path } = props;
  const blockSelectionApi = editor.getApi(BlockSelectionPlugin).blockSelection;
  const { isDragging, previewRef, handleRef } = useDraggable({
    element,
    onDropHandler: (_, { dragItem }) => {
      const id = (dragItem as { id: string }).id;

      if (blockSelectionApi && id) {
        blockSelectionApi.set(id);
      }
    },
  });

  const isInColumn = path.length === 3;
  const isInTable = path.length === 4;

  return (
    <div
      className={cn(
        "relative",
        isDragging && "opacity-50",
        STRUCTURAL_TYPES.includes(element.type) ? "group/structural" : "group",
      )}
    >
      {!isInTable && (
        <Gutter>
          <div
            className={cn(
              "slate-blockToolbarWrapper",
              "flex h-[1.5em]",
              isType(editor, element, [
                HEADING_KEYS.h1,
                HEADING_KEYS.h2,
                HEADING_KEYS.h3,
                HEADING_KEYS.h4,
                HEADING_KEYS.h5,
              ]) && "h-[1.3em]",
              isInColumn && "h-4",
            )}
          >
            <div
              className={cn(
                "slate-blockToolbar",
                "pointer-events-auto mr-1 flex items-center",
                isInColumn && "mr-1.5",
              )}
            >
              <Button
                ref={handleRef}
                variant="ghost"
                className="h-6 w-4.5 p-0"
                data-plate-prevent-deselect
              >
                <DragHandle />
              </Button>
            </div>
          </div>
        </Gutter>
      )}

      <div ref={previewRef} className="slate-blockWrapper">
        <MemoizedChildren>{children}</MemoizedChildren>
        <DropLine />
      </div>
    </div>
  );
}
Draggable.displayName = "Draggable";

function Gutter({
  children,
  className,
  ...props
}: React.ComponentProps<"div">) {
  const editor = useEditorRef();
  const element = useElement();
  const path = usePath();
  const isSelectionAreaVisible = usePluginOption(
    BlockSelectionPlugin,
    "isSelectionAreaVisible",
  );
  const selected = useSelected();

  const isNodeType = (keys: string[] | string) => isType(editor, element, keys);

  const isInColumn = path.length === 3;

  return (
    <div
      {...props}
      className={cn(
        "slate-gutterLeft",
        "absolute top-0 z-50 flex h-full -translate-x-full cursor-text hover:opacity-100 sm:opacity-0",
        STRUCTURAL_TYPES.includes(element.type)
          ? "group-hover/structural:opacity-100"
          : "group-hover:opacity-100",
        isSelectionAreaVisible && "hidden",
        !selected && "opacity-0",
        isNodeType(HEADING_KEYS.h1) && "pb-1 text-[1.875em]",
        isNodeType(HEADING_KEYS.h2) && "pb-1 text-[1.5em]",
        isNodeType(HEADING_KEYS.h3) && "pt-[2px] pb-1 text-[1.25em]",
        isNodeType([HEADING_KEYS.h4, HEADING_KEYS.h5]) &&
          "pt-1 pb-0 text-[1.1em]",
        isNodeType(HEADING_KEYS.h6) && "pb-0",
        isNodeType(ParagraphPlugin.key) && "pt-1 pb-0",
        isNodeType(["ul", "ol"]) && "pb-0",
        isNodeType(BlockquotePlugin.key) && "pb-0",
        isNodeType(CodeBlockPlugin.key) && "pt-6 pb-0",
        isNodeType([
          ImagePlugin.key,
          MediaEmbedPlugin.key,
          ExcalidrawPlugin.key,
          TogglePlugin.key,
          ColumnPlugin.key,
        ]) && "py-0",
        isNodeType([PlaceholderPlugin.key, TablePlugin.key]) && "pt-3 pb-0",
        isInColumn && "mt-2 h-4 pt-0",
        className,
      )}
      contentEditable={false}
    >
      {children}
    </div>
  );
}
Gutter.displayName = "Gutter";

const DragHandle = React.memo(function DragHandle() {
  const editor = useEditorRef();
  const element = useElement();

  return (
    <Tooltip>
      <TooltipTrigger asChild>
        <div
          className="flex size-full items-center justify-center"
          onClick={() => {
            editor
              .getApi(BlockSelectionPlugin)
              .blockSelection.set(element.id as string);
          }}
          role="button"
        >
          <GripVertical className="text-muted-foreground" />
        </div>
      </TooltipTrigger>
      <TooltipContent>Drag to move</TooltipContent>
    </Tooltip>
  );
});
DragHandle.displayName = "DragHandle";

function DropLine({ className, ...props }: React.ComponentProps<"div">) {
  const editor = useEditorRef();
  const isSelectionAreaVisible = usePluginOption(
    BlockSelectionPlugin,
    "isSelectionAreaVisible",
  );
  const { dropLine } = useDropLine(editor);

  return (
    <div
      {...props}
      className={cn(
        "absolute z-50 h-0.5 w-full opacity-0",
        isSelectionAreaVisible
          ? "bg-blue-500 dark:bg-blue-300"
          : "bg-slate-400 dark:bg-slate-300",
        dropLine,
        className,
      )}
    />
  );
}
DropLine.displayName = "DropLine";

// ========== FILE END: ui/primitives/draggable.tsx ==========



// ========== FILE START: ui/primitives/editor-static.tsx ==========
import * as React from "react";

import type { VariantProps } from "class-variance-authority";

import { type PlateStaticProps, PlateStatic } from "@udecode/plate";
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils";

export const editorVariants = cva(
  cn(
    "group/editor",
    "relative w-full cursor-text overflow-x-hidden break-words whitespace-pre-wrap select-text",
    "rounded-md ring-offset-background focus-visible:outline-none",
    "placeholder:text-muted-foreground/80 **:data-slate-placeholder:top-[auto_!important] **:data-slate-placeholder:text-muted-foreground/80 **:data-slate-placeholder:opacity-100!",
    "[&_strong]:font-bold",
  ),
  {
    defaultVariants: {
      variant: "none",
    },
    variants: {
      disabled: {
        true: "cursor-not-allowed opacity-50",
      },
      focused: {
        true: "ring-2 ring-ring ring-offset-2",
      },
      variant: {
        ai: "w-full px-0 text-base md:text-sm",
        aiChat:
          "max-h-[min(70vh,320px)] w-full max-w-[700px] overflow-y-auto px-5 py-3 text-base md:text-sm",
        default:
          "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        demo: "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        fullWidth: "size-full px-16 pt-4 pb-72 text-base sm:px-24",
        none: "",
        select: "px-3 py-2 text-base data-readonly:w-fit",
      },
    },
  },
);

export function EditorStatic({
  className,
  variant,
  ...props
}: PlateStaticProps & VariantProps<typeof editorVariants>) {
  return (
    <PlateStatic
      className={cn(editorVariants({ variant }), className)}
      {...props}
    />
  );
}

// ========== FILE END: ui/primitives/editor-static.tsx ==========



// ========== FILE START: ui/primitives/editor.tsx ==========
"use client";

import * as React from "react";

import type { PlateContentProps } from "@udecode/plate/react";
import type { VariantProps } from "class-variance-authority";

import { PlateContainer, PlateContent } from "@udecode/plate/react";
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils";

const editorContainerVariants = cva(
  "relative w-full cursor-text overflow-y-auto caret-primary select-text selection:bg-brand/25 focus-visible:outline-none [&_.slate-selection-area]:z-50 [&_.slate-selection-area]:border [&_.slate-selection-area]:border-brand/25 [&_.slate-selection-area]:bg-brand/15",
  {
    defaultVariants: {
      variant: "default",
    },
    variants: {
      variant: {
        comment: cn(
          "flex flex-wrap justify-between gap-1 px-1 py-0.5 text-sm",
          "rounded-md border-[1.5px] border-transparent bg-transparent",
          "has-[[data-slate-editor]:focus]:border-brand/50 has-[[data-slate-editor]:focus]:ring-2 has-[[data-slate-editor]:focus]:ring-brand/30",
          "has-aria-disabled:border-input has-aria-disabled:bg-muted",
        ),
        default: "h-full",
        demo: "h-[650px]",
        select: cn(
          "group rounded-md border border-input ring-offset-background focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2",
          "has-data-readonly:w-fit has-data-readonly:cursor-default has-data-readonly:border-transparent has-data-readonly:focus-within:[box-shadow:none]",
        ),
      },
    },
  },
);

export const EditorContainer = ({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> &
  VariantProps<typeof editorContainerVariants>) => {
  return (
    <PlateContainer
      className={cn(
        "ignore-click-outside/toolbar",
        editorContainerVariants({ variant }),
        className,
      )}
      {...props}
    />
  );
};

EditorContainer.displayName = "EditorContainer";

const editorVariants = cva(
  cn(
    "group/editor",
    "relative w-full cursor-text overflow-x-hidden break-words whitespace-pre-wrap select-text",
    "rounded-md ring-offset-background focus-visible:outline-none",
    "placeholder:text-muted-foreground/80 **:data-slate-placeholder:top-[auto_!important] **:data-slate-placeholder:text-muted-foreground/80 **:data-slate-placeholder:opacity-100!",
    "[&_strong]:font-bold",
  ),
  {
    defaultVariants: {
      variant: "default",
    },
    variants: {
      disabled: {
        true: "cursor-not-allowed opacity-50",
      },
      focused: {
        true: "ring-2 ring-ring ring-offset-2",
      },
      variant: {
        ai: "w-full px-0 text-base md:text-sm",
        aiChat:
          "max-h-[min(70vh,320px)] w-full max-w-[700px] overflow-y-auto px-3 py-2 text-base md:text-sm",
        comment: cn("rounded-none border-none bg-transparent text-sm"),
        default:
          "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        demo: "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        fullWidth: "size-full px-16 pt-4 pb-72 text-base sm:px-24",
        none: "",
        select: "px-3 py-2 text-base data-readonly:w-fit",
      },
    },
  },
);

export type EditorProps = PlateContentProps &
  VariantProps<typeof editorVariants>;

export const Editor = React.forwardRef<HTMLDivElement, EditorProps>(
  ({ className, disabled, focused, variant, ...props }, ref) => {
    return (
      <PlateContent
        ref={ref}
        className={cn(
          editorVariants({
            disabled,
            focused,
            variant,
          }),
          className,
        )}
        disabled={disabled}
        disableDefaultStyles
        {...props}
      />
    );
  },
);

Editor.displayName = "Editor";

// ========== FILE END: ui/primitives/editor.tsx ==========



// ========== FILE START: ui/primitives/ghost-text.tsx ==========
"use client";

import * as React from "react";

import { CopilotPlugin } from "@udecode/plate-ai/react";
import { useElement, usePluginOption } from "@udecode/plate/react";

export const GhostText = () => {
  const element = useElement();

  const isSuggested = usePluginOption(
    CopilotPlugin,
    "isSuggested",
    element.id as string,
  );

  if (!isSuggested) return null;

  return <GhostTextContent />;
};

export function GhostTextContent() {
  const suggestionText = usePluginOption(CopilotPlugin, "suggestionText");

  return (
    <span
      className="pointer-events-none text-muted-foreground/70 max-sm:hidden"
      contentEditable={false}
    >
      {suggestionText && suggestionText}
    </span>
  );
}

// ========== FILE END: ui/primitives/ghost-text.tsx ==========



// ========== FILE START: ui/primitives/index.ts ==========
export * from "./block-selection";
export * from "./caption";
export * from "./cursor-overlay";
export * from "./editor-static";
export * from "./editor";

// ========== FILE END: ui/primitives/index.ts ==========



// ========== FILE START: ui/primitives/placeholder.tsx ==========
"use client";

import * as React from "react";

import { HEADING_KEYS } from "@udecode/plate-heading";
import { ParagraphPlugin } from "@udecode/plate/react";
import {
  type PlaceholderProps,
  createNodeHOC,
  createNodesHOC,
  usePlaceholderState,
} from "@udecode/plate/react";

import { cn } from "@/lib/utils";

export const Placeholder = (props: PlaceholderProps) => {
  const { attributes, children, placeholder } = props;

  const { enabled } = usePlaceholderState(props);

  return React.Children.map(children, (child) => {
    return React.cloneElement(child, {
      attributes: {
        ...attributes,
        className: cn(
          attributes.className,
          enabled &&
            "before:absolute before:cursor-text before:opacity-30 before:content-[attr(placeholder)]",
        ),
        placeholder,
      },
    });
  });
};

export const withPlaceholder = createNodeHOC(Placeholder);

export const withPlaceholdersPrimitive = createNodesHOC(Placeholder);

export const withPlaceholders = (components: any) =>
  withPlaceholdersPrimitive(components, [
    {
      key: ParagraphPlugin.key,
      hideOnBlur: true,
      placeholder: "Type a paragraph",
      query: {
        maxLevel: 1,
      },
    },
    {
      key: HEADING_KEYS.h1,
      hideOnBlur: false,
      placeholder: "Untitled",
    },
  ]);

// ========== FILE END: ui/primitives/placeholder.tsx ==========



// ========== FILE START: ui/primitives/resize-handle.tsx ==========
"use client";

import * as React from "react";

import type { VariantProps } from "class-variance-authority";

import {
  type ResizeHandle as ResizeHandlePrimitive,
  Resizable as ResizablePrimitive,
  useResizeHandle,
  useResizeHandleState,
} from "@udecode/plate-resizable";
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils";

export const mediaResizeHandleVariants = cva(
  cn(
    "top-0 flex w-6 flex-col justify-center select-none",
    "after:flex after:h-16 after:w-[3px] after:rounded-[6px] after:bg-ring after:opacity-0 after:content-['_'] group-hover:after:opacity-100",
  ),
  {
    variants: {
      direction: {
        left: "-left-3 -ml-3 pl-3",
        right: "-right-3 -mr-3 items-end pr-3",
      },
    },
  },
);

const resizeHandleVariants = cva(cn("absolute z-40"), {
  variants: {
    direction: {
      bottom: "w-full cursor-row-resize",
      left: "h-full cursor-col-resize",
      right: "h-full cursor-col-resize",
      top: "w-full cursor-row-resize",
    },
  },
});

export function ResizeHandle({
  className,
  direction,
  options,
  ...props
}: React.ComponentProps<typeof ResizeHandlePrimitive> &
  VariantProps<typeof resizeHandleVariants>) {
  const state = useResizeHandleState(options ?? {});
  const resizeHandle = useResizeHandle(state);

  if (state.readOnly) return null;

  return (
    <div
      className={cn(resizeHandleVariants({ direction }), className)}
      data-resizing={state.isResizing}
      {...resizeHandle.props}
      {...props}
    />
  );
}

const resizableVariants = cva("", {
  variants: {
    align: {
      center: "mx-auto",
      left: "mr-auto",
      right: "ml-auto",
    },
  },
});

export function Resizable({
  align,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive> &
  VariantProps<typeof resizableVariants>) {
  return (
    <ResizablePrimitive
      {...props}
      className={cn(resizableVariants({ align }), className)}
    />
  );
}

// ========== FILE END: ui/primitives/resize-handle.tsx ==========